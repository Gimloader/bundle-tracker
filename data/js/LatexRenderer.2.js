function e(e, t, a, i) {
    Object.defineProperty(e, t, {
        get: a,
        set: i,
        enumerable: !0,
        configurable: !0
    })
}("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {}).parcelRequire388b.register("mS2fe", (function(t, a) {
    function i(e) {
        return Array.isArray(e)
    }

    function o() {
        return "window" in globalThis && "document" in globalThis
    }

    function r() {
        if (!o()) throw new Error("<math-field> is an interactive component that needs to run in a browser environment\nIf you are using nextjs, see https://nextjs.org/docs/advanced-features/dynamic-import#with-no-ssr")
    }

    function n() {
        return !!o() && ("matchMedia" in globalThis ? globalThis.matchMedia("(any-pointer: coarse)").matches : "ontouchstart" in globalThis || navigator.maxTouchPoints > 0)
    }

    function s() {
        return o() && "function" == typeof navigator.vibrate
    }

    function l() {
        var e, t;
        if (!o()) return "other";
        const a = null !== (t = null === (e = navigator.userAgentData) || void 0 === e ? void 0 : e.platform) && void 0 !== t ? t : navigator.platform;
        return /^mac/i.test(a) ? 5 === navigator.maxTouchPoints ? "ios" : "macos" : /^win/i.test(a) ? "windows" : /android/i.test(navigator.userAgent) ? "android" : /iphone|ipod|ipad/i.test(navigator.userAgent) ? "ios" : /\bcros\b/i.test(navigator.userAgent) ? "chromeos" : "other"
    }

    function d() {
        if (!o()) return !0;
        if (/firefox/i.test(navigator.userAgent)) {
            const e = navigator.userAgent.match(/firefox\/(\d+)/i);
            return !!e && parseInt(e[1]) >= 78
        }
        if (/trident/i.test(navigator.userAgent)) return !1;
        if (/edge/i.test(navigator.userAgent)) {
            const e = navigator.userAgent.match(/edg\/(\d+)/i);
            return !!e && parseInt(e[1]) >= 79
        }
        return !0
    }
    e(t.exports, "MathfieldElement", (function() {
        return fn
    })), e(t.exports, "renderMathInElement", (function() {
        return Kn
    }));
    const c = {
        strings: {
            en: {
                "keyboard.tooltip.functions": "Functions",
                "keyboard.tooltip.symbols": "Symbols",
                "keyboard.tooltip.greek": "Greek Letters",
                "keyboard.tooltip.command": "LaTeX Command Mode",
                "keyboard.tooltip.numeric": "Numeric",
                "keyboard.tooltip.roman": "Roman Letters",
                "tooltip.copy to clipboard": "Copy to Clipboard",
                "tooltip.redo": "Redo",
                "tooltip.toggle virtual keyboard": "Toggle Virtual Keyboard",
                "tooltip.undo": "Undo",
                "menu.insert matrix": "Insert Matrix",
                "menu.insert vector": "Insert Vector",
                "submenu.array.matrix delimiters": "Matrix Delimiters",
                "menu.array.add row above": "Add Row After",
                "menu.array.add row below": "Add Row Before",
                "menu.array.add column after": "Add Column After",
                "menu.array.add column before": "Add Column Before",
                "menu.array.delete row": "Delete Row",
                "menu.array.delete rows": "Delete Selected Rows",
                "menu.array.delete column": "Delete Column",
                "menu.array.delete columns": "Delete Selected Columns",
                "submenu.array.insert separator": "Insert Separator",
                "menu.insert table": "Insert Table",
                "submenu.table style": "Table Style"
            },
            ar: {
                "keyboard.tooltip.functions": "مهام",
                "keyboard.tooltip.symbols": "حرف او رمز",
                "keyboard.tooltip.greek": "حروف يونانية",
                "keyboard.tooltip.command": "حالة تلقي الأوامر اللاتك",
                "keyboard.tooltip.numeric": "الرقمية",
                "keyboard.tooltip.roman": "رموز الاحرف الرومانية",
                "tooltip.copy to clipboard": "نسخ إلى الحافظة",
                "tooltip.redo": "الإعادة",
                "tooltip.toggle virtual keyboard": "تبديل لوحة المفاتيح الإفتراضية",
                "tooltip.undo": "إلغاء",
                "menu.insert matrix": "أدخل المصفوفة",
                "menu.insert vector": "أدخل متجه",
                "submenu.array.matrix delimiters": "محددات المصفوفة",
                "menu.array.add row above": "أضف صفًا بعد ذلك",
                "menu.array.add row below": "أضف الصف قبل",
                "menu.array.add column after": "أضف العمود بعد ذلك",
                "menu.array.add column before": "أضف العمود قبل",
                "menu.array.delete row": "احذف صف",
                "menu.array.delete rows": "حذف الصفوف المحددة",
                "menu.array.delete column": "حذف العمود",
                "menu.array.delete columns": "حذف الأعمدة المحددة",
                "submenu.array.insert separator": "أدخل فاصل",
                "menu.insert table": "إدراج جدول",
                "submenu.table style": "نمط الجدول"
            },
            bg: {
                "keyboard.tooltip.functions": "Функции",
                "keyboard.tooltip.symbols": "Символи",
                "keyboard.tooltip.greek": "Гръцки букви",
                "keyboard.tooltip.command": "Команден режим на латекс",
                "keyboard.tooltip.numeric": "Числови",
                "keyboard.tooltip.roman": "Римски букви",
                "tooltip.copy to clipboard": "Копиране в клипборда",
                "tooltip.redo": "Повторно",
                "tooltip.toggle virtual keyboard": "Превключване на виртуална клавиатура",
                "tooltip.undo": "Отмяна",
                "menu.insert matrix": "Вмъкване на матрица",
                "menu.insert vector": "Вмъкване на вектор",
                "submenu.array.matrix delimiters": "Матрични разделители",
                "menu.array.add row above": "Добавяне на ред след",
                "menu.array.add row below": "Добавяне на ред преди",
                "menu.array.add column after": "Добавяне на колона след",
                "menu.array.add column before": "Добавяне на колона преди",
                "menu.array.delete row": "Изтриване на реда",
                "menu.array.delete rows": "Изтриване на избраните редове",
                "menu.array.delete column": "Изтриване на колона",
                "menu.array.delete columns": "Изтриване на избраните колони",
                "submenu.array.insert separator": "Поставете разделител",
                "menu.insert table": "Вмъкване на таблица",
                "submenu.table style": "Табличен стил"
            },
            bs: {
                "keyboard.tooltip.functions": "Funkcije",
                "keyboard.tooltip.symbols": "Simboli",
                "keyboard.tooltip.greek": "Grčka slova",
                "keyboard.tooltip.command": "LaTeX naredbeni način",
                "keyboard.tooltip.numeric": "Numerički",
                "keyboard.tooltip.roman": "Rimska slova",
                "tooltip.copy to clipboard": "Kopirati u clipboard",
                "tooltip.redo": "Ponovi",
                "tooltip.toggle virtual keyboard": "Uključi / isključi virtualnu tipkovnicu",
                "tooltip.undo": "Poništi",
                "menu.insert matrix": "Umetni matricu",
                "menu.insert vector": "Umetni vektor",
                "submenu.array.matrix delimiters": "Matrični razdjelnici",
                "menu.array.add row above": "Dodaj redak nakon",
                "menu.array.add row below": "Dodaj red prije",
                "menu.array.add column after": "Dodaj stupac nakon",
                "menu.array.add column before": "Dodaj stupac prije",
                "menu.array.delete row": "Izbriši red",
                "menu.array.delete rows": "Izbriši odabrane redove",
                "menu.array.delete column": "Izbriši stupac",
                "menu.array.delete columns": "Izbriši odabrane stupce",
                "submenu.array.insert separator": "Umetni separator",
                "menu.insert table": "Ubaci tabelu",
                "submenu.table style": "Stil tabele"
            },
            cs: {
                "keyboard.tooltip.functions": "Funkce",
                "keyboard.tooltip.symbols": "Symboly",
                "keyboard.tooltip.greek": "Řecké dopisy",
                "keyboard.tooltip.command": "Příkazový režim LaTeX",
                "keyboard.tooltip.numeric": "Číselné",
                "keyboard.tooltip.roman": "Římské dopisy",
                "tooltip.copy to clipboard": "Zkopírovat do schránky",
                "tooltip.redo": "Předělat",
                "tooltip.toggle virtual keyboard": "Přepnout virtuální klávesnici",
                "tooltip.undo": "Vrátit",
                "menu.insert matrix": "Vložte matici",
                "menu.insert vector": "Vložit vektor",
                "submenu.array.matrix delimiters": "Oddělovače matic",
                "menu.array.add row above": "Přidat řádek za",
                "menu.array.add row below": "Přidat řádek před",
                "menu.array.add column after": "Přidat sloupec za",
                "menu.array.add column before": "Přidat sloupec dříve",
                "menu.array.delete row": "Odstranit řádek",
                "menu.array.delete rows": "Odstranit vybrané řádky",
                "menu.array.delete column": "Odstranit sloupec",
                "menu.array.delete columns": "Odstranit vybrané sloupce",
                "submenu.array.insert separator": "Vložte oddělovač",
                "menu.insert table": "Vložit tabulku",
                "submenu.table style": "Styl tabulky"
            },
            da: {
                "keyboard.tooltip.functions": "Funktioner",
                "keyboard.tooltip.symbols": "Symboler",
                "keyboard.tooltip.greek": "Græske bogstaver",
                "keyboard.tooltip.command": "LaTeX kommandotilstand",
                "keyboard.tooltip.numeric": "Numerisk",
                "keyboard.tooltip.roman": "Romerske breve",
                "tooltip.copy to clipboard": "Kopier til udklipsholder",
                "tooltip.redo": "Gentag igen",
                "tooltip.toggle virtual keyboard": "Skift virtuelt tastatur",
                "tooltip.undo": "Fortryd",
                "menu.insert matrix": "Indsæt matrix",
                "menu.insert vector": "Indsæt vektor",
                "submenu.array.matrix delimiters": "Matrixafgrænsere",
                "menu.array.add row above": "Tilføj række efter",
                "menu.array.add row below": "Tilføj række før",
                "menu.array.add column after": "Tilføj kolonne efter",
                "menu.array.add column before": "Tilføj kolonne før",
                "menu.array.delete row": "Slet række",
                "menu.array.delete rows": "Slet valgte rækker",
                "menu.array.delete column": "Slet kolonne",
                "menu.array.delete columns": "Slet valgte kolonner",
                "submenu.array.insert separator": "Indsæt separator",
                "menu.insert table": "Indsæt tabel",
                "submenu.table style": "Tabelstil"
            },
            de: {
                "keyboard.tooltip.functions": "Funktionen",
                "keyboard.tooltip.symbols": "Symbole",
                "keyboard.tooltip.greek": "Griechische Buchstaben",
                "keyboard.tooltip.command": "LaTeX-Befehlsmodus",
                "keyboard.tooltip.numeric": "Numerisch",
                "keyboard.tooltip.roman": "Römische Buchstaben",
                "tooltip.copy to clipboard": "In die Zwischenablage kopieren",
                "tooltip.redo": "Wiederholen",
                "tooltip.toggle virtual keyboard": "Virtuelle Tastatur umschalten",
                "tooltip.undo": "Widerrufen",
                "menu.insert matrix": "Matrix einfügen",
                "menu.insert vector": "Vektor einfügen",
                "submenu.array.matrix delimiters": "Matrixtrennzeichen",
                "menu.array.add row above": "Zeile hinzufügen nach",
                "menu.array.add row below": "Zeile hinzufügen vor",
                "menu.array.add column after": "Spalte hinzufügen nach",
                "menu.array.add column before": "Spalte hinzufügen vor",
                "menu.array.delete row": "Zeile löschen",
                "menu.array.delete rows": "Ausgewählte Zeilen löschen",
                "menu.array.delete column": "Spalte löschen",
                "menu.array.delete columns": "Ausgewählte Spalten löschen",
                "submenu.array.insert separator": "Trennzeichen einfügen",
                "menu.insert table": "Tabelle einfügen",
                "submenu.table style": "Tabellenstil"
            },
            el: {
                "keyboard.tooltip.functions": "συναρτήσεις",
                "keyboard.tooltip.symbols": "σύμβολα",
                "keyboard.tooltip.greek": "ελληνικά γράμματα",
                "keyboard.tooltip.command": "Λειτουργία εντολών LaTeX",
                "keyboard.tooltip.numeric": "Αριθμητικός",
                "keyboard.tooltip.roman": "Ρωμαϊκά γράμματα",
                "tooltip.copy to clipboard": "Αντιγραφή στο πρόχειρο",
                "tooltip.redo": "Ξανακάνω",
                "tooltip.toggle virtual keyboard": "Εναλλαγή εικονικού πληκτρολογίου",
                "tooltip.undo": "Ξεκάνω",
                "menu.insert matrix": "Εισαγωγή Matrix",
                "menu.insert vector": "Εισαγωγή διανύσματος",
                "submenu.array.matrix delimiters": "Οριοθέτες Matrix",
                "menu.array.add row above": "Προσθήκη σειράς μετά",
                "menu.array.add row below": "Προσθήκη σειράς πριν",
                "menu.array.add column after": "Προσθήκη στήλης μετά",
                "menu.array.add column before": "Προσθήκη στήλης πριν",
                "menu.array.delete row": "Διαγραφή σειράς",
                "menu.array.delete rows": "Διαγραφή επιλεγμένων σειρών",
                "menu.array.delete column": "Διαγραφή στήλης",
                "menu.array.delete columns": "Διαγραφή επιλεγμένων στηλών",
                "submenu.array.insert separator": "Εισαγωγή διαχωριστικού",
                "menu.insert table": "Εισαγωγή πίνακα",
                "submenu.table style": "Στυλ πίνακα"
            },
            es: {
                "keyboard.tooltip.functions": "Funciones",
                "keyboard.tooltip.symbols": "Símbolos",
                "keyboard.tooltip.greek": "Letras griegas",
                "keyboard.tooltip.command": "Modo Comando LaTeX",
                "keyboard.tooltip.numeric": "Numérico",
                "keyboard.tooltip.roman": "Letras romanas",
                "tooltip.copy to clipboard": "Copiar al portapapeles",
                "tooltip.redo": "Rehacer",
                "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
                "tooltip.undo": "Deshacer",
                "menu.insert matrix": "Añadir Matriz",
                "menu.insert vector": "Añadir vector",
                "submenu.array.matrix delimiters": "Delimitadores de Matriz",
                "menu.array.add row above": "Añadir Línea Antes",
                "menu.array.add row below": "Añadir Línea Despues",
                "menu.array.add column after": "Añadir Columna Despues",
                "menu.array.add column before": "Añadir Columna Antes",
                "menu.array.delete row": "Borrar Línea",
                "menu.array.delete rows": "Borrar Líneas Seleccionadas",
                "menu.array.delete column": "Borrar Columna",
                "menu.array.delete columns": "Borrar Columnas Seleccionadas",
                "submenu.array.insert separator": "Insertar un Separador",
                "menu.insert table": "Insertar Tabla",
                "submenu.table style": "Estilo de Tabla"
            },
            et: {
                "keyboard.tooltip.functions": "Funktsioonid",
                "keyboard.tooltip.symbols": "Sümbolid",
                "keyboard.tooltip.greek": "Kreeka kirjad",
                "keyboard.tooltip.command": "LaTeXi käsurežiim",
                "keyboard.tooltip.numeric": "Numbriline",
                "keyboard.tooltip.roman": "Rooma kirjad",
                "tooltip.copy to clipboard": "Kopeerida lõikelauale",
                "tooltip.redo": "Tee uuesti",
                "tooltip.toggle virtual keyboard": "Lülitage sisse virtuaalne klaviatuur",
                "tooltip.undo": "Võta tagasi",
                "menu.insert matrix": "Sisesta maatriks",
                "menu.insert vector": "Sisesta vektor",
                "submenu.array.matrix delimiters": "Maatriksi eraldajad",
                "menu.array.add row above": "Lisa rida pärast",
                "menu.array.add row below": "Lisa rida enne",
                "menu.array.add column after": "Lisa veerg pärast",
                "menu.array.add column before": "Lisa veerg enne",
                "menu.array.delete row": "Kustuta rida",
                "menu.array.delete rows": "Kustuta valitud read",
                "menu.array.delete column": "Kustuta veerg",
                "menu.array.delete columns": "Kustuta valitud veerud",
                "submenu.array.insert separator": "Sisestage eraldaja",
                "menu.insert table": "Sisesta tabeli",
                "submenu.table style": "Tabeli stiilis"
            },
            fa: {
                "keyboard.tooltip.functions": "توابع",
                "keyboard.tooltip.symbols": "نمادها",
                "keyboard.tooltip.greek": "حروف یونانی",
                "keyboard.tooltip.command": "حالت دستور لاتک",
                "keyboard.tooltip.numeric": "عددی",
                "keyboard.tooltip.roman": "حروف رومی",
                "tooltip.copy to clipboard": "کپی به کلیپبورد",
                "tooltip.redo": "بازگشت به بعد",
                "tooltip.toggle virtual keyboard": "نمایش/نهفتن کیبورد مجازی",
                "tooltip.undo": "بازگشت به قبل",
                "menu.insert matrix": "ماتریس را وارد کنید",
                "menu.insert vector": "درج بردار",
                "submenu.array.matrix delimiters": "مرزهای ماتریس",
                "menu.array.add row above": "بعد از آن ردیف اضافه کنید",
                "menu.array.add row below": "ردیف را قبل اضافه کنید",
                "menu.array.add column after": "اضافه کردن ستون بعد",
                "menu.array.add column before": "ستون قبل را اضافه کنید",
                "menu.array.delete row": "ردیف را حذف کنید",
                "menu.array.delete rows": "ردیف های انتخاب شده را حذف کنید",
                "menu.array.delete column": "حذف ستون",
                "menu.array.delete columns": "ستون های انتخاب شده را حذف کنید",
                "submenu.array.insert separator": "درج جدا کننده",
                "menu.insert table": "قرار دادن جدول",
                "submenu.table style": "سبک میز"
            },
            fi: {
                "keyboard.tooltip.functions": "Toiminnot",
                "keyboard.tooltip.symbols": "Symbolit",
                "keyboard.tooltip.greek": "Kreikkalaiset kirjeet",
                "keyboard.tooltip.command": "LaTeX-komentotila",
                "keyboard.tooltip.numeric": "Numeerinen",
                "keyboard.tooltip.roman": "Roomalaiset kirjeet",
                "tooltip.copy to clipboard": "Kopioi leikepöydälle",
                "tooltip.redo": "Tee uudelleen",
                "tooltip.toggle virtual keyboard": "Vaihda virtuaalinäppäimistö",
                "tooltip.undo": "Kumoa",
                "menu.insert matrix": "Lisää matriisi",
                "menu.insert vector": "Lisää vektori",
                "submenu.array.matrix delimiters": "Matriisin erottimet",
                "menu.array.add row above": "Lisää rivi jälkeen",
                "menu.array.add row below": "Lisää rivi ennen",
                "menu.array.add column after": "Lisää sarake jälkeen",
                "menu.array.add column before": "Lisää sarake ennen",
                "menu.array.delete row": "Poista rivi",
                "menu.array.delete rows": "Poista valitut rivit",
                "menu.array.delete column": "Poista sarake",
                "menu.array.delete columns": "Poista valitut sarakkeet",
                "submenu.array.insert separator": "Aseta erotin",
                "menu.insert table": "Lisää taulukko",
                "submenu.table style": "Taulukon tyyli"
            },
            fr: {
                "keyboard.tooltip.functions": "Fonctions",
                "keyboard.tooltip.symbols": "Symboles",
                "keyboard.tooltip.greek": "Lettres grecques",
                "keyboard.tooltip.command": "Mode de commandes LaTeX",
                "keyboard.tooltip.numeric": "Numérique",
                "keyboard.tooltip.roman": "Lettres romaines",
                "tooltip.copy to clipboard": "Copier dans le presse-papiers",
                "tooltip.redo": "Rétablir",
                "tooltip.toggle virtual keyboard": "Afficher/Masquer le clavier virtuel",
                "tooltip.undo": "Annuler",
                "menu.insert matrix": "Insérer une Matrice",
                "menu.insert vector": "Insérer un Vecteur",
                "submenu.array.matrix delimiters": "Délimiteurs de la Matrice",
                "menu.array.add row above": "Ajouter une Ligne Avant",
                "menu.array.add row below": "Ajouter une Ligne Après",
                "menu.array.add column before": "Ajouter une Colonne Avant",
                "menu.array.add column after": "Ajouter une Colonne Après",
                "menu.array.delete row": "Enlever une Ligne",
                "menu.array.delete rows": "Enlever les Lignes Sélectionées",
                "menu.array.delete column": "Enlever une Colone",
                "menu.array.delete columns": "Enlever les Colonnes Sélectionées",
                "submenu.array.insert separator": "Insérer un Séparateur",
                "menu.insert table": "Insérer une Table",
                "submenu.table style": "Style de la  Table"
            },
            ga: {
                "keyboard.tooltip.functions": "Feidhmeanna",
                "keyboard.tooltip.symbols": "Siombailí",
                "keyboard.tooltip.greek": "Litreacha na Gréige",
                "keyboard.tooltip.command": "Mód Ordú LaTeX",
                "keyboard.tooltip.numeric": "Uimhriúil",
                "keyboard.tooltip.roman": "Litreacha Rómhánacha",
                "tooltip.copy to clipboard": "Cóipeáil chuig an Ghearrthaisce",
                "tooltip.redo": "Athdhéan",
                "tooltip.toggle virtual keyboard": "Méarchláir Fíorúil a Fháil",
                "tooltip.undo": "Cealaigh",
                "menu.insert matrix": "Cuir isteach Maitrís",
                "menu.insert vector": "Cuir isteach Veicteoir",
                "submenu.array.matrix delimiters": "Delimiters Maitrís",
                "menu.array.add row above": "Cuir Rae Tar éis",
                "menu.array.add row below": "Cuir Rae Roimh",
                "menu.array.add column after": "Cuir Colún Tar éis",
                "menu.array.add column before": "Cuir Colún Roimh",
                "menu.array.delete row": "Scrios Rae",
                "menu.array.delete rows": "Scrios Sraitheanna Roghnaithe",
                "menu.array.delete column": "Scrios Colún",
                "menu.array.delete columns": "Scrios Colúin Roghnaithe",
                "submenu.array.insert separator": "Cuir Deighilteoir isteach",
                "menu.insert table": "Ionsáigh Tábla",
                "submenu.table style": "Stíl Tábla"
            },
            he: {
                "keyboard.tooltip.functions": "פונקציות",
                "keyboard.tooltip.symbols": "סמלים",
                "keyboard.tooltip.greek": "אותיות יווניות",
                "keyboard.tooltip.command": "מצב פקודה לטקס",
                "keyboard.tooltip.numeric": "מספרי",
                "keyboard.tooltip.roman": "מכתבים רומיים",
                "tooltip.copy to clipboard": "העתק ללוח",
                "tooltip.redo": "לַעֲשׂוֹת שׁוּב",
                "tooltip.toggle virtual keyboard": "החלף את המקלדת הווירטואלית",
                "tooltip.undo": "לבטל",
                "menu.insert matrix": "הכנס מטריקס",
                "menu.insert vector": "הכנס וקטור",
                "submenu.array.matrix delimiters": "מפרידי מטריקס",
                "menu.array.add row above": "הוסף שורה אחרי",
                "menu.array.add row below": "הוסף שורה לפני",
                "menu.array.add column after": "הוסף עמודה אחרי",
                "menu.array.add column before": "הוסף עמודה לפני",
                "menu.array.delete row": "מחק שורה",
                "menu.array.delete rows": "מחק שורות שנבחרו",
                "menu.array.delete column": "מחק עמודה",
                "menu.array.delete columns": "מחק עמודות שנבחרו",
                "submenu.array.insert separator": "הכנס מפריד",
                "menu.insert table": "הכנס טבלה",
                "submenu.table style": "טבלה סִגְנוֹן"
            },
            hr: {
                "keyboard.tooltip.functions": "Funkcije",
                "keyboard.tooltip.symbols": "Simboli",
                "keyboard.tooltip.greek": "Grčka slova",
                "keyboard.tooltip.command": "LaTeX naredbeni način",
                "keyboard.tooltip.numeric": "Numerički",
                "keyboard.tooltip.roman": "Rimska slova",
                "tooltip.copy to clipboard": "Kopirati u međuspremnik",
                "tooltip.redo": "Ponovi",
                "tooltip.toggle virtual keyboard": "Uključi / isključi virtualnu tipkovnicu",
                "tooltip.undo": "Poništi",
                "menu.insert matrix": "Umetni matricu",
                "menu.insert vector": "Umetni vektor",
                "submenu.array.matrix delimiters": "Matrični razdjelnici",
                "menu.array.add row above": "Dodaj redak nakon",
                "menu.array.add row below": "Dodaj redak prije",
                "menu.array.add column after": "Dodaj stupac nakon",
                "menu.array.add column before": "Dodaj stupac prije",
                "menu.array.delete row": "Izbriši redak",
                "menu.array.delete rows": "Izbriši odabrane retke",
                "menu.array.delete column": "Izbriši stupac",
                "menu.array.delete columns": "Izbriši odabrane stupce",
                "submenu.array.insert separator": "Umetni separator",
                "menu.insert table": "Umetni tablicu",
                "submenu.table style": "Stil tabele"
            },
            id: {
                "keyboard.tooltip.functions": "Fungsi",
                "keyboard.tooltip.symbols": "Simbol",
                "keyboard.tooltip.greek": "Huruf Yunani",
                "keyboard.tooltip.command": "Mode Perintah LaTeX",
                "keyboard.tooltip.numeric": "Numerik",
                "keyboard.tooltip.roman": "Surat Romawi",
                "tooltip.copy to clipboard": "Menyalin ke clipboard",
                "tooltip.redo": "Mengulangi",
                "tooltip.toggle virtual keyboard": "Alihkan Keyboard Virtual",
                "tooltip.undo": "Membuka",
                "menu.insert matrix": "Sisipkan Matriks",
                "menu.insert vector": "Sisipkan Vektor",
                "submenu.array.matrix delimiters": "Pembatas Matriks",
                "menu.array.add row above": "Tambahkan Baris Setelah",
                "menu.array.add row below": "Tambahkan Baris Sebelumnya",
                "menu.array.add column after": "Tambahkan Kolom Setelah",
                "menu.array.add column before": "Tambahkan Kolom Sebelumnya",
                "menu.array.delete row": "Hapus Baris",
                "menu.array.delete rows": "Hapus Baris yang Dipilih",
                "menu.array.delete column": "Hapus Kolom",
                "menu.array.delete columns": "Hapus Kolom yang Dipilih",
                "submenu.array.insert separator": "Sisipkan Pemisah",
                "menu.insert table": "Sisipkan Tabel",
                "submenu.table style": "Gaya Tabel"
            },
            hi: {
                "keyboard.tooltip.functions": "कार्यों",
                "keyboard.tooltip.symbols": "प्रतीक",
                "keyboard.tooltip.greek": "ग्रीक अक्षर",
                "keyboard.tooltip.command": "लाटेक्स कमांड मोड",
                "keyboard.tooltip.numeric": "संख्यात्मक",
                "keyboard.tooltip.roman": "रोमन पत्र",
                "tooltip.copy to clipboard": "क्लिपबोर्ड पर कॉपी करें",
                "tooltip.redo": "फिर से करें",
                "tooltip.toggle virtual keyboard": "वर्चुअल कीबोर्ड टॉगल करें",
                "tooltip.undo": "पूर्ववत",
                "menu.insert matrix": "मैट्रिक्स डालें",
                "menu.insert vector": "वेक्टर डालें",
                "submenu.array.matrix delimiters": "मैट्रिक्स सीमांकक",
                "menu.array.add row above": "बाद में पंक्ति जोड़ें",
                "menu.array.add row below": "पहले पंक्ति जोड़ें",
                "menu.array.add column after": "बाद में कॉलम जोड़ें",
                "menu.array.add column before": "पहले कॉलम जोड़ें",
                "menu.array.delete row": "पंक्ति को हटाएं",
                "menu.array.delete rows": "चयनित पंक्तियों को हटाएं",
                "menu.array.delete column": "कॉलम हटाएं",
                "menu.array.delete columns": "चयनित कॉलम हटाएं",
                "submenu.array.insert separator": "विभाजक डालें",
                "menu.insert table": "टेबल इंसर्ट करें",
                "submenu.table style": "टेबल स्टाइल"
            },
            hu: {
                "keyboard.tooltip.functions": "Funkciók",
                "keyboard.tooltip.symbols": "Szimbólumok",
                "keyboard.tooltip.greek": "Görög levelek",
                "keyboard.tooltip.command": "LaTeX Parancs mód",
                "keyboard.tooltip.numeric": "Numerikus",
                "keyboard.tooltip.roman": "Római levelek",
                "tooltip.copy to clipboard": "Másolja a vágólapra",
                "tooltip.redo": "Újra",
                "tooltip.toggle virtual keyboard": "Váltás a virtuális billentyűzetre",
                "tooltip.undo": "Visszavonás",
                "menu.insert matrix": "Helyezze be a Mátrixot",
                "menu.insert vector": "Vektor beszúrása",
                "submenu.array.matrix delimiters": "Mátrixhatárolók",
                "menu.array.add row above": "Sor hozzáadása után",
                "menu.array.add row below": "Add Add Sor előtt",
                "menu.array.add column after": "Oszlop hozzáadása után",
                "menu.array.add column before": "Add oszlop előtt",
                "menu.array.delete row": "Sor törlése",
                "menu.array.delete rows": "Kijelölt sorok törlése",
                "menu.array.delete column": "Oszlop törlése",
                "menu.array.delete columns": "A kijelölt oszlopok törlése",
                "submenu.array.insert separator": "Helyezze be az elválasztót",
                "menu.insert table": "Helyezze be a táblázatot",
                "submenu.table style": "Táblázatos stílus"
            },
            it: {
                "keyboard.tooltip.functions": "Funzioni",
                "keyboard.tooltip.symbols": "Simboli",
                "keyboard.tooltip.greek": "Lettere greche",
                "keyboard.tooltip.command": "Modalità di comando LaTeX",
                "keyboard.tooltip.numeric": "Numerico",
                "keyboard.tooltip.roman": "Lettere romane",
                "tooltip.copy to clipboard": "Copia negli appunti",
                "tooltip.redo": "Rifare",
                "tooltip.toggle virtual keyboard": "Attiva / disattiva la tastiera virtuale",
                "tooltip.undo": "Disfare",
                "menu.insert matrix": "Inserisci una Matrice",
                "menu.insert vector": "Inserisci Vettore",
                "submenu.array.matrix delimiters": "Delimitatori di Matrice",
                "menu.array.add row above": "Aggiungi una Riga Prima",
                "menu.array.add row below": "Aggiungi una Riga Dopo",
                "menu.array.add column before": "Aggiungi una Colonna Prima",
                "menu.array.add column after": "Aggiungi una Colonna Dopo",
                "menu.array.delete row": "Rimuovi una Riga",
                "menu.array.delete rows": "Rimuovi le Righe Selezionate",
                "menu.array.delete column": "Rimuovi una Colonna",
                "menu.array.delete columns": "Rimuovi le Colonne Selezionate",
                "submenu.array.insert separator": "Inserisci un Separatore",
                "menu.insert table": "Inserisci Tabella",
                "submenu.table style": "Stile tabella"
            },
            is: {
                "keyboard.tooltip.functions": "Aðgerðir",
                "keyboard.tooltip.symbols": "Tákn",
                "keyboard.tooltip.greek": "Grísk bréf",
                "keyboard.tooltip.command": "LaTeX stjórnunarstilling",
                "keyboard.tooltip.numeric": "Tölulegt",
                "keyboard.tooltip.roman": "Rómversk bréf",
                "tooltip.copy to clipboard": "Afritaðu á klemmuspjald",
                "tooltip.redo": "Endurtaka",
                "tooltip.toggle virtual keyboard": "Skiptu um sýndarlyklaborð",
                "tooltip.undo": "Afturkalla",
                "menu.insert matrix": "Settu fylki inn",
                "menu.insert vector": "Settu inn Vector",
                "submenu.array.matrix delimiters": "Matrix afmörkun",
                "menu.array.add row above": "Bæta við röð á eftir",
                "menu.array.add row below": "Bæta við röð áður",
                "menu.array.add column after": "Bæta við dálki á eftir",
                "menu.array.add column before": "Bæta við dálki áður",
                "menu.array.delete row": "Eyða röð",
                "menu.array.delete rows": "Eyða völdum línum",
                "menu.array.delete column": "Eyða dálki",
                "menu.array.delete columns": "Eyða völdum dálkum",
                "submenu.array.insert separator": "Settu skiljuna í",
                "menu.insert table": "Settu inn töflu",
                "submenu.table style": "Töflu stíl"
            },
            ja: {
                "keyboard.tooltip.functions": "関数",
                "keyboard.tooltip.symbols": "シンボル",
                "keyboard.tooltip.greek": "ギリシャ文字",
                "keyboard.tooltip.command": "ラテックスコマンドモード",
                "keyboard.tooltip.numeric": "数値",
                "keyboard.tooltip.roman": "ローマ字",
                "tooltip.copy to clipboard": "クリップボードにコピー",
                "tooltip.redo": "やり直し",
                "tooltip.toggle virtual keyboard": "仮想キーボードの切り替え",
                "tooltip.undo": "元に戻す",
                "menu.insert matrix": "マトリックスを挿入",
                "menu.insert vector": "ベクトルを挿入",
                "submenu.array.matrix delimiters": "行列区切り文字",
                "menu.array.add row above": "後に行を追加",
                "menu.array.add row below": "前に行を追加",
                "menu.array.add column after": "後に列を追加",
                "menu.array.add column before": "前に列を追加",
                "menu.array.delete row": "行を削除",
                "menu.array.delete rows": "選択した行を削除する",
                "menu.array.delete column": "列を削除",
                "menu.array.delete columns": "選択した列を削除する",
                "submenu.array.insert separator": "セパレーターを挿入",
                "menu.insert table": "テーブルを挿入",
                "submenu.table style": "テーブルスタイル"
            },
            ko: {
                "keyboard.tooltip.functions": "기능",
                "keyboard.tooltip.symbols": "기호",
                "keyboard.tooltip.greek": "그리스 문자",
                "keyboard.tooltip.command": "유액 명령 모드",
                "keyboard.tooltip.numeric": "숫자",
                "keyboard.tooltip.roman": "로마 문자",
                "tooltip.copy to clipboard": "클립 보드에 복사",
                "tooltip.redo": "다시 하다",
                "tooltip.toggle virtual keyboard": "가상 키보드 전환",
                "tooltip.undo": "실행 취소",
                "menu.insert matrix": "매트릭스 삽입",
                "menu.insert vector": "벡터 삽입",
                "submenu.array.matrix delimiters": "행렬 구분 기호",
                "menu.array.add row above": "뒤에 행 추가",
                "menu.array.add row below": "앞에 행 추가",
                "menu.array.add column after": "뒤에 열 추가",
                "menu.array.add column before": "앞에 열 추가",
                "menu.array.delete row": "행 삭제",
                "menu.array.delete rows": "선택한 행 삭제",
                "menu.array.delete column": "열 삭제",
                "menu.array.delete columns": "선택한 열 삭제",
                "submenu.array.insert separator": "구분자 삽입",
                "menu.insert table": "표 삽입",
                "submenu.table style": "테이블 스타일"
            },
            lv: {
                "keyboard.tooltip.functions": "Funkcijas",
                "keyboard.tooltip.symbols": "Simboli",
                "keyboard.tooltip.greek": "Grieķu burti",
                "keyboard.tooltip.command": "LaTeX komandu režīms",
                "keyboard.tooltip.numeric": "Ciparu skaitlis",
                "keyboard.tooltip.roman": "Romiešu vēstules",
                "tooltip.copy to clipboard": "Kopēt starpliktuvē",
                "tooltip.redo": "Pārtaisīt",
                "tooltip.toggle virtual keyboard": "Pārslēgt virtuālo tastatūru",
                "tooltip.undo": "Atsaukt",
                "menu.insert matrix": "Ievietojiet matricu",
                "menu.insert vector": "Ievietot vektoru",
                "submenu.array.matrix delimiters": "Matricas norobežotāji",
                "menu.array.add row above": "Pievienot rindu pēc",
                "menu.array.add row below": "Pievienot rindu pirms",
                "menu.array.add column after": "Pievienot kolonnu pēc",
                "menu.array.add column before": "Pievienot kolonnu pirms",
                "menu.array.delete row": "Dzēst rindu",
                "menu.array.delete rows": "Dzēst atlasītās rindas",
                "menu.array.delete column": "Dzēst kolonnu",
                "menu.array.delete columns": "Dzēst atlasītās kolonnas",
                "submenu.array.insert separator": "Ievietojiet atdalītāju",
                "menu.insert table": "Ievietojiet tabulu",
                "submenu.table style": "Galda stils"
            },
            lt: {
                "keyboard.tooltip.functions": "Funkcijos",
                "keyboard.tooltip.symbols": "Simboliai",
                "keyboard.tooltip.greek": "Graikiškos raidės",
                "keyboard.tooltip.command": "LaTeX komandų režimas",
                "keyboard.tooltip.numeric": "Skaitmeninis",
                "keyboard.tooltip.roman": "Romos laiškai",
                "tooltip.copy to clipboard": "Nukopijuoti į iškarpinę",
                "tooltip.redo": "Perdaryti",
                "tooltip.toggle virtual keyboard": "Perjungti virtualiąją klaviatūrą",
                "tooltip.undo": "Atšaukti",
                "menu.insert matrix": "Ievietojiet matricu",
                "menu.insert vector": "Ievietot vektoru",
                "submenu.array.matrix delimiters": "Matricas norobežotāji",
                "menu.array.add row above": "Pievienot rindu pēc",
                "menu.array.add row below": "Pievienot rindu pirms",
                "menu.array.add column after": "Pievienot kolonnu pēc",
                "menu.array.add column before": "Pievienot kolonnu pirms",
                "menu.array.delete row": "Dzēst rindu",
                "menu.array.delete rows": "Dzēst atlasītās rindas",
                "menu.array.delete column": "Dzēst kolonnu",
                "menu.array.delete columns": "Dzēst atlasītās kolonnas",
                "submenu.array.insert separator": "Ievietojiet atdalītāju",
                "menu.insert table": "Ievietojiet tabulu",
                "submenu.table style": "Tabulas stili"
            },
            lu: {
                "keyboard.tooltip.functions": "Funktiounen",
                "keyboard.tooltip.symbols": "Symboler",
                "keyboard.tooltip.greek": "Griichesch Bréiwer",
                "keyboard.tooltip.command": "LaTeX Kommando Modus",
                "keyboard.tooltip.numeric": "Numeresch",
                "keyboard.tooltip.roman": "Réimesch Bréiwer",
                "tooltip.copy to clipboard": "Kopéiert op Clipboard",
                "tooltip.redo": "Nees nei maachen",
                "tooltip.toggle virtual keyboard": "Wiesselt Virtuell Tastatur",
                "tooltip.undo": "Undoen",
                "menu.insert matrix": "Matrix asetzen",
                "menu.insert vector": "Insert Vector",
                "submenu.array.matrix delimiters": "Matrix Ofgrenzer",
                "menu.array.add row above": "Dobäizemaachen Rei No",
                "menu.array.add row below": "Füügt Rei vir",
                "menu.array.add column after": "Dobäizemaachen Kolonn No",
                "menu.array.add column before": "Kolonn derbäi Virun",
                "menu.array.delete row": "Rad läschen",
                "menu.array.delete rows": "Läscht Ausgewielte Reien",
                "menu.array.delete column": "Läscht Kolonn",
                "menu.array.delete columns": "Läscht Ausgewielte Kolonnen",
                "submenu.array.insert separator": "Insert Separator",
                "menu.insert table": "Dësch anzeginn",
                "submenu.table style": "Dësch Style"
            },
            nl: {
                "keyboard.tooltip.functions": "Functies",
                "keyboard.tooltip.symbols": "Symbolen",
                "keyboard.tooltip.greek": "Griekse letters",
                "keyboard.tooltip.command": "LaTeX commando mode",
                "keyboard.tooltip.numeric": "Numeriek",
                "keyboard.tooltip.roman": "Romeinse letters",
                "tooltip.copy to clipboard": "Kopiëren naar klembord",
                "tooltip.redo": "Opnieuw",
                "tooltip.toggle virtual keyboard": "Schakel naar virtueel toetsenbord",
                "tooltip.undo": "Ongedaan maken",
                "menu.insert matrix": "Matrix invoegen",
                "menu.insert vector": "Vector invoegen",
                "submenu.array.matrix delimiters": "Matrixscheidingstekens",
                "menu.array.add row above": "Rij toevoegen na",
                "menu.array.add row below": "Rij toevoegen eerder",
                "menu.array.add column after": "Kolom toevoegen na",
                "menu.array.add column before": "Kolom toevoegen voor",
                "menu.array.delete row": "Verwijder rij",
                "menu.array.delete rows": "Geselecteerde rijen verwijderen",
                "menu.array.delete column": "Kolom verwijderen",
                "menu.array.delete columns": "Geselecteerde kolommen verwijderen",
                "submenu.array.insert separator": "Scheidingsteken invoegen",
                "menu.insert table": "Tabel invoegen",
                "submenu.table style": "Tabelstijl"
            },
            no: {
                "keyboard.tooltip.functions": "Funksjoner",
                "keyboard.tooltip.symbols": "Symboler",
                "keyboard.tooltip.greek": "Greske bokstaver",
                "keyboard.tooltip.command": "LaTeX kommandomodus",
                "keyboard.tooltip.numeric": "Numerisk",
                "keyboard.tooltip.roman": "Romerske bokstaver",
                "tooltip.copy to clipboard": "Kopiere til utklippstavle",
                "tooltip.redo": "Gjøre om",
                "tooltip.toggle virtual keyboard": "Bytt virtuelt tastatur",
                "tooltip.undo": "Angre",
                "menu.insert matrix": "Sett inn matrise",
                "menu.insert vector": "Sett inn vektor",
                "submenu.array.matrix delimiters": "Matrix avgrensere",
                "menu.array.add row above": "Legg til rad etter",
                "menu.array.add row below": "Legg til rad før",
                "menu.array.add column after": "Legg til kolonne etter",
                "menu.array.add column before": "Legg til kolonne før",
                "menu.array.delete row": "Slett rad",
                "menu.array.delete rows": "Slett valgte rader",
                "menu.array.delete column": "Slett kolonne",
                "menu.array.delete columns": "Slett valgte kolonner",
                "submenu.array.insert separator": "Sett inn skilletegn",
                "menu.insert table": "Sett inn tabell",
                "submenu.table style": "Tabellstil"
            },
            mk: {
                "keyboard.tooltip.functions": "Функции",
                "keyboard.tooltip.symbols": "Симболи",
                "keyboard.tooltip.greek": "Грчки букви",
                "keyboard.tooltip.command": "Режим на команда во латекс",
                "keyboard.tooltip.numeric": "Нумерички",
                "keyboard.tooltip.roman": "Римски писма",
                "tooltip.copy to clipboard": "Копирајте во клипборд",
                "tooltip.redo": "Повторно",
                "tooltip.toggle virtual keyboard": "Вклучете ја виртуелната тастатура",
                "tooltip.undo": "Врати",
                "menu.insert matrix": "Вметнете матрица",
                "menu.insert vector": "Вметни вектор",
                "submenu.array.matrix delimiters": "Разграничувачи на матрица",
                "menu.array.add row above": "Додадете ред после",
                "menu.array.add row below": "Додади ред пред тоа",
                "menu.array.add column after": "Додадете колона после",
                "menu.array.add column before": "Додадете колона пред тоа",
                "menu.array.delete row": "Избриши го редот",
                "menu.array.delete rows": "Избришете ги избраните редови",
                "menu.array.delete column": "Избриши ја колоната",
                "menu.array.delete columns": "Избриши ја колоната",
                "submenu.array.insert separator": "Вметнете сепаратор",
                "menu.insert table": "Вметни табела",
                "submenu.table style": "Табела стил"
            },
            pl: {
                "keyboard.tooltip.functions": "Funkcje",
                "keyboard.tooltip.symbols": "Symbolika",
                "keyboard.tooltip.greek": "Litery greckie",
                "keyboard.tooltip.command": "Tryb poleceń LaTeX",
                "keyboard.tooltip.numeric": "Numeryczne",
                "keyboard.tooltip.roman": "Litery rzymskie",
                "tooltip.copy to clipboard": "Kopiuj do Schowka",
                "tooltip.redo": "Przywróć",
                "tooltip.toggle virtual keyboard": "Przełącz wirtualną klawiaturę",
                "tooltip.undo": "Cofnij",
                "menu.insert matrix": "Wstaw macierz",
                "menu.insert vector": "Wstaw wektor",
                "submenu.array.matrix delimiters": "Ograniczniki macierzy",
                "menu.array.add row above": "Dodaj wiersz po",
                "menu.array.add row below": "Dodaj wiersz przed",
                "menu.array.add column after": "Dodaj kolumnę po",
                "menu.array.add column before": "Dodaj kolumnę przed",
                "menu.array.delete row": "Usuń wiersz",
                "menu.array.delete rows": "Usuń wybrane wiersze",
                "menu.array.delete column": "Usuń kolumnę",
                "menu.array.delete columns": "Usuń wybrane kolumny",
                "submenu.array.insert separator": "Wstaw separator",
                "menu.insert table": "Wypełnij tabelę",
                "submenu.table style": "Styl tabelę"
            },
            pt: {
                "keyboard.tooltip.functions": "Functions",
                "keyboard.tooltip.symbols": "Símbolos",
                "keyboard.tooltip.greek": "Letras gregas",
                "keyboard.tooltip.command": "Modo de Comando LaTeX",
                "keyboard.tooltip.numeric": "Numérico",
                "keyboard.tooltip.roman": "Letras romanas",
                "tooltip.copy to clipboard": "Copiar para área de transferência",
                "tooltip.redo": "Refazer",
                "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
                "tooltip.undo": "Desfazer",
                "menu.insert matrix": "Inserir Matriz",
                "menu.insert vector": "Inserir vetor",
                "submenu.array.matrix delimiters": "Delimitadores de matriz",
                "menu.array.add row above": "Adicionar linha depois",
                "menu.array.add row below": "Adicionar linha antes",
                "menu.array.add column after": "Adicionar coluna depois",
                "menu.array.add column before": "Adicionar coluna antes",
                "menu.array.delete row": "Excluir linha",
                "menu.array.delete rows": "Excluir linhas selecionadas",
                "menu.array.delete column": "Apagar Coluna",
                "menu.array.delete columns": "Excluir Colunas Selecionadas",
                "submenu.array.insert separator": "Inserir Separador",
                "menu.insert table": "Insira a tabela",
                "submenu.table style": "Estilo tabela"
            },
            ro: {
                "keyboard.tooltip.functions": "Funcții",
                "keyboard.tooltip.symbols": "Simboluri",
                "keyboard.tooltip.greek": "Scrisori grecești",
                "keyboard.tooltip.command": "Modul de comandă latex",
                "keyboard.tooltip.numeric": "Numeric",
                "keyboard.tooltip.roman": "Scrisori romane",
                "tooltip.copy to clipboard": "Copiați în clipboard",
                "tooltip.redo": "A reface",
                "tooltip.toggle virtual keyboard": "Comutați tastatura virtuală",
                "tooltip.undo": "Anula",
                "menu.insert matrix": "Introduceți Matrix",
                "menu.insert vector": "Inserați Vector",
                "submenu.array.matrix delimiters": "Delimitatori de matrice",
                "menu.array.add row above": "Adăugați rândul după",
                "menu.array.add row below": "Adăugați rândul înainte",
                "menu.array.add column after": "Adăugați o coloană după",
                "menu.array.add column before": "Adăugați o coloană înainte",
                "menu.array.delete row": "Ștergeți rândul",
                "menu.array.delete rows": "Ștergeți rândurile selectate",
                "menu.array.delete column": "Ștergeți coloana",
                "menu.array.delete columns": "Ștergeți coloanele selectate",
                "submenu.array.insert separator": "Introduceți separatorul",
                "menu.insert table": "Introduceți tabelul",
                "submenu.table style": "Table style"
            },
            ru: {
                "keyboard.tooltip.functions": "Функции",
                "keyboard.tooltip.symbols": "Символы",
                "keyboard.tooltip.greek": "Греческие буквы",
                "keyboard.tooltip.command": "Режим командной строки Латекс",
                "keyboard.tooltip.numeric": "числовой",
                "keyboard.tooltip.roman": "Латинские буквы",
                "tooltip.copy to clipboard": "Скопировать в буфер обмена",
                "tooltip.redo": "переделывать",
                "tooltip.toggle virtual keyboard": "Переключить виртуальную клавиатуру",
                "tooltip.undo": "расстегивать",
                "menu.insert matrix": "Вставить матрицу",
                "menu.insert vector": "Вставить вектор",
                "submenu.array.matrix delimiters": "Матричные разделители",
                "menu.array.add row above": "Добавить строку после",
                "menu.array.add row below": "Добавить строку перед",
                "menu.array.add column after": "Добавить столбец после",
                "menu.array.add column before": "Добавить столбец перед",
                "menu.array.delete row": "Удалить строку",
                "menu.array.delete rows": "Удалить выбранные строки",
                "menu.array.delete column": "Удалить столбец",
                "menu.array.delete columns": "Удалить выбранные столбцы",
                "submenu.array.insert separator": "Вставить разделитель",
                "menu.insert table": "Вставить таблицу",
                "submenu.table style": "Табличный стиль"
            },
            sk: {
                "keyboard.tooltip.functions": "Functions",
                "keyboard.tooltip.symbols": "Symboly",
                "keyboard.tooltip.greek": "Grécke listy",
                "keyboard.tooltip.command": "Príkazový režim LaTeX",
                "keyboard.tooltip.numeric": "Numerické",
                "keyboard.tooltip.roman": "Rímske listy",
                "tooltip.copy to clipboard": "Skopírovať do schránky",
                "tooltip.redo": "Znova",
                "tooltip.toggle virtual keyboard": "Prepnúť virtuálnu klávesnicu",
                "tooltip.undo": "Vrátenie späť",
                "menu.insert matrix": "Vložte maticu",
                "menu.insert vector": "Vložte vektor",
                "submenu.array.matrix delimiters": "Oddeľovače matíc",
                "menu.array.add row above": "Pridajte riadok za",
                "menu.array.add row below": "Pridajte riadok pred",
                "menu.array.add column after": "Pridať stĺpec za",
                "menu.array.add column before": "Pridajte stĺpec predtým",
                "menu.array.delete row": "Odstrániť riadok",
                "menu.array.delete rows": "Odstrániť vybraté riadky",
                "menu.array.delete column": "Odstrániť stĺpec",
                "menu.array.delete columns": "Odstrániť vybraté stĺpce",
                "submenu.array.insert separator": "Vložte oddeľovač",
                "menu.insert table": "Vložte tabuľku",
                "submenu.table style": "Štýl tabuľky"
            },
            sl: {
                "keyboard.tooltip.functions": "Funkcije",
                "keyboard.tooltip.symbols": "Simboli",
                "keyboard.tooltip.greek": "Grška pisma",
                "keyboard.tooltip.command": "Ukazni način LaTeX",
                "keyboard.tooltip.numeric": "Številsko",
                "keyboard.tooltip.roman": "Rimska pisma",
                "tooltip.copy to clipboard": "Kopirati v odložišče",
                "tooltip.redo": "Ponovi",
                "tooltip.toggle virtual keyboard": "Preklop navidezne tipkovnice",
                "tooltip.undo": "Razveljavi",
                "menu.insert matrix": "Vstavi matrico",
                "menu.insert vector": "Vstavi vektor",
                "submenu.array.matrix delimiters": "Matrični ločevalniki",
                "menu.array.add row above": "Dodaj vrstico po",
                "menu.array.add row below": "Dodaj vrstico prej",
                "menu.array.add column after": "Dodaj stolpec po",
                "menu.array.add column before": "Dodaj stolpec prej",
                "menu.array.delete row": "Izbriši vrstico",
                "menu.array.delete rows": "Izbriši izbrane vrstice",
                "menu.array.delete column": "Izbriši stolpec",
                "menu.array.delete columns": "Izbriši izbrane stolpce",
                "submenu.array.insert separator": "Vstavi ločilo",
                "menu.insert table": "Vstavi tabelo",
                "submenu.table style": "Tabela slog"
            },
            sq: {
                "keyboard.tooltip.functions": "Funksione",
                "keyboard.tooltip.symbols": "Simbolet",
                "keyboard.tooltip.greek": "Letrat Greke",
                "keyboard.tooltip.command": "Modaliteti i komandës latex",
                "keyboard.tooltip.numeric": "Numerike",
                "keyboard.tooltip.roman": "Letrat romake",
                "tooltip.copy to clipboard": "Kopjoni në Clipboard",
                "tooltip.redo": "Riparo",
                "tooltip.toggle virtual keyboard": "Aktivizo tastierën virtuale",
                "tooltip.undo": "Zhbëj",
                "menu.insert matrix": "Vendosni Matricën",
                "menu.insert vector": "Vendos vektorin",
                "submenu.array.matrix delimiters": "Përcaktuesit e matricës",
                "menu.array.add row above": "Shto Rreshtin Pas",
                "menu.array.add row below": "Shto Rreshtin Para",
                "menu.array.add column after": "Shto kolonën pas",
                "menu.array.add column before": "Shto kolonën para",
                "menu.array.delete row": "Fshi Rreshtin",
                "menu.array.delete rows": "Fshi rreshtat e zgjedhur",
                "menu.array.delete column": "Fshi kolonën",
                "menu.array.delete columns": "Fshi kolonat e zgjedhura",
                "submenu.array.insert separator": "Vendos Ndarësin",
                "menu.insert table": "Vendos tabelën",
                "submenu.table style": "Stili tabelën"
            },
            sr: {
                "keyboard.tooltip.functions": "Функције",
                "keyboard.tooltip.symbols": "Симболи",
                "keyboard.tooltip.greek": "Греек Леттерс",
                "keyboard.tooltip.command": "ЛаТеКс командни режим",
                "keyboard.tooltip.numeric": "Нумерички",
                "keyboard.tooltip.roman": "Римска писма",
                "tooltip.copy to clipboard": "Копирајте у међуспремник",
                "tooltip.redo": "Понови",
                "tooltip.toggle virtual keyboard": "Укључи / искључи виртуелну тастатуру",
                "tooltip.undo": "Опозови",
                "menu.insert matrix": "Уметни матрицу",
                "menu.insert vector": "Уметни вектор",
                "submenu.array.matrix delimiters": "Матрик Делимитерс",
                "menu.array.add row above": "Додај ред после",
                "menu.array.add row below": "Додај ред пре",
                "menu.array.add column after": "Додај колону после",
                "menu.array.add column before": "Додај колону пре",
                "menu.array.delete row": "Избриши ред",
                "menu.array.delete rows": "Избриши изабране редове",
                "menu.array.delete column": "Избриши колону",
                "menu.array.delete columns": "Избриши изабране колоне",
                "submenu.array.insert separator": "Уметни сепаратор",
                "menu.insert table": "Убаци табелу",
                "submenu.table style": "Табеларни стил"
            },
            sv: {
                "keyboard.tooltip.functions": "Funktioner",
                "keyboard.tooltip.symbols": "Symboler",
                "keyboard.tooltip.greek": "Grekiska bokstäver",
                "keyboard.tooltip.command": "LaTeX kommandoläge",
                "keyboard.tooltip.numeric": "Numerisk",
                "keyboard.tooltip.roman": "Romerska bokstäver",
                "tooltip.copy to clipboard": "Kopiera till Urklipp",
                "tooltip.redo": "Göra om",
                "tooltip.toggle virtual keyboard": "Växla virtuellt tangentbord",
                "tooltip.undo": "Ångra",
                "menu.insert matrix": "Sätt in matris",
                "menu.insert vector": "Infoga vektor",
                "submenu.array.matrix delimiters": "Matrisavgränsare",
                "menu.array.add row above": "Lägg till rad efter",
                "menu.array.add row below": "Lägg till rad före",
                "menu.array.add column after": "Lägg till kolumn efter",
                "menu.array.add column before": "Lägg till kolumn före",
                "menu.array.delete row": "Radera rad",
                "menu.array.delete rows": "Ta bort valda rader",
                "menu.array.delete column": "Ta bort kolumn",
                "menu.array.delete columns": "Ta bort valda kolumner",
                "submenu.array.insert separator": "Sätt i separator",
                "menu.insert table": "Infoga tabell",
                "submenu.table style": "Tabellstil"
            },
            th: {
                "keyboard.tooltip.functions": "ฟังก์ชั่น",
                "keyboard.tooltip.symbols": "สัญลักษณ์",
                "keyboard.tooltip.greek": "อักษรกรีก",
                "keyboard.tooltip.command": "โหมดคำสั่ง น้ำยาง",
                "keyboard.tooltip.numeric": "ตัวเลข",
                "keyboard.tooltip.roman": "อักษรโรมัน",
                "tooltip.copy to clipboard": "คัดลอกไปที่คลิปบอร์ด",
                "tooltip.redo": "ทำซ้ำ",
                "tooltip.toggle virtual keyboard": "สลับแป้นพิมพ์เสมือน",
                "tooltip.undo": "เลิกทำ",
                "menu.insert matrix": "แทรกเมทริกซ์",
                "menu.insert vector": "แทรกเวกเตอร์",
                "submenu.array.matrix delimiters": "ตัวคั่นเมทริกซ์",
                "menu.array.add row above": "เพิ่มแถวหลัง",
                "menu.array.add row below": "เพิ่มแถวก่อน",
                "menu.array.add column after": "เพิ่มคอลัมน์หลัง",
                "menu.array.add column before": "เพิ่มคอลัมน์ก่อน",
                "menu.array.delete row": "ลบแถว",
                "menu.array.delete rows": "ลบแถวที่เลือก",
                "menu.array.delete column": "ลบคอลัมน์",
                "menu.array.delete columns": "ลบคอลัมน์ที่เลือก",
                "submenu.array.insert separator": "ตัวคั่นแทรก",
                "menu.insert table": "แทรกตาราง",
                "submenu.table style": "สไตล์ตาราง"
            },
            tr: {
                "keyboard.tooltip.functions": "Fonksiyonlar",
                "keyboard.tooltip.symbols": "Semboller",
                "keyboard.tooltip.greek": "Yunan harfleri",
                "keyboard.tooltip.command": "LaTeX Komut Modu",
                "keyboard.tooltip.numeric": "Sayısal",
                "keyboard.tooltip.roman": "Roma Harfleri",
                "tooltip.copy to clipboard": "Panoya kopyala",
                "tooltip.redo": "Yeniden yap",
                "tooltip.toggle virtual keyboard": "Sanal Klavyeyi Aç/Kapat",
                "tooltip.undo": "Geri alma",
                "menu.insert matrix": "Matris Ekle",
                "menu.insert vector": "Vektör Ekle",
                "submenu.array.matrix delimiters": "Matris Sınırlayıcılar",
                "menu.array.add row above": "Satırdan Sonra Ekle",
                "menu.array.add row below": "Önce Satır Ekle",
                "menu.array.add column after": "Sonra Sütun Ekle",
                "menu.array.add column before": "Önce Sütun Ekle",
                "menu.array.delete row": "Sırayı sil",
                "menu.array.delete rows": "Seçili Satırları Sil",
                "menu.array.delete column": "Sütunu Sil",
                "menu.array.delete columns": "Seçili Sütunları Sil",
                "submenu.array.insert separator": "Ayırıcı Ekle",
                "menu.insert table": "Tablo Ekle",
                "submenu.table style": "Tablo Stili"
            },
            uk: {
                "keyboard.tooltip.functions": "Функції",
                "keyboard.tooltip.symbols": "Символи",
                "keyboard.tooltip.greek": "Грецькі літери",
                "keyboard.tooltip.command": "Командний режим латексу",
                "keyboard.tooltip.numeric": "Числовий",
                "keyboard.tooltip.roman": "Римські літери",
                "tooltip.copy to clipboard": "Копіювати в буфер обміну",
                "tooltip.redo": "Повторити",
                "tooltip.toggle virtual keyboard": "Переключити віртуальну клавіатуру",
                "tooltip.undo": "Скасувати",
                "menu.insert matrix": "Вставити матрицю",
                "menu.insert vector": "Вставити вектор",
                "submenu.array.matrix delimiters": "Матричні роздільники",
                "menu.array.add row above": "Додати рядок після",
                "menu.array.add row below": "Додати рядок до",
                "menu.array.add column after": "Додати стовпець після",
                "menu.array.add column before": "Додати стовпець перед",
                "menu.array.delete row": "Видалити рядок",
                "menu.array.delete rows": "Видалити вибрані рядки",
                "menu.array.delete column": "Видалити стовпець",
                "menu.array.delete columns": "Видалити вибрані стовпці",
                "submenu.array.insert separator": "Вставте роздільник",
                "menu.insert table": "Вставити таблицю",
                "submenu.table style": "Стиль таблиці"
            },
            vi: {
                "keyboard.tooltip.functions": "Chức năng",
                "keyboard.tooltip.symbols": "Ký hiệu",
                "keyboard.tooltip.greek": "Chữ Hy Lạp",
                "keyboard.tooltip.command": "Chế độ lệnh LaTeX",
                "keyboard.tooltip.numeric": "Số",
                "keyboard.tooltip.roman": "Chữ cái La mã",
                "tooltip.copy to clipboard": "Sao chép vào clipboard",
                "tooltip.redo": "Làm lại",
                "tooltip.toggle virtual keyboard": "Chuyển đổi bàn phím ảo",
                "tooltip.undo": "Hoàn tác",
                "menu.insert matrix": "Chèn ma trận",
                "menu.insert vector": "Insert Vector",
                "submenu.array.matrix delimiters": "Dấu phân cách ma trận",
                "menu.array.add row above": "Thêm hàng sau",
                "menu.array.add row below": "Thêm hàng trước",
                "menu.array.add column after": "Thêm cột sau",
                "menu.array.add column before": "Thêm cột trước",
                "menu.array.delete row": "Xóa hàng",
                "menu.array.delete rows": "Xóa hàng đã chọn",
                "menu.array.delete column": "Xóa cột",
                "menu.array.delete columns": "Xóa các cột đã chọn",
                "submenu.array.insert separator": "Chèn dấu phân cách",
                "menu.insert table": "Chèn bảng",
                "submenu.table style": "Kiểu bảng"
            },
            zh_cn: {
                "keyboard.tooltip.functions": "职能",
                "keyboard.tooltip.symbols": "符号",
                "keyboard.tooltip.greek": "希腊字母",
                "keyboard.tooltip.command": "乳胶 命令模式",
                "keyboard.tooltip.numeric": "数字",
                "keyboard.tooltip.roman": "罗马字母",
                "tooltip.copy to clipboard": "复制到剪贴板",
                "tooltip.redo": "重做",
                "tooltip.toggle virtual keyboard": "切换虚拟键盘",
                "tooltip.undo": "撤消",
                "menu.insert matrix": "插入矩阵",
                "menu.insert vector": "插入向量",
                "submenu.array.matrix delimiters": "矩阵分隔符",
                "menu.array.add row above": "在后面添加行",
                "menu.array.add row below": "在前面添加行",
                "menu.array.add column after": "在后面添加列r",
                "menu.array.add column before": "在前面添加列",
                "menu.array.delete row": "删除行",
                "menu.array.delete rows": "删除选定行",
                "menu.array.delete column": "删除列",
                "menu.array.delete columns": "删除选定的列",
                "submenu.array.insert separator": "插入分隔符",
                "menu.insert table": "插入表格",
                "submenu.table style": "表格样式"
            },
            zh_tw: {
                "keyboard.tooltip.functions": "職能",
                "keyboard.tooltip.symbols": "符號",
                "keyboard.tooltip.greek": "希臘字母",
                "keyboard.tooltip.command": "乳膠命令模式",
                "keyboard.tooltip.numeric": "數字",
                "keyboard.tooltip.roman": "羅馬字母",
                "tooltip.copy to clipboard": "複製到剪貼板",
                "tooltip.redo": "重做",
                "tooltip.toggle virtual keyboard": "切換虛擬鍵盤",
                "tooltip.undo": "撤消",
                "menu.insert matrix": "插入矩陣",
                "menu.insert vector": "插入向量",
                "submenu.array.matrix delimiters": "矩陣分隔符",
                "menu.array.add row above": "在後面添加行",
                "menu.array.add row below": "在前面添加行",
                "menu.array.add column after": "在後面添加列",
                "menu.array.add column before": "在前面添加列",
                "menu.array.delete row": "刪除行",
                "menu.array.delete rows": "刪除選定行",
                "menu.array.delete column": "刪除列",
                "menu.array.delete columns": "刪除選定的列",
                "submenu.array.insert separator": "插入分隔符",
                "menu.insert table": "插入表格",
                "submenu.table style": "表格樣式"
            }
        },
        _locale: "",
        get locale() {
            return c._locale || (c._locale = o() ? navigator.language.slice(0, 5) : "en"), c._locale
        },
        set locale(e) {
            c._locale = e
        },
        merge(e, t) {
            if (e && t) {
                const a = c._locale;
                c.locale = e, c.strings[e] = {
                    ...c.strings[e],
                    ...t
                }, c.locale = a
            } else if (e && !t)
                for (const t of Object.keys(e)) c.merge(t, e[t])
        }
    };

    function u(e) {
        if (void 0 === e) return;
        const t = c.locale.slice(0, 2);
        let a = "";
        return c.strings[c.locale] && (a = c.strings[c.locale][e]), !a && c.strings[t] && (a = c.strings[t][e]), a || (a = c.strings.en[e]), a || void 0
    }
    const p = {
            m0: "#3F3D99",
            m1: "#993D71",
            m2: "#998B3D",
            m3: "#3D9956",
            m4: "#3D5A99",
            m5: "#993D90",
            m6: "#996D3D",
            m7: "#43993D",
            m8: "#3D7999",
            m9: "#843D99"
        },
        h = {
            blue: "#0072BD",
            orange: "#D95319",
            yellow: "#EDB120",
            purple: "#7E2F8E",
            green: "#77AC30",
            cyan: "#4DBEEE",
            red: "#A2142F"
        },
        m = {
            red: "#fbbbb6",
            orange: "#ffe0c2",
            yellow: "#fff1c2",
            lime: "#d0e8b9",
            green: "#bceac4",
            teal: "#b9f1f1",
            blue: "#b6d9fb",
            indigo: "#d1c2f0",
            purple: "#e3baf8",
            magenta: "#f9c8e0",
            black: "#353535",
            "dark-grey": "#8C8C8C",
            grey: "#D0D0D0",
            "light-grey": "#F0F0F0",
            white: "#ffffff"
        },
        f = {
            red: "#d7170b",
            orange: "#fe8a2b",
            yellow: "#ffc02b",
            lime: "#63b215",
            green: "#21ba3a",
            teal: "#17cfcf",
            blue: "#0d80f2",
            indigo: "#63c",
            purple: "#a219e6",
            magenta: "#eb4799",
            black: "#000",
            "dark-grey": "#666",
            grey: "#A6A6A6",
            "light-grey": "#d4d5d2",
            white: "#ffffff"
        },
        y = {
            Red: "red",
            Orange: "orange",
            Yellow: "yellow",
            LimeGreen: "lime",
            Green: "green",
            TealBlue: "teal",
            Blue: "blue",
            Violet: "indigo",
            Purple: "purple",
            Magenta: "magenta",
            Black: "black",
            Gray: "grey",
            White: "white"
        },
        b = {
            Apricot: "#FBB982",
            Aquamarine: "#00B5BE",
            Bittersweet: "#C04F17",
            Black: "#221E1F",
            Blue: "#2D2F92",
            BlueGreen: "#00B3B8",
            BlueViolet: "#473992",
            BrickRed: "#B6321C",
            Brown: "#792500",
            BurntOrange: "#F7921D",
            CadetBlue: "#74729A",
            CarnationPink: "#F282B4",
            Cerulean: "#00A2E3",
            CornflowerBlue: "#41B0E4",
            Cyan: "#00AEEF",
            Dandelion: "#FDBC42",
            DarkOrchid: "#A4538A",
            Emerald: "#00A99D",
            ForestGreen: "#009B55",
            Fuchsia: "#8C368C",
            Goldenrod: "#FFDF42",
            Gray: "#949698",
            Green: "#00A64F",
            GreenYellow: "#DFE674",
            JungleGreen: "#00A99A",
            Lavender: "#F49EC4",
            Limegreen: "#8DC73E",
            Magenta: "#EC008C",
            Mahogany: "#A9341F",
            Maroon: "#AF3235",
            Melon: "#F89E7B",
            MidnightBlue: "#006795",
            Mulberry: "#A93C93",
            NavyBlue: "#006EB8",
            OliveGreen: "#3C8031",
            Orange: "#F58137",
            OrangeRed: "#ED135A",
            Orchid: "#AF72B0",
            Peach: "#F7965A",
            Periwinkle: "#7977B8",
            PineGreen: "#008B72",
            Plum: "#92268F",
            ProcessBlue: "#00B0F0",
            Purple: "#99479B",
            RawSienna: "#974006",
            Red: "#ED1B23",
            RedOrange: "#F26035",
            RedViolet: "#A1246B",
            Rhodamine: "#EF559F",
            RoyalBlue: "#0071BC",
            RoyalPurple: "#613F99",
            RubineRed: "#ED017D",
            Salmon: "#F69289",
            SeaGreen: "#3FBC9D",
            Sepia: "#671800",
            SkyBlue: "#46C5DD",
            SpringGreen: "#C6DC67",
            Tan: "#DA9D76",
            TealBlue: "#00AEB3",
            Thistle: "#D883B7",
            Turquoise: "#00B4CE",
            Violet: "#58429B",
            VioletRed: "#EF58A0",
            White: "#FFFFFF",
            WildStrawberry: "#EE2967",
            Yellow: "#FFF200",
            YellowGreen: "#98CC70",
            YellowOrange: "#FAA21A"
        };

    function g(e) {
        var t, a, i, o, r, n;
        const s = e.split("!");
        let l, d, c, u = 255,
            m = 255,
            g = 255,
            v = -1;
        const k = s.length > 0 && s[0].startsWith("-");
        k && (s[0] = s[0].slice(1));
        for (let e = 0; e < s.length; e++) {
            l = u, d = m, c = g;
            const k = null === (t = s[e].trim().match(/^([A-Za-z\d]+)/)) || void 0 === t ? void 0 : t[1],
                x = null == k ? void 0 : k.toLowerCase(),
                w = k && null !== (n = null !== (r = null !== (o = null !== (i = null !== (a = f[x]) && void 0 !== a ? a : f[y[k]]) && void 0 !== i ? i : h[k]) && void 0 !== o ? o : b[k]) && void 0 !== r ? r : p[k]) && void 0 !== n ? n : s[e].trim();
            let _ = w.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
            if ((null == _ ? void 0 : _[1]) && _[2] && _[3]) u = Math.max(0, Math.min(255, Number.parseInt(_[1], 16))), m = Math.max(0, Math.min(255, Number.parseInt(_[2], 16))), g = Math.max(0, Math.min(255, Number.parseInt(_[3], 16)));
            else if (_ = w.match(/^#([\da-f]{3})$/i), null == _ ? void 0 : _[1]) {
                const e = Number.parseInt(_[1][0], 16),
                    t = Number.parseInt(_[1][1], 16),
                    a = Number.parseInt(_[1][2], 16);
                u = Math.max(0, Math.min(255, 16 * e + e)), m = Math.max(0, Math.min(255, 16 * t + t)), g = Math.max(0, Math.min(255, 16 * a + a))
            } else {
                if (_ = w.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i), !((null == _ ? void 0 : _[1]) && _[2] && _[3])) return;
                u = Math.max(0, Math.min(255, Number.parseInt(_[1]))), m = Math.max(0, Math.min(255, Number.parseInt(_[2]))), g = Math.max(0, Math.min(255, Number.parseInt(_[3])))
            }
            v >= 0 && (u = (1 - v) * u + v * l, m = (1 - v) * m + v * d, g = (1 - v) * g + v * c, v = -1), e + 1 < s.length && (v = Math.max(0, Math.min(100, Number.parseInt(s[++e]))) / 100)
        }
        return v >= 0 && (u = v * u + (1 - v) * l, m = v * m + (1 - v) * d, g = v * g + (1 - v) * c), k && (u = 255 - u, m = 255 - m, g = 255 - g), "#" + ("00" + Math.round(u).toString(16)).slice(-2) + ("00" + Math.round(m).toString(16)).slice(-2) + ("00" + Math.round(g).toString(16)).slice(-2)
    }

    function v(e) {
        var t, a;
        return e = e.trim(), null !== (a = null !== (t = m[e.toLowerCase()]) && void 0 !== t ? t : m[y[e]]) && void 0 !== a ? a : g(e)
    }

    function k(e, t, a) {
        return a < 0 && (a += 6), a >= 6 && (a -= 6), a < 1 ? (t - e) * a + e : a < 3 ? t : a < 4 ? (t - e) * (4 - a) + e : e
    }

    function x(e) {
        return e < 0 ? 0 : e > 255 ? 255 : Math.round(e)
    }

    function w(e) {
        let t = function(e) {
            if (!e) return;
            if ("#" !== e[0]) return;
            let t;
            return (e = e.slice(1)).length <= 4 ? (t = {
                r: parseInt(e[0] + e[0], 16),
                g: parseInt(e[1] + e[1], 16),
                b: parseInt(e[2] + e[2], 16)
            }, 4 === e.length && (t.a = parseInt(e[3] + e[3], 16) / 255)) : (t = {
                r: parseInt(e[0] + e[1], 16),
                g: parseInt(e[2] + e[3], 16),
                b: parseInt(e[4] + e[5], 16)
            }, 8 === e.length && (t.a = parseInt(e[6] + e[7], 16) / 255)), t && void 0 === t.a && (t.a = 1), t
        }(e);
        if (!t) return e;
        let {
            h: a,
            s: i,
            l: o
        } = function(e) {
            let {
                r: t,
                g: a,
                b: i
            } = e;
            t /= 255, a /= 255, i /= 255;
            const o = Math.min(t, a, i),
                r = Math.max(t, a, i),
                n = r - o;
            let s, l;
            r === o ? s = 0 : t === r ? s = (a - i) / n : a === r ? s = 2 + (i - t) / n : i === r && (s = 4 + (t - a) / n), s = Math.min(60 * s, 360), s < 0 && (s += 360);
            const d = (o + r) / 2;
            return l = r === o ? 0 : d <= .5 ? n / (r + o) : n / (2 - r - o), {
                h: s,
                s: l,
                l: d
            }
        }(t);
        return i += .1, o -= .1,
            function(e) {
                const {
                    r: t,
                    g: a,
                    b: i
                } = e;
                let o = (16777216 + (x(t) << 16) + (x(a) << 8) + x(i)).toString(16).slice(1);
                return o[0] === o[1] && o[2] === o[3] && o[4] === o[5] && o[6] === o[7] && (o = o[0] + o[2] + o[4]), "#" + o
            }(function(e) {
                let [t, a, i] = [e.h, e.s, e.l];
                t = (t + 360) % 360 / 60, i = Math.max(0, Math.min(i, 1)), a = Math.max(0, Math.min(a, 1));
                const o = i <= .5 ? i * (a + 1) : i + a - i * a,
                    r = 2 * i - o;
                return {
                    r: Math.round(255 * k(r, o, t + 2)),
                    g: Math.round(255 * k(r, o, t)),
                    b: Math.round(255 * k(r, o, t - 2))
                }
            }({
                h: a,
                s: i,
                l: o
            }))
    }
    const _ = {},
        S = {
            60: "\\lt",
            62: "\\gt",
            111: "o",
            38: "\\&",
            123: "\\lbrace",
            125: "\\rbrace",
            91: "\\lbrack",
            93: "\\rbrack",
            58: "\\colon",
            160: "~",
            172: "\\neg",
            183: "\\cdot",
            188: "\\frac{1}{4}",
            189: "\\frac{1}{2}",
            190: "\\frac{3}{4}",
            8304: "^{0}",
            8305: "^{i}",
            185: "^{1}",
            178: "^{2}",
            179: "^{3}",
            8224: "\\dagger",
            8225: "\\ddagger",
            8230: "\\ldots",
            8308: "^{4}",
            8309: "^{5}",
            8310: "^{6}",
            8311: "^{7}",
            8312: "^{8}",
            8313: "^{9}",
            8314: "^{+}",
            8315: "^{-}",
            8316: "^{=}",
            8319: "^{n}",
            8320: "_{0}",
            8321: "_{1}",
            8322: "_{2}",
            8323: "_{3}",
            8324: "_{4}",
            8325: "_{5}",
            8326: "_{6}",
            8327: "_{7}",
            8328: "_{8}",
            8329: "_{9}",
            8330: "_{+}",
            8331: "_{-}",
            8332: "_{=}",
            8336: "_{a}",
            8337: "_{e}",
            8338: "_{o}",
            8339: "_{x}",
            8242: "\\prime",
            39: "\\prime",
            8592: "\\gets",
            8594: "\\to",
            9651: "\\triangle",
            9661: "\\triangledown",
            8715: "\\owns",
            8727: "\\ast",
            8739: "\\vert",
            8741: "\\Vert",
            8743: "\\land",
            8744: "\\lor",
            8901: "\\cdot",
            8904: "\\bowtie",
            8800: "\\ne",
            8804: "\\le",
            8805: "\\ge",
            8869: "\\bot",
            10231: "\\biconditional",
            10232: "\\impliedby",
            10233: "\\implies",
            10234: "\\iff",
            8450: "\\mathbb{C}",
            8469: "\\mathbb{N}",
            8473: "\\mathbb{P}",
            8474: "\\mathbb{Q}",
            8477: "\\mathbb{R}",
            8484: "\\mathbb{Z}",
            8461: "\\mathbb{H}",
            8476: "\\Re",
            8465: "\\Im",
            42: "\\ast",
            11036: "\\square",
            9633: "\\square",
            8720: "\\coprod",
            8716: "\\not\\ni",
            9671: "\\diamond",
            8846: "\\uplus",
            8851: "\\sqcap",
            8852: "\\sqcup",
            8768: "\\wr",
            8750: "\\oint",
            8226: "\\textbullet",
            8722: "-",
            978: "\\Upsilon"
        },
        M = {},
        L = {},
        C = {
            iff: "\\;⟺\\;",
            nicefrac: "^{#1}\\!\\!/\\!_{#2}",
            rd: "\\mathrm{d}",
            rD: "\\mathrm{D}",
            doubleStruckCapitalN: "\\mathbb{N}",
            doubleStruckCapitalR: "\\mathbb{R}",
            doubleStruckCapitalQ: "\\mathbb{Q}",
            doubleStruckCapitalZ: "\\mathbb{Z}",
            doubleStruckCapitalP: "\\mathbb{P}",
            scriptCapitalE: "\\mathscr{E}",
            scriptCapitalH: "\\mathscr{H}",
            scriptCapitalL: "\\mathscr{L}",
            gothicCapitalC: "\\mathfrak{C}",
            gothicCapitalH: "\\mathfrak{H}",
            gothicCapitalI: "\\mathfrak{I}",
            gothicCapitalR: "\\mathfrak{R}",
            imaginaryI: "\\mathrm{i}",
            imaginaryJ: "\\mathrm{j}",
            exponentialE: "\\mathrm{e}",
            differentialD: "\\mathrm{d}",
            capitalDifferentialD: "\\mathrm{D}",
            "braket.sty": {
                package: {
                    bra: "\\mathinner{\\langle{#1}|}",
                    ket: "\\mathinner{|{#1}\\rangle}",
                    braket: "\\mathinner{\\langle{#1}\\rangle}",
                    set: "\\mathinner{\\lbrace #1 \\rbrace}",
                    Bra: "\\left\\langle #1\\right|",
                    Ket: "\\left|#1\\right\\rangle",
                    Braket: "\\left\\langle{#1}\\right\\rangle",
                    Set: "\\left\\lbrace #1 \\right\\rbrace"
                }
            },
            "amsmath.sty": {
                package: {
                    varGamma: "\\mathit{\\Gamma}",
                    varDelta: "\\mathit{\\Delta}",
                    varTheta: "\\mathit{\\Theta}",
                    varLambda: "\\mathit{\\Lambda}",
                    varXi: "\\mathit{\\Xi}",
                    varPi: "\\mathit{\\Pi}",
                    varSigma: "\\mathit{\\Sigma}",
                    varUpsilon: "\\mathit{\\Upsilon}",
                    varPhi: "\\mathit{\\Phi}",
                    varPsi: "\\mathit{\\Psi}",
                    varOmega: "\\mathit{\\Omega}",
                    pmod: {
                        def: "\\quad(\\operatorname{mod}\\ #1)",
                        args: 1,
                        expand: !1
                    },
                    mod: {
                        def: "\\quad\\operatorname{mod}\\,\\,#1",
                        args: 1,
                        expand: !1
                    },
                    bmod: {
                        def: "\\;\\mathbin{\\operatorname{mod }}",
                        expand: !1
                    }
                },
                expand: !1
            },
            "texvc.sty": {
                package: {
                    darr: "\\downarrow",
                    dArr: "\\Downarrow",
                    Darr: "\\Downarrow",
                    lang: "\\langle",
                    rang: "\\rangle",
                    uarr: "\\uparrow",
                    uArr: "\\Uparrow",
                    Uarr: "\\Uparrow",
                    N: "\\mathbb{N}",
                    R: "\\mathbb{R}",
                    Z: "\\mathbb{Z}",
                    alef: "\\aleph",
                    alefsym: "\\aleph",
                    Alpha: "\\mathrm{A}",
                    Beta: "\\mathrm{B}",
                    bull: "\\bullet",
                    Chi: "\\mathrm{X}",
                    clubs: "\\clubsuit",
                    cnums: "\\mathbb{C}",
                    Complex: "\\mathbb{C}",
                    Dagger: "\\ddagger",
                    diamonds: "\\diamondsuit",
                    empty: "\\emptyset",
                    Epsilon: "\\mathrm{E}",
                    Eta: "\\mathrm{H}",
                    exist: "\\exists",
                    harr: "\\leftrightarrow",
                    hArr: "\\Leftrightarrow",
                    Harr: "\\Leftrightarrow",
                    hearts: "\\heartsuit",
                    image: "\\Im",
                    infin: "\\infty",
                    Iota: "\\mathrm{I}",
                    isin: "\\in",
                    Kappa: "\\mathrm{K}",
                    larr: "\\leftarrow",
                    lArr: "\\Leftarrow",
                    Larr: "\\Leftarrow",
                    lrarr: "\\leftrightarrow",
                    lrArr: "\\Leftrightarrow",
                    Lrarr: "\\Leftrightarrow",
                    Mu: "\\mathrm{M}",
                    natnums: "\\mathbb{N}",
                    Nu: "\\mathrm{N}",
                    Omicron: "\\mathrm{O}",
                    plusmn: "\\pm",
                    rarr: "\\rightarrow",
                    rArr: "\\Rightarrow",
                    Rarr: "\\Rightarrow",
                    real: "\\Re",
                    reals: "\\mathbb{R}",
                    Reals: "\\mathbb{R}",
                    Rho: "\\mathrm{P}",
                    sdot: "\\cdot",
                    sect: "\\S",
                    spades: "\\spadesuit",
                    sub: "\\subset",
                    sube: "\\subseteq",
                    supe: "\\supseteq",
                    Tau: "\\mathrm{T}",
                    thetasym: "\\vartheta",
                    weierp: "\\wp",
                    Zeta: "\\mathrm{Z}"
                },
                expand: !1
            }
        },
        A = {
            " ": 32,
            "\\#": 35,
            "\\&": 38,
            "\\$": 36,
            "\\%": 37,
            "\\_": 95,
            "\\euro": 8364,
            "\\maltese": 10016,
            "\\{": 123,
            "\\}": 125,
            "\\nobreakspace": 160,
            "\\ldots": 8230,
            "\\textellipsis": 8230,
            "\\backslash": 92,
            "`": 8216,
            "'": 8217,
            "``": 8220,
            "''": 8221,
            "\\degree": 176,
            "\\textasciicircum": 94,
            "\\textasciitilde": 126,
            "\\textasteriskcentered": 42,
            "\\textbackslash": 92,
            "\\textbraceleft": 123,
            "\\textbraceright": 125,
            "\\textbullet": 8226,
            "\\textdollar": 36,
            "\\textsterling": 163,
            "\\textdagger": 8224,
            "\\textdaggerdbl": 8225,
            "–": 8211,
            "—": 8212,
            "‘": 8216,
            "’": 8217,
            "“": 8220,
            "”": 8221,
            '"': 8221,
            "\\ss": 223,
            "\\ae": 230,
            "\\oe": 339,
            "\\AE": 198,
            "\\OE": 338,
            "\\O": 216,
            "\\i": 305,
            "\\j": 567,
            "\\aa": 229,
            "\\AA": 197
        },
        D = /[\w!@*()-=+{}[\]\\';:?/.,~<>`|$%#&^" ]/,
        T = d() ? new RegExp("\\p{Letter}", "u") : /[a-zA-Z\u0430\u0410\u0431\u0411\u0432\u0412\u0433\u0413\u0434\u0414\u0435\u0415\u0451\u0401\u0436\u0416\u0437\u0417\u0438\u0418\u0439\u0419\u043a\u041a\u043b\u041b\u043c\u041c\u043d\u041d\u043e\u041e\u043f\u041f\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0444\u0424\u0445\u0425\u0446\u0426\u0447\u0427\u0448\u0428\u0449\u0429\u044a\u042a\u044b\u042b\u044c\u042c\u044d\u042d\u044e\u042e\u044f\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\xd3\xf3\u015a\u015b\u0179\u017a\u017b\u017c\xe0\xe2\xe4\xf4\xe9\xe8\xeb\xea\xef\xee\xe7\xf9\xfb\xfc\xff\xe6\u0153\xc0\xc2\xc4\xd4\xc9\xc8\xcb\xca\xcf\xce\u0178\xc7\xd9\xdb\xdc\xc6\u0152\xf6\xdf\xd6\u1e9e\xec\xed\xf2\xfa\xcc\xcd\xd2\xda\xe1\xf1\xc1\xd1]/,
        z = d() ? new RegExp("[0-9\\p{Letter}]", "u") : /[\da-zA-Z\u0430\u0410\u0431\u0411\u0432\u0412\u0433\u0413\u0434\u0414\u0435\u0415\u0451\u0401\u0436\u0416\u0437\u0417\u0438\u0418\u0439\u0419\u043a\u041a\u043b\u041b\u043c\u041c\u043d\u041d\u043e\u041e\u043f\u041f\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0444\u0424\u0445\u0425\u0446\u0426\u0447\u0427\u0448\u0428\u0449\u0429\u044a\u042a\u044b\u042b\u044c\u042c\u044d\u042d\u044e\u042e\u044f\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\xd3\xf3\u015a\u015b\u0179\u017a\u017b\u017c\xe0\xe2\xe4\xf4\xe9\xe8\xeb\xea\xef\xee\xe7\xf9\xfb\xfc\xff\xe6\u0153\xc0\xc2\xc4\xd4\xc9\xc8\xcb\xca\xcf\xce\u0178\xc7\xd9\xdb\xdc\xc6\u0152\xf6\xdf\xd6\u1e9e\xec\xed\xf2\xfa\xcc\xcd\xd2\xda\xe1\xf1\xc1\xd1]/;

    function B(e, t, a = "mord", i) {
        void 0 !== t && (_[e] = {
            definitionType: "symbol",
            type: a,
            variant: i,
            codepoint: t
        }, S[t] || (S[t] = e), A[e] || (A[e] = t))
    }

    function K(e, t, a) {
        if ("string" != typeof e)
            for (const [i, o, r, n] of e) B(i, o, null != r ? r : t, null != n ? n : a);
        else
            for (let t = 0; t < e.length; t++) {
                const a = e.charAt(t);
                B(a, a.codePointAt(0))
            }
    }

    function q(e, t) {
        for (let a = e; a <= t; a++) B(String.fromCodePoint(a), a)
    }

    function $(e, t) {
        if (void 0 === t) return "";
        if ("math" === e && S[t]) return S[t];
        if ("text" === e) {
            let e = Object.keys(A).find((e => A[e] === t));
            if (!e) {
                const a = t.toString(16);
                e = "^".repeat(a.length) + a
            }
            return e
        }
        return String.fromCodePoint(t)
    }
    const E = {
            119893: 8462,
            119965: 8492,
            119968: 8496,
            119969: 8497,
            119971: 8459,
            119972: 8464,
            119975: 8466,
            119976: 8499,
            119981: 8475,
            119994: 8495,
            119996: 8458,
            120004: 8500,
            120070: 8493,
            120075: 8460,
            120076: 8465,
            120085: 8476,
            120093: 8488,
            120122: 8450,
            120127: 8461,
            120133: 8469,
            120135: 8473,
            120136: 8474,
            120137: 8477,
            120145: 8484
        },
        O = [{
            start: 119808,
            len: 26,
            offset: 65,
            style: "bold"
        }, {
            start: 119834,
            len: 26,
            offset: 97,
            style: "bold"
        }, {
            start: 119860,
            len: 26,
            offset: 65,
            style: "italic"
        }, {
            start: 119886,
            len: 26,
            offset: 97,
            style: "italic"
        }, {
            start: 119912,
            len: 26,
            offset: 65,
            style: "bolditalic"
        }, {
            start: 119938,
            len: 26,
            offset: 97,
            style: "bolditalic"
        }, {
            start: 119964,
            len: 26,
            offset: 65,
            variant: "script"
        }, {
            start: 119990,
            len: 26,
            offset: 97,
            variant: "script"
        }, {
            start: 120016,
            len: 26,
            offset: 65,
            variant: "script",
            style: "bold"
        }, {
            start: 120042,
            len: 26,
            offset: 97,
            variant: "script",
            style: "bold"
        }, {
            start: 120068,
            len: 26,
            offset: 65,
            variant: "fraktur"
        }, {
            start: 120094,
            len: 26,
            offset: 97,
            variant: "fraktur"
        }, {
            start: 120172,
            len: 26,
            offset: 65,
            variant: "fraktur",
            style: "bold"
        }, {
            start: 120198,
            len: 26,
            offset: 97,
            variant: "fraktur",
            style: "bold"
        }, {
            start: 120120,
            len: 26,
            offset: 65,
            variant: "double-struck"
        }, {
            start: 120146,
            len: 26,
            offset: 97,
            variant: "double-struck"
        }, {
            start: 120224,
            len: 26,
            offset: 65,
            variant: "sans-serif"
        }, {
            start: 120250,
            len: 26,
            offset: 97,
            variant: "sans-serif"
        }, {
            start: 120276,
            len: 26,
            offset: 65,
            variant: "sans-serif",
            style: "bold"
        }, {
            start: 120302,
            len: 26,
            offset: 97,
            variant: "sans-serif",
            style: "bold"
        }, {
            start: 120328,
            len: 26,
            offset: 65,
            variant: "sans-serif",
            style: "italic"
        }, {
            start: 120354,
            len: 26,
            offset: 97,
            variant: "sans-serif",
            style: "italic"
        }, {
            start: 120380,
            len: 26,
            offset: 65,
            variant: "sans-serif",
            style: "bolditalic"
        }, {
            start: 120406,
            len: 26,
            offset: 97,
            variant: "sans-serif",
            style: "bolditalic"
        }, {
            start: 120432,
            len: 26,
            offset: 65,
            variant: "monospace"
        }, {
            start: 120458,
            len: 26,
            offset: 97,
            variant: "monospace"
        }, {
            start: 120488,
            len: 25,
            offset: 913,
            style: "bold"
        }, {
            start: 120514,
            len: 25,
            offset: 945,
            style: "bold"
        }, {
            start: 120546,
            len: 25,
            offset: 913,
            style: "italic"
        }, {
            start: 120572,
            len: 25,
            offset: 945,
            style: "italic"
        }, {
            start: 120604,
            len: 25,
            offset: 913,
            style: "bolditalic"
        }, {
            start: 120630,
            len: 25,
            offset: 945,
            style: "bolditalic"
        }, {
            start: 120662,
            len: 25,
            offset: 913,
            variant: "sans-serif",
            style: "bold"
        }, {
            start: 120688,
            len: 25,
            offset: 945,
            variant: "sans-serif",
            style: "bold"
        }, {
            start: 120720,
            len: 25,
            offset: 913,
            variant: "sans-serif",
            style: "bolditalic"
        }, {
            start: 120746,
            len: 25,
            offset: 945,
            variant: "sans-serif",
            style: "bolditalic"
        }, {
            start: 120782,
            len: 10,
            offset: 48,
            variant: "main",
            style: "bold"
        }, {
            start: 120792,
            len: 10,
            offset: 48,
            variant: "double-struck"
        }, {
            start: 120803,
            len: 10,
            offset: 48,
            variant: "sans-serif"
        }, {
            start: 120812,
            len: 10,
            offset: 48,
            variant: "sans-serif",
            style: "bold"
        }, {
            start: 120822,
            len: 10,
            offset: 48,
            variant: "monospace"
        }];

    function N(e) {
        let t = "auto";
        const a = e.match(/:([^=]+)/);
        return a && (t = a[1].trim()), t
    }

    function P(e) {
        if (!e) return [];
        const t = [];
        let a = e.split("]");
        if (a[0].startsWith("[")) {
            t.push({
                isOptional: !0,
                type: N(a[0].slice(1))
            });
            for (let e = 1; e <= a.length; e++) t.push(...P(a[e]))
        } else if (a = e.split("}"), a[0].startsWith("{")) {
            t.push({
                isOptional: !1,
                type: N(a[0].slice(1))
            });
            for (let e = 1; e <= a.length; e++) t.push(...P(a[e]))
        }
        return t
    }

    function F(e) {
        if (!e) return "";
        let t = "",
            a = !0;
        for (const i of e) "string" == typeof i.value ? t += i.value : a = !1;
        return a ? t : ""
    }

    function R(e, t, a, i = !1) {
        "string" == typeof e && (e = [e]);
        const o = {
            tabular: i,
            params: P(t),
            createAtom: a
        };
        for (const t of e) L[t] = o
    }

    function I(e, t, a) {
        R(e, t, a, !0)
    }

    function V(e, t, a) {
        var i, o;
        a || (a = {});
        const r = {
            definitionType: "function",
            params: P(t),
            ifMode: a.ifMode,
            isFunction: null !== (i = a.isFunction) && void 0 !== i && i,
            applyMode: a.applyMode,
            infix: null !== (o = a.infix) && void 0 !== o && o,
            createAtom: a.createAtom,
            applyStyle: a.applyStyle
        };
        if ("string" == typeof e) M["\\" + e] = r;
        else
            for (const t of e) M["\\" + t] = r
    }
    let j;

    function H(e) {
        return j || (j = J(C)), e ? J({
            ...j,
            ...e
        }) : j
    }

    function W(e, t) {
        var a, i, o, r;
        if ("string" == typeof e) {
            let o = 0;
            const r = e;
            return /(^|[^\\])#1/.test(r) && (o = 1), /(^|[^\\])#2/.test(r) && (o = 2), /(^|[^\\])#3/.test(r) && (o = 3), /(^|[^\\])#4/.test(r) && (o = 4), /(^|[^\\])#5/.test(r) && (o = 5), /(^|[^\\])#6/.test(r) && (o = 6), /(^|[^\\])#7/.test(r) && (o = 7), /(^|[^\\])#8/.test(r) && (o = 8), /(^|[^\\])#9/.test(r) && (o = 9), {
                expand: null === (a = null == t ? void 0 : t.expand) || void 0 === a || a,
                captureSelection: null === (i = null == t ? void 0 : t.captureSelection) || void 0 === i || i,
                args: o,
                def: r
            }
        }
        return {
            expand: null === (o = null == t ? void 0 : t.expand) || void 0 === o || o,
            captureSelection: null === (r = null == t ? void 0 : t.captureSelection) || void 0 === r || r,
            args: 0,
            ...e
        }
    }

    function J(e) {
        if (!e) return {};
        const t = {};
        for (const a of Object.keys(e)) {
            const i = e[a];
            if (null == i) delete t[a];
            else if ("object" == typeof i && "package" in i)
                for (const e of Object.keys(i.package)) t[e] = W(i.package[e], {
                    expand: i.expand,
                    captureSelection: i.captureSelection
                });
            else t[a] = W(i)
        }
        return t
    }
    const U = [0, .69444, 0, 0],
        X = [0, .61111, 0, 0],
        G = [.25, .75, 0, 0],
        Z = [0, .44444, 0, 0],
        Y = [0, .68611, 0, 0],
        Q = [.19444, .69444, 0, 0],
        ee = [0, .68333, 0, 0],
        te = [0, .68889, 0, 0],
        ae = [0, .69141, 0, 0],
        ie = [0, 0, 0, 0],
        oe = [0, .64444, 0, 0],
        re = [0, .69224, 0, 0],
        ne = [.19444, .44444, 0, 0],
        se = [.65002, 1.15, 0, 0],
        le = [0, .55556, 0, 0],
        de = [.35001, .85, 0, 0],
        ce = [1.25003, 1.75, 0, 0],
        ue = [.95003, 1.45, 0, 0],
        pe = [0, .75, 0, 0],
        he = [0, .47534, 0, 0],
        me = [.25001, .75, 0, 0],
        fe = [.55001, 1.05, 0, 0],
        ye = [.16667, .68889, 0, 0],
        be = [.08167, .58167, 0, 0];
    var ge = {
        "AMS-Regular": {
            32: ie,
            65: te,
            66: te,
            67: te,
            68: te,
            69: te,
            70: te,
            71: te,
            72: te,
            73: te,
            74: ye,
            75: te,
            76: te,
            77: te,
            78: te,
            79: ye,
            80: te,
            81: ye,
            82: te,
            83: te,
            84: te,
            85: te,
            86: te,
            87: te,
            88: te,
            89: te,
            90: te,
            107: te,
            160: ie,
            165: [0, .675, .025, 0],
            174: [.15559, .69224, 0, 0],
            240: te,
            295: te,
            710: [0, .825, 0, 0],
            732: [0, .9, 0, 0],
            770: [0, .825, 0, 0],
            771: [0, .9, 0, 0],
            989: be,
            1008: [0, .43056, .04028, 0],
            8245: [0, .54986, 0, 0],
            8463: te,
            8487: te,
            8498: te,
            8502: te,
            8503: te,
            8504: te,
            8513: te,
            8592: [-.03598, .46402, 0, 0],
            8594: [-.03598, .46402, 0, 0],
            8602: [-.13313, .36687, 0, 0],
            8603: [-.13313, .36687, 0, 0],
            8606: [.01354, .52239, 0, 0],
            8608: [.01354, .52239, 0, 0],
            8610: [.01354, .52239, 0, 0],
            8611: [.01354, .52239, 0, 0],
            8619: [0, .54986, 0, 0],
            8620: [0, .54986, 0, 0],
            8621: [-.13313, .37788, 0, 0],
            8622: [-.13313, .36687, 0, 0],
            8624: re,
            8625: re,
            8630: [0, .43056, 0, 0],
            8631: [0, .43056, 0, 0],
            8634: [.08198, .58198, 0, 0],
            8635: [.08198, .58198, 0, 0],
            8638: [.19444, .69224, 0, 0],
            8639: [.19444, .69224, 0, 0],
            8642: [.19444, .69224, 0, 0],
            8643: [.19444, .69224, 0, 0],
            8644: [.1808, .675, 0, 0],
            8646: [.1808, .675, 0, 0],
            8647: [.1808, .675, 0, 0],
            8648: [.19444, .69224, 0, 0],
            8649: [.1808, .675, 0, 0],
            8650: [.19444, .69224, 0, 0],
            8651: [.01354, .52239, 0, 0],
            8652: [.01354, .52239, 0, 0],
            8653: [-.13313, .36687, 0, 0],
            8654: [-.13313, .36687, 0, 0],
            8655: [-.13313, .36687, 0, 0],
            8666: [.13667, .63667, 0, 0],
            8667: [.13667, .63667, 0, 0],
            8669: [-.13313, .37788, 0, 0],
            8672: [-.064, .437, 0, 0],
            8674: [-.064, .437, 0, 0],
            8705: [0, .825, 0, 0],
            8708: te,
            8709: be,
            8717: [0, .43056, 0, 0],
            8722: [-.03598, .46402, 0, 0],
            8724: [.08198, .69224, 0, 0],
            8726: be,
            8733: re,
            8736: re,
            8737: re,
            8738: [.03517, .52239, 0, 0],
            8739: be,
            8740: [.25142, .74111, 0, 0],
            8741: be,
            8742: [.25142, .74111, 0, 0],
            8756: re,
            8757: re,
            8764: [-.13313, .36687, 0, 0],
            8765: [-.13313, .37788, 0, 0],
            8769: [-.13313, .36687, 0, 0],
            8770: [-.03625, .46375, 0, 0],
            8774: [.30274, .79383, 0, 0],
            8776: [-.01688, .48312, 0, 0],
            8778: be,
            8782: [.06062, .54986, 0, 0],
            8783: [.06062, .54986, 0, 0],
            8785: [.08198, .58198, 0, 0],
            8786: [.08198, .58198, 0, 0],
            8787: [.08198, .58198, 0, 0],
            8790: re,
            8791: [.22958, .72958, 0, 0],
            8796: [.08198, .91667, 0, 0],
            8806: [.25583, .75583, 0, 0],
            8807: [.25583, .75583, 0, 0],
            8808: [.25142, .75726, 0, 0],
            8809: [.25142, .75726, 0, 0],
            8812: [.25583, .75583, 0, 0],
            8814: [.20576, .70576, 0, 0],
            8815: [.20576, .70576, 0, 0],
            8816: [.30274, .79383, 0, 0],
            8817: [.30274, .79383, 0, 0],
            8818: [.22958, .72958, 0, 0],
            8819: [.22958, .72958, 0, 0],
            8822: [.1808, .675, 0, 0],
            8823: [.1808, .675, 0, 0],
            8828: [.13667, .63667, 0, 0],
            8829: [.13667, .63667, 0, 0],
            8830: [.22958, .72958, 0, 0],
            8831: [.22958, .72958, 0, 0],
            8832: [.20576, .70576, 0, 0],
            8833: [.20576, .70576, 0, 0],
            8840: [.30274, .79383, 0, 0],
            8841: [.30274, .79383, 0, 0],
            8842: [.13597, .63597, 0, 0],
            8843: [.13597, .63597, 0, 0],
            8847: [.03517, .54986, 0, 0],
            8848: [.03517, .54986, 0, 0],
            8858: [.08198, .58198, 0, 0],
            8859: [.08198, .58198, 0, 0],
            8861: [.08198, .58198, 0, 0],
            8862: [0, .675, 0, 0],
            8863: [0, .675, 0, 0],
            8864: [0, .675, 0, 0],
            8865: [0, .675, 0, 0],
            8872: re,
            8873: re,
            8874: re,
            8876: te,
            8877: te,
            8878: te,
            8879: te,
            8882: [.03517, .54986, 0, 0],
            8883: [.03517, .54986, 0, 0],
            8884: [.13667, .63667, 0, 0],
            8885: [.13667, .63667, 0, 0],
            8888: [0, .54986, 0, 0],
            8890: [.19444, .43056, 0, 0],
            8891: [.19444, .69224, 0, 0],
            8892: [.19444, .69224, 0, 0],
            8901: [0, .54986, 0, 0],
            8903: be,
            8905: be,
            8906: be,
            8907: re,
            8908: re,
            8909: [-.03598, .46402, 0, 0],
            8910: [0, .54986, 0, 0],
            8911: [0, .54986, 0, 0],
            8912: [.03517, .54986, 0, 0],
            8913: [.03517, .54986, 0, 0],
            8914: [0, .54986, 0, 0],
            8915: [0, .54986, 0, 0],
            8916: re,
            8918: [.0391, .5391, 0, 0],
            8919: [.0391, .5391, 0, 0],
            8920: [.03517, .54986, 0, 0],
            8921: [.03517, .54986, 0, 0],
            8922: [.38569, .88569, 0, 0],
            8923: [.38569, .88569, 0, 0],
            8926: [.13667, .63667, 0, 0],
            8927: [.13667, .63667, 0, 0],
            8928: [.30274, .79383, 0, 0],
            8929: [.30274, .79383, 0, 0],
            8934: [.23222, .74111, 0, 0],
            8935: [.23222, .74111, 0, 0],
            8936: [.23222, .74111, 0, 0],
            8937: [.23222, .74111, 0, 0],
            8938: [.20576, .70576, 0, 0],
            8939: [.20576, .70576, 0, 0],
            8940: [.30274, .79383, 0, 0],
            8941: [.30274, .79383, 0, 0],
            8994: [.19444, .69224, 0, 0],
            8995: [.19444, .69224, 0, 0],
            9416: [.15559, .69224, 0, 0],
            9484: re,
            9488: re,
            9492: [0, .37788, 0, 0],
            9496: [0, .37788, 0, 0],
            9585: [.19444, .68889, 0, 0],
            9586: [.19444, .74111, 0, 0],
            9632: [0, .675, 0, 0],
            9633: [0, .675, 0, 0],
            9650: [0, .54986, 0, 0],
            9651: [0, .54986, 0, 0],
            9654: [.03517, .54986, 0, 0],
            9660: [0, .54986, 0, 0],
            9661: [0, .54986, 0, 0],
            9664: [.03517, .54986, 0, 0],
            9674: [.11111, .69224, 0, 0],
            9733: [.19444, .69224, 0, 0],
            10003: re,
            10016: re,
            10731: [.11111, .69224, 0, 0],
            10846: [.19444, .75583, 0, 0],
            10877: [.13667, .63667, 0, 0],
            10878: [.13667, .63667, 0, 0],
            10885: [.25583, .75583, 0, 0],
            10886: [.25583, .75583, 0, 0],
            10887: [.13597, .63597, 0, 0],
            10888: [.13597, .63597, 0, 0],
            10889: [.26167, .75726, 0, 0],
            10890: [.26167, .75726, 0, 0],
            10891: [.48256, .98256, 0, 0],
            10892: [.48256, .98256, 0, 0],
            10901: [.13667, .63667, 0, 0],
            10902: [.13667, .63667, 0, 0],
            10933: [.25142, .75726, 0, 0],
            10934: [.25142, .75726, 0, 0],
            10935: [.26167, .75726, 0, 0],
            10936: [.26167, .75726, 0, 0],
            10937: [.26167, .75726, 0, 0],
            10938: [.26167, .75726, 0, 0],
            10949: [.25583, .75583, 0, 0],
            10950: [.25583, .75583, 0, 0],
            10955: [.28481, .79383, 0, 0],
            10956: [.28481, .79383, 0, 0],
            57350: be,
            57351: be,
            57352: be,
            57353: [0, .43056, .04028, 0],
            57356: [.25142, .75726, 0, 0],
            57357: [.25142, .75726, 0, 0],
            57358: [.41951, .91951, 0, 0],
            57359: [.30274, .79383, 0, 0],
            57360: [.30274, .79383, 0, 0],
            57361: [.41951, .91951, 0, 0],
            57366: [.25142, .75726, 0, 0],
            57367: [.25142, .75726, 0, 0],
            57368: [.25142, .75726, 0, 0],
            57369: [.25142, .75726, 0, 0],
            57370: [.13597, .63597, 0, 0],
            57371: [.13597, .63597, 0, 0]
        },
        "Caligraphic-Regular": {
            32: ie,
            65: [0, .68333, 0, .19445],
            66: [0, .68333, .03041, .13889],
            67: [0, .68333, .05834, .13889],
            68: [0, .68333, .02778, .08334],
            69: [0, .68333, .08944, .11111],
            70: [0, .68333, .09931, .11111],
            71: [.09722, .68333, .0593, .11111],
            72: [0, .68333, .00965, .11111],
            73: [0, .68333, .07382, 0],
            74: [.09722, .68333, .18472, .16667],
            75: [0, .68333, .01445, .05556],
            76: [0, .68333, 0, .13889],
            77: [0, .68333, 0, .13889],
            78: [0, .68333, .14736, .08334],
            79: [0, .68333, .02778, .11111],
            80: [0, .68333, .08222, .08334],
            81: [.09722, .68333, 0, .11111],
            82: [0, .68333, 0, .08334],
            83: [0, .68333, .075, .13889],
            84: [0, .68333, .25417, 0],
            85: [0, .68333, .09931, .08334],
            86: [0, .68333, .08222, 0],
            87: [0, .68333, .08222, .08334],
            88: [0, .68333, .14643, .13889],
            89: [.09722, .68333, .08222, .08334],
            90: [0, .68333, .07944, .13889],
            160: ie
        },
        "Fraktur-Regular": {
            32: ie,
            33: ae,
            34: ae,
            38: ae,
            39: ae,
            40: [.24982, .74947, 0, 0],
            41: [.24982, .74947, 0, 0],
            42: [0, .62119, 0, 0],
            43: [.08319, .58283, 0, 0],
            44: [0, .10803, 0, 0],
            45: [.08319, .58283, 0, 0],
            46: [0, .10803, 0, 0],
            47: [.24982, .74947, 0, 0],
            48: he,
            49: he,
            50: he,
            51: [.18906, .47534, 0, 0],
            52: [.18906, .47534, 0, 0],
            53: [.18906, .47534, 0, 0],
            54: ae,
            55: [.18906, .47534, 0, 0],
            56: ae,
            57: [.18906, .47534, 0, 0],
            58: he,
            59: [.12604, .47534, 0, 0],
            61: [-.13099, .36866, 0, 0],
            63: ae,
            65: ae,
            66: ae,
            67: ae,
            68: ae,
            69: ae,
            70: [.12604, .69141, 0, 0],
            71: ae,
            72: [.06302, .69141, 0, 0],
            73: ae,
            74: [.12604, .69141, 0, 0],
            75: ae,
            76: ae,
            77: ae,
            78: ae,
            79: ae,
            80: [.18906, .69141, 0, 0],
            81: [.03781, .69141, 0, 0],
            82: ae,
            83: ae,
            84: ae,
            85: ae,
            86: ae,
            87: ae,
            88: ae,
            89: [.18906, .69141, 0, 0],
            90: [.12604, .69141, 0, 0],
            91: [.24982, .74947, 0, 0],
            93: [.24982, .74947, 0, 0],
            94: ae,
            97: he,
            98: ae,
            99: he,
            100: [0, .62119, 0, 0],
            101: he,
            102: [.18906, .69141, 0, 0],
            103: [.18906, .47534, 0, 0],
            104: [.18906, .69141, 0, 0],
            105: ae,
            106: ae,
            107: ae,
            108: ae,
            109: he,
            110: he,
            111: he,
            112: [.18906, .52396, 0, 0],
            113: [.18906, .47534, 0, 0],
            114: he,
            115: he,
            116: [0, .62119, 0, 0],
            117: he,
            118: [0, .52396, 0, 0],
            119: [0, .52396, 0, 0],
            120: [.18906, .47534, 0, 0],
            121: [.18906, .47534, 0, 0],
            122: [.18906, .47534, 0, 0],
            160: ie,
            8216: ae,
            8217: ae,
            58112: [0, .62119, 0, 0],
            58113: [0, .62119, 0, 0],
            58114: [.18906, .69141, 0, 0],
            58115: [.18906, .69141, 0, 0],
            58116: [.18906, .47534, 0, 0],
            58117: ae,
            58118: [0, .62119, 0, 0],
            58119: he
        },
        "Main-Bold": {
            32: ie,
            33: U,
            34: U,
            35: Q,
            36: [.05556, .75, 0, 0],
            37: [.05556, .75, 0, 0],
            38: U,
            39: U,
            40: G,
            41: G,
            42: pe,
            43: [.13333, .63333, 0, 0],
            44: [.19444, .15556, 0, 0],
            45: Z,
            46: [0, .15556, 0, 0],
            47: G,
            48: oe,
            49: oe,
            50: oe,
            51: oe,
            52: oe,
            53: oe,
            54: oe,
            55: oe,
            56: oe,
            57: oe,
            58: Z,
            59: ne,
            60: [.08556, .58556, 0, 0],
            61: [-.10889, .39111, 0, 0],
            62: [.08556, .58556, 0, 0],
            63: U,
            64: U,
            65: Y,
            66: Y,
            67: Y,
            68: Y,
            69: Y,
            70: Y,
            71: Y,
            72: Y,
            73: Y,
            74: Y,
            75: Y,
            76: Y,
            77: Y,
            78: Y,
            79: Y,
            80: Y,
            81: [.19444, .68611, 0, 0],
            82: Y,
            83: Y,
            84: Y,
            85: Y,
            86: [0, .68611, .01597, 0],
            87: [0, .68611, .01597, 0],
            88: Y,
            89: [0, .68611, .02875, 0],
            90: Y,
            91: G,
            92: G,
            93: G,
            94: U,
            95: [.31, .13444, .03194, 0],
            97: Z,
            98: U,
            99: Z,
            100: U,
            101: Z,
            102: [0, .69444, .10903, 0],
            103: [.19444, .44444, .01597, 0],
            104: U,
            105: U,
            106: Q,
            107: U,
            108: U,
            109: Z,
            110: Z,
            111: Z,
            112: ne,
            113: ne,
            114: Z,
            115: Z,
            116: [0, .63492, 0, 0],
            117: Z,
            118: [0, .44444, .01597, 0],
            119: [0, .44444, .01597, 0],
            120: Z,
            121: [.19444, .44444, .01597, 0],
            122: Z,
            123: G,
            124: G,
            125: G,
            126: [.35, .34444, 0, 0],
            160: ie,
            163: U,
            168: U,
            172: Z,
            176: U,
            177: [.13333, .63333, 0, 0],
            184: [.17014, 0, 0, 0],
            198: Y,
            215: [.13333, .63333, 0, 0],
            216: [.04861, .73472, 0, 0],
            223: U,
            230: Z,
            247: [.13333, .63333, 0, 0],
            248: [.09722, .54167, 0, 0],
            305: Z,
            338: Y,
            339: Z,
            567: ne,
            710: U,
            711: [0, .63194, 0, 0],
            713: [0, .59611, 0, 0],
            714: U,
            715: U,
            728: U,
            729: U,
            730: U,
            732: U,
            733: U,
            915: Y,
            916: Y,
            920: Y,
            923: Y,
            926: Y,
            928: Y,
            931: Y,
            933: Y,
            934: Y,
            936: Y,
            937: Y,
            8211: [0, .44444, .03194, 0],
            8212: [0, .44444, .03194, 0],
            8216: U,
            8217: U,
            8220: U,
            8221: U,
            8224: Q,
            8225: Q,
            8242: le,
            8407: [0, .72444, .15486, 0],
            8463: U,
            8465: U,
            8467: U,
            8472: ne,
            8476: U,
            8501: U,
            8592: [-.10889, .39111, 0, 0],
            8593: Q,
            8594: [-.10889, .39111, 0, 0],
            8595: Q,
            8596: [-.10889, .39111, 0, 0],
            8597: G,
            8598: Q,
            8599: Q,
            8600: Q,
            8601: Q,
            8636: [-.10889, .39111, 0, 0],
            8637: [-.10889, .39111, 0, 0],
            8640: [-.10889, .39111, 0, 0],
            8641: [-.10889, .39111, 0, 0],
            8656: [-.10889, .39111, 0, 0],
            8657: Q,
            8658: [-.10889, .39111, 0, 0],
            8659: Q,
            8660: [-.10889, .39111, 0, 0],
            8661: G,
            8704: U,
            8706: [0, .69444, .06389, 0],
            8707: U,
            8709: [.05556, .75, 0, 0],
            8711: Y,
            8712: [.08556, .58556, 0, 0],
            8715: [.08556, .58556, 0, 0],
            8722: [.13333, .63333, 0, 0],
            8723: [.13333, .63333, 0, 0],
            8725: G,
            8726: G,
            8727: [-.02778, .47222, 0, 0],
            8728: [-.02639, .47361, 0, 0],
            8729: [-.02639, .47361, 0, 0],
            8730: [.18, .82, 0, 0],
            8733: Z,
            8734: Z,
            8736: re,
            8739: G,
            8741: G,
            8743: le,
            8744: le,
            8745: le,
            8746: le,
            8747: [.19444, .69444, .12778, 0],
            8764: [-.10889, .39111, 0, 0],
            8768: Q,
            8771: [.00222, .50222, 0, 0],
            8776: [.02444, .52444, 0, 0],
            8781: [.00222, .50222, 0, 0],
            8801: [.00222, .50222, 0, 0],
            8804: [.19667, .69667, 0, 0],
            8805: [.19667, .69667, 0, 0],
            8810: [.08556, .58556, 0, 0],
            8811: [.08556, .58556, 0, 0],
            8826: [.08556, .58556, 0, 0],
            8827: [.08556, .58556, 0, 0],
            8834: [.08556, .58556, 0, 0],
            8835: [.08556, .58556, 0, 0],
            8838: [.19667, .69667, 0, 0],
            8839: [.19667, .69667, 0, 0],
            8846: le,
            8849: [.19667, .69667, 0, 0],
            8850: [.19667, .69667, 0, 0],
            8851: le,
            8852: le,
            8853: [.13333, .63333, 0, 0],
            8854: [.13333, .63333, 0, 0],
            8855: [.13333, .63333, 0, 0],
            8856: [.13333, .63333, 0, 0],
            8857: [.13333, .63333, 0, 0],
            8866: U,
            8867: U,
            8868: U,
            8869: U,
            8900: [-.02639, .47361, 0, 0],
            8901: [-.02639, .47361, 0, 0],
            8902: [-.02778, .47222, 0, 0],
            8968: G,
            8969: G,
            8970: G,
            8971: G,
            8994: [-.13889, .36111, 0, 0],
            8995: [-.13889, .36111, 0, 0],
            9651: Q,
            9657: [-.02778, .47222, 0, 0],
            9661: Q,
            9667: [-.02778, .47222, 0, 0],
            9711: Q,
            9824: [.12963, .69444, 0, 0],
            9825: [.12963, .69444, 0, 0],
            9826: [.12963, .69444, 0, 0],
            9827: [.12963, .69444, 0, 0],
            9837: pe,
            9838: Q,
            9839: Q,
            10216: G,
            10217: G,
            10815: Y,
            10927: [.19667, .69667, 0, 0],
            10928: [.19667, .69667, 0, 0],
            57376: Q
        },
        "Main-BoldItalic": {
            32: ie,
            33: [0, .69444, .11417, 0],
            34: [0, .69444, .07939, 0],
            35: [.19444, .69444, .06833, 0],
            37: [.05556, .75, .12861, 0],
            38: [0, .69444, .08528, 0],
            39: [0, .69444, .12945, 0],
            40: [.25, .75, .15806, 0],
            41: [.25, .75, .03306, 0],
            42: [0, .75, .14333, 0],
            43: [.10333, .60333, .03306, 0],
            44: [.19444, .14722, 0, 0],
            45: [0, .44444, .02611, 0],
            46: [0, .14722, 0, 0],
            47: [.25, .75, .15806, 0],
            48: [0, .64444, .13167, 0],
            49: [0, .64444, .13167, 0],
            50: [0, .64444, .13167, 0],
            51: [0, .64444, .13167, 0],
            52: [.19444, .64444, .13167, 0],
            53: [0, .64444, .13167, 0],
            54: [0, .64444, .13167, 0],
            55: [.19444, .64444, .13167, 0],
            56: [0, .64444, .13167, 0],
            57: [0, .64444, .13167, 0],
            58: [0, .44444, .06695, 0],
            59: [.19444, .44444, .06695, 0],
            61: [-.10889, .39111, .06833, 0],
            63: [0, .69444, .11472, 0],
            64: [0, .69444, .09208, 0],
            65: Y,
            66: [0, .68611, .0992, 0],
            67: [0, .68611, .14208, 0],
            68: [0, .68611, .09062, 0],
            69: [0, .68611, .11431, 0],
            70: [0, .68611, .12903, 0],
            71: [0, .68611, .07347, 0],
            72: [0, .68611, .17208, 0],
            73: [0, .68611, .15681, 0],
            74: [0, .68611, .145, 0],
            75: [0, .68611, .14208, 0],
            76: Y,
            77: [0, .68611, .17208, 0],
            78: [0, .68611, .17208, 0],
            79: [0, .68611, .09062, 0],
            80: [0, .68611, .0992, 0],
            81: [.19444, .68611, .09062, 0],
            82: [0, .68611, .02559, 0],
            83: [0, .68611, .11264, 0],
            84: [0, .68611, .12903, 0],
            85: [0, .68611, .17208, 0],
            86: [0, .68611, .18625, 0],
            87: [0, .68611, .18625, 0],
            88: [0, .68611, .15681, 0],
            89: [0, .68611, .19803, 0],
            90: [0, .68611, .14208, 0],
            91: [.25, .75, .1875, 0],
            93: [.25, .75, .09972, 0],
            94: [0, .69444, .06709, 0],
            95: [.31, .13444, .09811, 0],
            97: [0, .44444, .09426, 0],
            98: [0, .69444, .07861, 0],
            99: [0, .44444, .05222, 0],
            100: [0, .69444, .10861, 0],
            101: [0, .44444, .085, 0],
            102: [.19444, .69444, .21778, 0],
            103: [.19444, .44444, .105, 0],
            104: [0, .69444, .09426, 0],
            105: [0, .69326, .11387, 0],
            106: [.19444, .69326, .1672, 0],
            107: [0, .69444, .11111, 0],
            108: [0, .69444, .10861, 0],
            109: [0, .44444, .09426, 0],
            110: [0, .44444, .09426, 0],
            111: [0, .44444, .07861, 0],
            112: [.19444, .44444, .07861, 0],
            113: [.19444, .44444, .105, 0],
            114: [0, .44444, .11111, 0],
            115: [0, .44444, .08167, 0],
            116: [0, .63492, .09639, 0],
            117: [0, .44444, .09426, 0],
            118: [0, .44444, .11111, 0],
            119: [0, .44444, .11111, 0],
            120: [0, .44444, .12583, 0],
            121: [.19444, .44444, .105, 0],
            122: [0, .44444, .13889, 0],
            126: [.35, .34444, .11472, 0],
            160: ie,
            168: [0, .69444, .11473, 0],
            176: U,
            184: [.17014, 0, 0, 0],
            198: [0, .68611, .11431, 0],
            216: [.04861, .73472, .09062, 0],
            223: [.19444, .69444, .09736, 0],
            230: [0, .44444, .085, 0],
            248: [.09722, .54167, .09458, 0],
            305: [0, .44444, .09426, 0],
            338: [0, .68611, .11431, 0],
            339: [0, .44444, .085, 0],
            567: [.19444, .44444, .04611, 0],
            710: [0, .69444, .06709, 0],
            711: [0, .63194, .08271, 0],
            713: [0, .59444, .10444, 0],
            714: [0, .69444, .08528, 0],
            715: U,
            728: [0, .69444, .10333, 0],
            729: [0, .69444, .12945, 0],
            730: U,
            732: [0, .69444, .11472, 0],
            733: [0, .69444, .11472, 0],
            915: [0, .68611, .12903, 0],
            916: Y,
            920: [0, .68611, .09062, 0],
            923: Y,
            926: [0, .68611, .15092, 0],
            928: [0, .68611, .17208, 0],
            931: [0, .68611, .11431, 0],
            933: [0, .68611, .10778, 0],
            934: [0, .68611, .05632, 0],
            936: [0, .68611, .10778, 0],
            937: [0, .68611, .0992, 0],
            8211: [0, .44444, .09811, 0],
            8212: [0, .44444, .09811, 0],
            8216: [0, .69444, .12945, 0],
            8217: [0, .69444, .12945, 0],
            8220: [0, .69444, .16772, 0],
            8221: [0, .69444, .07939, 0]
        },
        "Main-Italic": {
            32: ie,
            33: [0, .69444, .12417, 0],
            34: [0, .69444, .06961, 0],
            35: [.19444, .69444, .06616, 0],
            37: [.05556, .75, .13639, 0],
            38: [0, .69444, .09694, 0],
            39: [0, .69444, .12417, 0],
            40: [.25, .75, .16194, 0],
            41: [.25, .75, .03694, 0],
            42: [0, .75, .14917, 0],
            43: [.05667, .56167, .03694, 0],
            44: [.19444, .10556, 0, 0],
            45: [0, .43056, .02826, 0],
            46: [0, .10556, 0, 0],
            47: [.25, .75, .16194, 0],
            48: [0, .64444, .13556, 0],
            49: [0, .64444, .13556, 0],
            50: [0, .64444, .13556, 0],
            51: [0, .64444, .13556, 0],
            52: [.19444, .64444, .13556, 0],
            53: [0, .64444, .13556, 0],
            54: [0, .64444, .13556, 0],
            55: [.19444, .64444, .13556, 0],
            56: [0, .64444, .13556, 0],
            57: [0, .64444, .13556, 0],
            58: [0, .43056, .0582, 0],
            59: [.19444, .43056, .0582, 0],
            61: [-.13313, .36687, .06616, 0],
            63: [0, .69444, .1225, 0],
            64: [0, .69444, .09597, 0],
            65: ee,
            66: [0, .68333, .10257, 0],
            67: [0, .68333, .14528, 0],
            68: [0, .68333, .09403, 0],
            69: [0, .68333, .12028, 0],
            70: [0, .68333, .13305, 0],
            71: [0, .68333, .08722, 0],
            72: [0, .68333, .16389, 0],
            73: [0, .68333, .15806, 0],
            74: [0, .68333, .14028, 0],
            75: [0, .68333, .14528, 0],
            76: ee,
            77: [0, .68333, .16389, 0],
            78: [0, .68333, .16389, 0],
            79: [0, .68333, .09403, 0],
            80: [0, .68333, .10257, 0],
            81: [.19444, .68333, .09403, 0],
            82: [0, .68333, .03868, 0],
            83: [0, .68333, .11972, 0],
            84: [0, .68333, .13305, 0],
            85: [0, .68333, .16389, 0],
            86: [0, .68333, .18361, 0],
            87: [0, .68333, .18361, 0],
            88: [0, .68333, .15806, 0],
            89: [0, .68333, .19383, 0],
            90: [0, .68333, .14528, 0],
            91: [.25, .75, .1875, 0],
            93: [.25, .75, .10528, 0],
            94: [0, .69444, .06646, 0],
            95: [.31, .12056, .09208, 0],
            97: [0, .43056, .07671, 0],
            98: [0, .69444, .06312, 0],
            99: [0, .43056, .05653, 0],
            100: [0, .69444, .10333, 0],
            101: [0, .43056, .07514, 0],
            102: [.19444, .69444, .21194, 0],
            103: [.19444, .43056, .08847, 0],
            104: [0, .69444, .07671, 0],
            105: [0, .65536, .1019, 0],
            106: [.19444, .65536, .14467, 0],
            107: [0, .69444, .10764, 0],
            108: [0, .69444, .10333, 0],
            109: [0, .43056, .07671, 0],
            110: [0, .43056, .07671, 0],
            111: [0, .43056, .06312, 0],
            112: [.19444, .43056, .06312, 0],
            113: [.19444, .43056, .08847, 0],
            114: [0, .43056, .10764, 0],
            115: [0, .43056, .08208, 0],
            116: [0, .61508, .09486, 0],
            117: [0, .43056, .07671, 0],
            118: [0, .43056, .10764, 0],
            119: [0, .43056, .10764, 0],
            120: [0, .43056, .12042, 0],
            121: [.19444, .43056, .08847, 0],
            122: [0, .43056, .12292, 0],
            126: [.35, .31786, .11585, 0],
            160: ie,
            168: [0, .66786, .10474, 0],
            176: U,
            184: [.17014, 0, 0, 0],
            198: [0, .68333, .12028, 0],
            216: [.04861, .73194, .09403, 0],
            223: [.19444, .69444, .10514, 0],
            230: [0, .43056, .07514, 0],
            248: [.09722, .52778, .09194, 0],
            338: [0, .68333, .12028, 0],
            339: [0, .43056, .07514, 0],
            710: [0, .69444, .06646, 0],
            711: [0, .62847, .08295, 0],
            713: [0, .56167, .10333, 0],
            714: [0, .69444, .09694, 0],
            715: U,
            728: [0, .69444, .10806, 0],
            729: [0, .66786, .11752, 0],
            730: U,
            732: [0, .66786, .11585, 0],
            733: [0, .69444, .1225, 0],
            915: [0, .68333, .13305, 0],
            916: ee,
            920: [0, .68333, .09403, 0],
            923: ee,
            926: [0, .68333, .15294, 0],
            928: [0, .68333, .16389, 0],
            931: [0, .68333, .12028, 0],
            933: [0, .68333, .11111, 0],
            934: [0, .68333, .05986, 0],
            936: [0, .68333, .11111, 0],
            937: [0, .68333, .10257, 0],
            8211: [0, .43056, .09208, 0],
            8212: [0, .43056, .09208, 0],
            8216: [0, .69444, .12417, 0],
            8217: [0, .69444, .12417, 0],
            8220: [0, .69444, .1685, 0],
            8221: [0, .69444, .06961, 0],
            8463: te
        },
        "Main-Regular": {
            32: ie,
            33: U,
            34: U,
            35: Q,
            36: [.05556, .75, 0, 0],
            37: [.05556, .75, 0, 0],
            38: U,
            39: U,
            40: G,
            41: G,
            42: pe,
            43: [.08333, .58333, 0, 0],
            44: [.19444, .10556, 0, 0],
            45: [0, .43056, 0, 0],
            46: [0, .10556, 0, 0],
            47: G,
            48: oe,
            49: oe,
            50: oe,
            51: oe,
            52: oe,
            53: oe,
            54: oe,
            55: oe,
            56: oe,
            57: oe,
            58: [0, .43056, 0, 0],
            59: [.19444, .43056, 0, 0],
            60: [.0391, .5391, 0, 0],
            61: [-.13313, .36687, 0, 0],
            62: [.0391, .5391, 0, 0],
            63: U,
            64: U,
            65: ee,
            66: ee,
            67: ee,
            68: ee,
            69: ee,
            70: ee,
            71: ee,
            72: ee,
            73: ee,
            74: ee,
            75: ee,
            76: ee,
            77: ee,
            78: ee,
            79: ee,
            80: ee,
            81: [.19444, .68333, 0, 0],
            82: ee,
            83: ee,
            84: ee,
            85: ee,
            86: [0, .68333, .01389, 0],
            87: [0, .68333, .01389, 0],
            88: ee,
            89: [0, .68333, .025, 0],
            90: ee,
            91: G,
            92: G,
            93: G,
            94: U,
            95: [.31, .12056, .02778, 0],
            97: [0, .43056, 0, 0],
            98: U,
            99: [0, .43056, 0, 0],
            100: U,
            101: [0, .43056, 0, 0],
            102: [0, .69444, .07778, 0],
            103: [.19444, .43056, .01389, 0],
            104: U,
            105: [0, .66786, 0, 0],
            106: [.19444, .66786, 0, 0],
            107: U,
            108: U,
            109: [0, .43056, 0, 0],
            110: [0, .43056, 0, 0],
            111: [0, .43056, 0, 0],
            112: [.19444, .43056, 0, 0],
            113: [.19444, .43056, 0, 0],
            114: [0, .43056, 0, 0],
            115: [0, .43056, 0, 0],
            116: [0, .61508, 0, 0],
            117: [0, .43056, 0, 0],
            118: [0, .43056, .01389, 0],
            119: [0, .43056, .01389, 0],
            120: [0, .43056, 0, 0],
            121: [.19444, .43056, .01389, 0],
            122: [0, .43056, 0, 0],
            123: G,
            124: G,
            125: G,
            126: [.35, .31786, 0, 0],
            160: ie,
            163: U,
            167: Q,
            168: [0, .66786, 0, 0],
            172: [0, .43056, 0, 0],
            176: U,
            177: [.08333, .58333, 0, 0],
            182: Q,
            184: [.17014, 0, 0, 0],
            198: ee,
            215: [.08333, .58333, 0, 0],
            216: [.04861, .73194, 0, 0],
            223: U,
            230: [0, .43056, 0, 0],
            247: [.08333, .58333, 0, 0],
            248: [.09722, .52778, 0, 0],
            305: [0, .43056, 0, 0],
            338: ee,
            339: [0, .43056, 0, 0],
            567: [.19444, .43056, 0, 0],
            710: U,
            711: [0, .62847, 0, 0],
            713: [0, .56778, 0, 0],
            714: U,
            715: U,
            728: U,
            729: [0, .66786, 0, 0],
            730: U,
            732: [0, .66786, 0, 0],
            733: U,
            915: ee,
            916: ee,
            920: ee,
            923: ee,
            926: ee,
            928: ee,
            931: ee,
            933: ee,
            934: ee,
            936: ee,
            937: ee,
            8211: [0, .43056, .02778, 0],
            8212: [0, .43056, .02778, 0],
            8216: U,
            8217: U,
            8220: U,
            8221: U,
            8224: Q,
            8225: Q,
            8230: [0, .12, 0, 0],
            8242: le,
            8407: [0, .71444, .15382, 0],
            8463: te,
            8465: U,
            8467: [0, .69444, 0, .11111],
            8472: [.19444, .43056, 0, .11111],
            8476: U,
            8501: U,
            8592: [-.13313, .36687, 0, 0],
            8593: Q,
            8594: [-.13313, .36687, 0, 0],
            8595: Q,
            8596: [-.13313, .36687, 0, 0],
            8597: G,
            8598: Q,
            8599: Q,
            8600: Q,
            8601: Q,
            8614: [.011, .511, 0, 0],
            8617: [.011, .511, 0, 0],
            8618: [.011, .511, 0, 0],
            8636: [-.13313, .36687, 0, 0],
            8637: [-.13313, .36687, 0, 0],
            8640: [-.13313, .36687, 0, 0],
            8641: [-.13313, .36687, 0, 0],
            8652: [.011, .671, 0, 0],
            8656: [-.13313, .36687, 0, 0],
            8657: Q,
            8658: [-.13313, .36687, 0, 0],
            8659: Q,
            8660: [-.13313, .36687, 0, 0],
            8661: G,
            8704: U,
            8706: [0, .69444, .05556, .08334],
            8707: U,
            8709: [.05556, .75, 0, 0],
            8711: ee,
            8712: [.0391, .5391, 0, 0],
            8715: [.0391, .5391, 0, 0],
            8722: [.08333, .58333, 0, 0],
            8723: [.08333, .58333, 0, 0],
            8725: G,
            8726: G,
            8727: [-.03472, .46528, 0, 0],
            8728: [-.05555, .44445, 0, 0],
            8729: [-.05555, .44445, 0, 0],
            8730: [.2, .8, 0, 0],
            8733: [0, .43056, 0, 0],
            8734: [0, .43056, 0, 0],
            8736: re,
            8739: G,
            8741: G,
            8743: le,
            8744: le,
            8745: le,
            8746: le,
            8747: [.19444, .69444, .11111, 0],
            8764: [-.13313, .36687, 0, 0],
            8768: Q,
            8771: [-.03625, .46375, 0, 0],
            8773: [-.022, .589, 0, 0],
            8776: [-.01688, .48312, 0, 0],
            8781: [-.03625, .46375, 0, 0],
            8784: [-.133, .67, 0, 0],
            8801: [-.03625, .46375, 0, 0],
            8804: [.13597, .63597, 0, 0],
            8805: [.13597, .63597, 0, 0],
            8810: [.0391, .5391, 0, 0],
            8811: [.0391, .5391, 0, 0],
            8826: [.0391, .5391, 0, 0],
            8827: [.0391, .5391, 0, 0],
            8834: [.0391, .5391, 0, 0],
            8835: [.0391, .5391, 0, 0],
            8838: [.13597, .63597, 0, 0],
            8839: [.13597, .63597, 0, 0],
            8846: le,
            8849: [.13597, .63597, 0, 0],
            8850: [.13597, .63597, 0, 0],
            8851: le,
            8852: le,
            8853: [.08333, .58333, 0, 0],
            8854: [.08333, .58333, 0, 0],
            8855: [.08333, .58333, 0, 0],
            8856: [.08333, .58333, 0, 0],
            8857: [.08333, .58333, 0, 0],
            8866: U,
            8867: U,
            8868: U,
            8869: U,
            8872: [.249, .75, 0, 0],
            8900: [-.05555, .44445, 0, 0],
            8901: [-.05555, .44445, 0, 0],
            8902: [-.03472, .46528, 0, 0],
            8904: [.005, .505, 0, 0],
            8942: [.03, .9, 0, 0],
            8943: [-.19, .31, 0, 0],
            8945: [-.1, .82, 0, 0],
            8968: G,
            8969: G,
            8970: G,
            8971: G,
            8994: [-.14236, .35764, 0, 0],
            8995: [-.14236, .35764, 0, 0],
            9136: [.244, .744, 0, 0],
            9137: [.244, .744, 0, 0],
            9651: Q,
            9657: [-.03472, .46528, 0, 0],
            9661: Q,
            9667: [-.03472, .46528, 0, 0],
            9711: Q,
            9824: [.12963, .69444, 0, 0],
            9825: [.12963, .69444, 0, 0],
            9826: [.12963, .69444, 0, 0],
            9827: [.12963, .69444, 0, 0],
            9837: pe,
            9838: Q,
            9839: Q,
            10216: G,
            10217: G,
            10222: [.244, .744, 0, 0],
            10223: [.244, .744, 0, 0],
            10229: [.011, .511, 0, 0],
            10230: [.011, .511, 0, 0],
            10231: [.011, .511, 0, 0],
            10232: [.024, .525, 0, 0],
            10233: [.024, .525, 0, 0],
            10234: [.024, .525, 0, 0],
            10236: [.011, .511, 0, 0],
            10815: ee,
            10927: [.13597, .63597, 0, 0],
            10928: [.13597, .63597, 0, 0],
            57376: Q
        },
        "Math-BoldItalic": {
            32: ie,
            48: Z,
            49: Z,
            50: Z,
            51: ne,
            52: ne,
            53: ne,
            54: oe,
            55: ne,
            56: oe,
            57: ne,
            65: Y,
            66: [0, .68611, .04835, 0],
            67: [0, .68611, .06979, 0],
            68: [0, .68611, .03194, 0],
            69: [0, .68611, .05451, 0],
            70: [0, .68611, .15972, 0],
            71: Y,
            72: [0, .68611, .08229, 0],
            73: [0, .68611, .07778, 0],
            74: [0, .68611, .10069, 0],
            75: [0, .68611, .06979, 0],
            76: Y,
            77: [0, .68611, .11424, 0],
            78: [0, .68611, .11424, 0],
            79: [0, .68611, .03194, 0],
            80: [0, .68611, .15972, 0],
            81: [.19444, .68611, 0, 0],
            82: [0, .68611, .00421, 0],
            83: [0, .68611, .05382, 0],
            84: [0, .68611, .15972, 0],
            85: [0, .68611, .11424, 0],
            86: [0, .68611, .25555, 0],
            87: [0, .68611, .15972, 0],
            88: [0, .68611, .07778, 0],
            89: [0, .68611, .25555, 0],
            90: [0, .68611, .06979, 0],
            97: Z,
            98: U,
            99: Z,
            100: U,
            101: Z,
            102: [.19444, .69444, .11042, 0],
            103: [.19444, .44444, .03704, 0],
            104: U,
            105: [0, .69326, 0, 0],
            106: [.19444, .69326, .0622, 0],
            107: [0, .69444, .01852, 0],
            108: [0, .69444, .0088, 0],
            109: Z,
            110: Z,
            111: Z,
            112: ne,
            113: [.19444, .44444, .03704, 0],
            114: [0, .44444, .03194, 0],
            115: Z,
            116: [0, .63492, 0, 0],
            117: Z,
            118: [0, .44444, .03704, 0],
            119: [0, .44444, .02778, 0],
            120: Z,
            121: [.19444, .44444, .03704, 0],
            122: [0, .44444, .04213, 0],
            160: ie,
            915: [0, .68611, .15972, 0],
            916: Y,
            920: [0, .68611, .03194, 0],
            923: Y,
            926: [0, .68611, .07458, 0],
            928: [0, .68611, .08229, 0],
            931: [0, .68611, .05451, 0],
            933: [0, .68611, .15972, 0],
            934: Y,
            936: [0, .68611, .11653, 0],
            937: [0, .68611, .04835, 0],
            945: Z,
            946: [.19444, .69444, .03403, 0],
            947: [.19444, .44444, .06389, 0],
            948: [0, .69444, .03819, 0],
            949: Z,
            950: [.19444, .69444, .06215, 0],
            951: [.19444, .44444, .03704, 0],
            952: [0, .69444, .03194, 0],
            953: Z,
            954: Z,
            955: U,
            956: ne,
            957: [0, .44444, .06898, 0],
            958: [.19444, .69444, .03021, 0],
            959: Z,
            960: [0, .44444, .03704, 0],
            961: ne,
            962: [.09722, .44444, .07917, 0],
            963: [0, .44444, .03704, 0],
            964: [0, .44444, .13472, 0],
            965: [0, .44444, .03704, 0],
            966: ne,
            967: ne,
            968: [.19444, .69444, .03704, 0],
            969: [0, .44444, .03704, 0],
            977: U,
            981: Q,
            982: [0, .44444, .03194, 0],
            1009: ne,
            1013: Z,
            57649: Z,
            57911: ne
        },
        "Math-Italic": {
            32: ie,
            48: [0, .43056, 0, 0],
            49: [0, .43056, 0, 0],
            50: [0, .43056, 0, 0],
            51: [.19444, .43056, 0, 0],
            52: [.19444, .43056, 0, 0],
            53: [.19444, .43056, 0, 0],
            54: oe,
            55: [.19444, .43056, 0, 0],
            56: oe,
            57: [.19444, .43056, 0, 0],
            65: [0, .68333, 0, .13889],
            66: [0, .68333, .05017, .08334],
            67: [0, .68333, .07153, .08334],
            68: [0, .68333, .02778, .05556],
            69: [0, .68333, .05764, .08334],
            70: [0, .68333, .13889, .08334],
            71: [0, .68333, 0, .08334],
            72: [0, .68333, .08125, .05556],
            73: [0, .68333, .07847, .11111],
            74: [0, .68333, .09618, .16667],
            75: [0, .68333, .07153, .05556],
            76: [0, .68333, 0, .02778],
            77: [0, .68333, .10903, .08334],
            78: [0, .68333, .10903, .08334],
            79: [0, .68333, .02778, .08334],
            80: [0, .68333, .13889, .08334],
            81: [.19444, .68333, 0, .08334],
            82: [0, .68333, .00773, .08334],
            83: [0, .68333, .05764, .08334],
            84: [0, .68333, .13889, .08334],
            85: [0, .68333, .10903, .02778],
            86: [0, .68333, .22222, 0],
            87: [0, .68333, .13889, 0],
            88: [0, .68333, .07847, .08334],
            89: [0, .68333, .22222, 0],
            90: [0, .68333, .07153, .08334],
            97: [0, .43056, 0, 0],
            98: U,
            99: [0, .43056, 0, .05556],
            100: [0, .69444, 0, .16667],
            101: [0, .43056, 0, .05556],
            102: [.19444, .69444, .10764, .16667],
            103: [.19444, .43056, .03588, .02778],
            104: U,
            105: [0, .65952, 0, 0],
            106: [.19444, .65952, .05724, 0],
            107: [0, .69444, .03148, 0],
            108: [0, .69444, .01968, .08334],
            109: [0, .43056, 0, 0],
            110: [0, .43056, 0, 0],
            111: [0, .43056, 0, .05556],
            112: [.19444, .43056, 0, .08334],
            113: [.19444, .43056, .03588, .08334],
            114: [0, .43056, .02778, .05556],
            115: [0, .43056, 0, .05556],
            116: [0, .61508, 0, .08334],
            117: [0, .43056, 0, .02778],
            118: [0, .43056, .03588, .02778],
            119: [0, .43056, .02691, .08334],
            120: [0, .43056, 0, .02778],
            121: [.19444, .43056, .03588, .05556],
            122: [0, .43056, .04398, .05556],
            160: ie,
            915: [0, .68333, .13889, .08334],
            916: [0, .68333, 0, .16667],
            920: [0, .68333, .02778, .08334],
            923: [0, .68333, 0, .16667],
            926: [0, .68333, .07569, .08334],
            928: [0, .68333, .08125, .05556],
            931: [0, .68333, .05764, .08334],
            933: [0, .68333, .13889, .05556],
            934: [0, .68333, 0, .08334],
            936: [0, .68333, .11, .05556],
            937: [0, .68333, .05017, .08334],
            945: [0, .43056, .0037, .02778],
            946: [.19444, .69444, .05278, .08334],
            947: [.19444, .43056, .05556, 0],
            948: [0, .69444, .03785, .05556],
            949: [0, .43056, 0, .08334],
            950: [.19444, .69444, .07378, .08334],
            951: [.19444, .43056, .03588, .05556],
            952: [0, .69444, .02778, .08334],
            953: [0, .43056, 0, .05556],
            954: [0, .43056, 0, 0],
            955: U,
            956: [.19444, .43056, 0, .02778],
            957: [0, .43056, .06366, .02778],
            958: [.19444, .69444, .04601, .11111],
            959: [0, .43056, 0, .05556],
            960: [0, .43056, .03588, 0],
            961: [.19444, .43056, 0, .08334],
            962: [.09722, .43056, .07986, .08334],
            963: [0, .43056, .03588, 0],
            964: [0, .43056, .1132, .02778],
            965: [0, .43056, .03588, .02778],
            966: [.19444, .43056, 0, .08334],
            967: [.19444, .43056, 0, .05556],
            968: [.19444, .69444, .03588, .11111],
            969: [0, .43056, .03588, 0],
            977: [0, .69444, 0, .08334],
            981: [.19444, .69444, 0, .08334],
            982: [0, .43056, .02778, 0],
            1009: [.19444, .43056, 0, .08334],
            1013: [0, .43056, 0, .05556],
            57649: [0, .43056, 0, .02778],
            57911: [.19444, .43056, 0, .08334]
        },
        "SansSerif-Bold": {
            32: ie,
            33: U,
            34: U,
            35: Q,
            36: [.05556, .75, 0, 0],
            37: [.05556, .75, 0, 0],
            38: U,
            39: U,
            40: G,
            41: G,
            42: pe,
            43: [.11667, .61667, 0, 0],
            44: [.10556, .13056, 0, 0],
            45: [0, .45833, 0, 0],
            46: [0, .13056, 0, 0],
            47: G,
            48: U,
            49: U,
            50: U,
            51: U,
            52: U,
            53: U,
            54: U,
            55: U,
            56: U,
            57: U,
            58: [0, .45833, 0, 0],
            59: [.10556, .45833, 0, 0],
            61: [-.09375, .40625, 0, 0],
            63: U,
            64: U,
            65: U,
            66: U,
            67: U,
            68: U,
            69: U,
            70: U,
            71: U,
            72: U,
            73: U,
            74: U,
            75: U,
            76: U,
            77: U,
            78: U,
            79: U,
            80: U,
            81: [.10556, .69444, 0, 0],
            82: U,
            83: U,
            84: U,
            85: U,
            86: [0, .69444, .01528, 0],
            87: [0, .69444, .01528, 0],
            88: U,
            89: [0, .69444, .0275, 0],
            90: U,
            91: G,
            93: G,
            94: U,
            95: [.35, .10833, .03056, 0],
            97: [0, .45833, 0, 0],
            98: U,
            99: [0, .45833, 0, 0],
            100: U,
            101: [0, .45833, 0, 0],
            102: [0, .69444, .07639, 0],
            103: [.19444, .45833, .01528, 0],
            104: U,
            105: U,
            106: Q,
            107: U,
            108: U,
            109: [0, .45833, 0, 0],
            110: [0, .45833, 0, 0],
            111: [0, .45833, 0, 0],
            112: [.19444, .45833, 0, 0],
            113: [.19444, .45833, 0, 0],
            114: [0, .45833, .01528, 0],
            115: [0, .45833, 0, 0],
            116: [0, .58929, 0, 0],
            117: [0, .45833, 0, 0],
            118: [0, .45833, .01528, 0],
            119: [0, .45833, .01528, 0],
            120: [0, .45833, 0, 0],
            121: [.19444, .45833, .01528, 0],
            122: [0, .45833, 0, 0],
            126: [.35, .34444, 0, 0],
            160: ie,
            168: U,
            176: U,
            180: U,
            184: [.17014, 0, 0, 0],
            305: [0, .45833, 0, 0],
            567: [.19444, .45833, 0, 0],
            710: U,
            711: [0, .63542, 0, 0],
            713: [0, .63778, 0, 0],
            728: U,
            729: U,
            730: U,
            732: U,
            733: U,
            915: U,
            916: U,
            920: U,
            923: U,
            926: U,
            928: U,
            931: U,
            933: U,
            934: U,
            936: U,
            937: U,
            8211: [0, .45833, .03056, 0],
            8212: [0, .45833, .03056, 0],
            8216: U,
            8217: U,
            8220: U,
            8221: U
        },
        "SansSerif-Italic": {
            32: ie,
            33: [0, .69444, .05733, 0],
            34: [0, .69444, .00316, 0],
            35: [.19444, .69444, .05087, 0],
            36: [.05556, .75, .11156, 0],
            37: [.05556, .75, .03126, 0],
            38: [0, .69444, .03058, 0],
            39: [0, .69444, .07816, 0],
            40: [.25, .75, .13164, 0],
            41: [.25, .75, .02536, 0],
            42: [0, .75, .11775, 0],
            43: [.08333, .58333, .02536, 0],
            44: [.125, .08333, 0, 0],
            45: [0, .44444, .01946, 0],
            46: [0, .08333, 0, 0],
            47: [.25, .75, .13164, 0],
            48: [0, .65556, .11156, 0],
            49: [0, .65556, .11156, 0],
            50: [0, .65556, .11156, 0],
            51: [0, .65556, .11156, 0],
            52: [0, .65556, .11156, 0],
            53: [0, .65556, .11156, 0],
            54: [0, .65556, .11156, 0],
            55: [0, .65556, .11156, 0],
            56: [0, .65556, .11156, 0],
            57: [0, .65556, .11156, 0],
            58: [0, .44444, .02502, 0],
            59: [.125, .44444, .02502, 0],
            61: [-.13, .37, .05087, 0],
            63: [0, .69444, .11809, 0],
            64: [0, .69444, .07555, 0],
            65: U,
            66: [0, .69444, .08293, 0],
            67: [0, .69444, .11983, 0],
            68: [0, .69444, .07555, 0],
            69: [0, .69444, .11983, 0],
            70: [0, .69444, .13372, 0],
            71: [0, .69444, .11983, 0],
            72: [0, .69444, .08094, 0],
            73: [0, .69444, .13372, 0],
            74: [0, .69444, .08094, 0],
            75: [0, .69444, .11983, 0],
            76: U,
            77: [0, .69444, .08094, 0],
            78: [0, .69444, .08094, 0],
            79: [0, .69444, .07555, 0],
            80: [0, .69444, .08293, 0],
            81: [.125, .69444, .07555, 0],
            82: [0, .69444, .08293, 0],
            83: [0, .69444, .09205, 0],
            84: [0, .69444, .13372, 0],
            85: [0, .69444, .08094, 0],
            86: [0, .69444, .1615, 0],
            87: [0, .69444, .1615, 0],
            88: [0, .69444, .13372, 0],
            89: [0, .69444, .17261, 0],
            90: [0, .69444, .11983, 0],
            91: [.25, .75, .15942, 0],
            93: [.25, .75, .08719, 0],
            94: [0, .69444, .0799, 0],
            95: [.35, .09444, .08616, 0],
            97: [0, .44444, .00981, 0],
            98: [0, .69444, .03057, 0],
            99: [0, .44444, .08336, 0],
            100: [0, .69444, .09483, 0],
            101: [0, .44444, .06778, 0],
            102: [0, .69444, .21705, 0],
            103: [.19444, .44444, .10836, 0],
            104: [0, .69444, .01778, 0],
            105: [0, .67937, .09718, 0],
            106: [.19444, .67937, .09162, 0],
            107: [0, .69444, .08336, 0],
            108: [0, .69444, .09483, 0],
            109: [0, .44444, .01778, 0],
            110: [0, .44444, .01778, 0],
            111: [0, .44444, .06613, 0],
            112: [.19444, .44444, .0389, 0],
            113: [.19444, .44444, .04169, 0],
            114: [0, .44444, .10836, 0],
            115: [0, .44444, .0778, 0],
            116: [0, .57143, .07225, 0],
            117: [0, .44444, .04169, 0],
            118: [0, .44444, .10836, 0],
            119: [0, .44444, .10836, 0],
            120: [0, .44444, .09169, 0],
            121: [.19444, .44444, .10836, 0],
            122: [0, .44444, .08752, 0],
            126: [.35, .32659, .08826, 0],
            160: ie,
            168: [0, .67937, .06385, 0],
            176: U,
            184: [.17014, 0, 0, 0],
            305: [0, .44444, .04169, 0],
            567: [.19444, .44444, .04169, 0],
            710: [0, .69444, .0799, 0],
            711: [0, .63194, .08432, 0],
            713: [0, .60889, .08776, 0],
            714: [0, .69444, .09205, 0],
            715: U,
            728: [0, .69444, .09483, 0],
            729: [0, .67937, .07774, 0],
            730: U,
            732: [0, .67659, .08826, 0],
            733: [0, .69444, .09205, 0],
            915: [0, .69444, .13372, 0],
            916: U,
            920: [0, .69444, .07555, 0],
            923: U,
            926: [0, .69444, .12816, 0],
            928: [0, .69444, .08094, 0],
            931: [0, .69444, .11983, 0],
            933: [0, .69444, .09031, 0],
            934: [0, .69444, .04603, 0],
            936: [0, .69444, .09031, 0],
            937: [0, .69444, .08293, 0],
            8211: [0, .44444, .08616, 0],
            8212: [0, .44444, .08616, 0],
            8216: [0, .69444, .07816, 0],
            8217: [0, .69444, .07816, 0],
            8220: [0, .69444, .14205, 0],
            8221: [0, .69444, .00316, 0]
        },
        "SansSerif-Regular": {
            32: ie,
            33: U,
            34: U,
            35: Q,
            36: [.05556, .75, 0, 0],
            37: [.05556, .75, 0, 0],
            38: U,
            39: U,
            40: G,
            41: G,
            42: pe,
            43: [.08333, .58333, 0, 0],
            44: [.125, .08333, 0, 0],
            45: Z,
            46: [0, .08333, 0, 0],
            47: G,
            48: [0, .65556, 0, 0],
            49: [0, .65556, 0, 0],
            50: [0, .65556, 0, 0],
            51: [0, .65556, 0, 0],
            52: [0, .65556, 0, 0],
            53: [0, .65556, 0, 0],
            54: [0, .65556, 0, 0],
            55: [0, .65556, 0, 0],
            56: [0, .65556, 0, 0],
            57: [0, .65556, 0, 0],
            58: Z,
            59: [.125, .44444, 0, 0],
            61: [-.13, .37, 0, 0],
            63: U,
            64: U,
            65: U,
            66: U,
            67: U,
            68: U,
            69: U,
            70: U,
            71: U,
            72: U,
            73: U,
            74: U,
            75: U,
            76: U,
            77: U,
            78: U,
            79: U,
            80: U,
            81: [.125, .69444, 0, 0],
            82: U,
            83: U,
            84: U,
            85: U,
            86: [0, .69444, .01389, 0],
            87: [0, .69444, .01389, 0],
            88: U,
            89: [0, .69444, .025, 0],
            90: U,
            91: G,
            93: G,
            94: U,
            95: [.35, .09444, .02778, 0],
            97: Z,
            98: U,
            99: Z,
            100: U,
            101: Z,
            102: [0, .69444, .06944, 0],
            103: [.19444, .44444, .01389, 0],
            104: U,
            105: [0, .67937, 0, 0],
            106: [.19444, .67937, 0, 0],
            107: U,
            108: U,
            109: Z,
            110: Z,
            111: Z,
            112: ne,
            113: ne,
            114: [0, .44444, .01389, 0],
            115: Z,
            116: [0, .57143, 0, 0],
            117: Z,
            118: [0, .44444, .01389, 0],
            119: [0, .44444, .01389, 0],
            120: Z,
            121: [.19444, .44444, .01389, 0],
            122: Z,
            126: [.35, .32659, 0, 0],
            160: ie,
            168: [0, .67937, 0, 0],
            176: U,
            184: [.17014, 0, 0, 0],
            305: Z,
            567: ne,
            710: U,
            711: [0, .63194, 0, 0],
            713: [0, .60889, 0, 0],
            714: U,
            715: U,
            728: U,
            729: [0, .67937, 0, 0],
            730: U,
            732: [0, .67659, 0, 0],
            733: U,
            915: U,
            916: U,
            920: U,
            923: U,
            926: U,
            928: U,
            931: U,
            933: U,
            934: U,
            936: U,
            937: U,
            8211: [0, .44444, .02778, 0],
            8212: [0, .44444, .02778, 0],
            8216: U,
            8217: U,
            8220: U,
            8221: U
        },
        "Script-Regular": {
            32: ie,
            65: [0, .7, .22925, 0],
            66: [0, .7, .04087, 0],
            67: [0, .7, .1689, 0],
            68: [0, .7, .09371, 0],
            69: [0, .7, .18583, 0],
            70: [0, .7, .13634, 0],
            71: [0, .7, .17322, 0],
            72: [0, .7, .29694, 0],
            73: [0, .7, .19189, 0],
            74: [.27778, .7, .19189, 0],
            75: [0, .7, .31259, 0],
            76: [0, .7, .19189, 0],
            77: [0, .7, .15981, 0],
            78: [0, .7, .3525, 0],
            79: [0, .7, .08078, 0],
            80: [0, .7, .08078, 0],
            81: [0, .7, .03305, 0],
            82: [0, .7, .06259, 0],
            83: [0, .7, .19189, 0],
            84: [0, .7, .29087, 0],
            85: [0, .7, .25815, 0],
            86: [0, .7, .27523, 0],
            87: [0, .7, .27523, 0],
            88: [0, .7, .26006, 0],
            89: [0, .7, .2939, 0],
            90: [0, .7, .24037, 0],
            160: ie
        },
        "Size1-Regular": {
            32: ie,
            40: de,
            41: de,
            47: de,
            91: de,
            92: de,
            93: de,
            123: de,
            125: de,
            160: ie,
            710: [0, .72222, 0, 0],
            732: [0, .72222, 0, 0],
            770: [0, .72222, 0, 0],
            771: [0, .72222, 0, 0],
            8214: [-99e-5, .601, 0, 0],
            8593: [1e-5, .6, 0, 0],
            8595: [1e-5, .6, 0, 0],
            8657: [1e-5, .6, 0, 0],
            8659: [1e-5, .6, 0, 0],
            8719: me,
            8720: me,
            8721: me,
            8730: de,
            8739: [-.00599, .606, 0, 0],
            8741: [-.00599, .606, 0, 0],
            8747: [.30612, .805, .19445, 0],
            8748: [.306, .805, .19445, 0],
            8749: [.306, .805, .19445, 0],
            8750: [.30612, .805, .19445, 0],
            8896: me,
            8897: me,
            8898: me,
            8899: me,
            8968: de,
            8969: de,
            8970: de,
            8971: de,
            9168: [-99e-5, .601, 0, 0],
            10216: de,
            10217: de,
            10752: me,
            10753: me,
            10754: me,
            10756: me,
            10758: me
        },
        "Size2-Regular": {
            32: ie,
            40: se,
            41: se,
            47: se,
            91: se,
            92: se,
            93: se,
            123: se,
            125: se,
            160: ie,
            710: pe,
            732: pe,
            770: pe,
            771: pe,
            8719: fe,
            8720: fe,
            8721: fe,
            8730: se,
            8747: [.86225, 1.36, .44445, 0],
            8748: [.862, 1.36, .44445, 0],
            8749: [.862, 1.36, .44445, 0],
            8750: [.86225, 1.36, .44445, 0],
            8896: fe,
            8897: fe,
            8898: fe,
            8899: fe,
            8968: se,
            8969: se,
            8970: se,
            8971: se,
            10216: se,
            10217: se,
            10752: fe,
            10753: fe,
            10754: fe,
            10756: fe,
            10758: fe
        },
        "Size3-Regular": {
            32: ie,
            40: ue,
            41: ue,
            47: ue,
            91: ue,
            92: ue,
            93: ue,
            123: ue,
            125: ue,
            160: ie,
            710: pe,
            732: pe,
            770: pe,
            771: pe,
            8730: ue,
            8968: ue,
            8969: ue,
            8970: ue,
            8971: ue,
            10216: ue,
            10217: ue
        },
        "Size4-Regular": {
            32: ie,
            40: ce,
            41: ce,
            47: ce,
            91: ce,
            92: ce,
            93: ce,
            123: ce,
            125: ce,
            160: ie,
            710: [0, .825, 0, 0],
            732: [0, .825, 0, 0],
            770: [0, .825, 0, 0],
            771: [0, .825, 0, 0],
            8730: ce,
            8968: ce,
            8969: ce,
            8970: ce,
            8971: ce,
            9115: [.64502, 1.155, 0, 0],
            9116: [1e-5, .6, 0, 0],
            9117: [.64502, 1.155, 0, 0],
            9118: [.64502, 1.155, 0, 0],
            9119: [1e-5, .6, 0, 0],
            9120: [.64502, 1.155, 0, 0],
            9121: [.64502, 1.155, 0, 0],
            9122: [-99e-5, .601, 0, 0],
            9123: [.64502, 1.155, 0, 0],
            9124: [.64502, 1.155, 0, 0],
            9125: [-99e-5, .601, 0, 0],
            9126: [.64502, 1.155, 0, 0],
            9127: [1e-5, .9, 0, 0],
            9128: se,
            9129: [.90001, 0, 0, 0],
            9130: [0, .3, 0, 0],
            9131: [1e-5, .9, 0, 0],
            9132: se,
            9133: [.90001, 0, 0, 0],
            9143: [.88502, .915, 0, 0],
            10216: ce,
            10217: ce,
            57344: [-.00499, .605, 0, 0],
            57345: [-.00499, .605, 0, 0],
            57680: [0, .12, 0, 0],
            57681: [0, .12, 0, 0],
            57682: [0, .12, 0, 0],
            57683: [0, .12, 0, 0]
        },
        "Typewriter-Regular": {
            32: ie,
            33: X,
            34: X,
            35: X,
            36: [.08333, .69444, 0, 0],
            37: [.08333, .69444, 0, 0],
            38: X,
            39: X,
            40: [.08333, .69444, 0, 0],
            41: [.08333, .69444, 0, 0],
            42: [0, .52083, 0, 0],
            43: [-.08056, .53055, 0, 0],
            44: [.13889, .125, 0, 0],
            45: [-.08056, .53055, 0, 0],
            46: [0, .125, 0, 0],
            47: [.08333, .69444, 0, 0],
            48: X,
            49: X,
            50: X,
            51: X,
            52: X,
            53: X,
            54: X,
            55: X,
            56: X,
            57: X,
            58: [0, .43056, 0, 0],
            59: [.13889, .43056, 0, 0],
            60: [-.05556, .55556, 0, 0],
            61: [-.19549, .41562, 0, 0],
            62: [-.05556, .55556, 0, 0],
            63: X,
            64: X,
            65: X,
            66: X,
            67: X,
            68: X,
            69: X,
            70: X,
            71: X,
            72: X,
            73: X,
            74: X,
            75: X,
            76: X,
            77: X,
            78: X,
            79: X,
            80: X,
            81: [.13889, .61111, 0, 0],
            82: X,
            83: X,
            84: X,
            85: X,
            86: X,
            87: X,
            88: X,
            89: X,
            90: X,
            91: [.08333, .69444, 0, 0],
            92: [.08333, .69444, 0, 0],
            93: [.08333, .69444, 0, 0],
            94: X,
            95: [.09514, 0, 0, 0],
            96: X,
            97: [0, .43056, 0, 0],
            98: X,
            99: [0, .43056, 0, 0],
            100: X,
            101: [0, .43056, 0, 0],
            102: X,
            103: [.22222, .43056, 0, 0],
            104: X,
            105: X,
            106: [.22222, .61111, 0, 0],
            107: X,
            108: X,
            109: [0, .43056, 0, 0],
            110: [0, .43056, 0, 0],
            111: [0, .43056, 0, 0],
            112: [.22222, .43056, 0, 0],
            113: [.22222, .43056, 0, 0],
            114: [0, .43056, 0, 0],
            115: [0, .43056, 0, 0],
            116: [0, .55358, 0, 0],
            117: [0, .43056, 0, 0],
            118: [0, .43056, 0, 0],
            119: [0, .43056, 0, 0],
            120: [0, .43056, 0, 0],
            121: [.22222, .43056, 0, 0],
            122: [0, .43056, 0, 0],
            123: [.08333, .69444, 0, 0],
            124: [.08333, .69444, 0, 0],
            125: [.08333, .69444, 0, 0],
            126: X,
            127: X,
            160: ie,
            176: X,
            184: [.19445, 0, 0, 0],
            305: [0, .43056, 0, 0],
            567: [.22222, .43056, 0, 0],
            711: [0, .56597, 0, 0],
            713: [0, .56555, 0, 0],
            714: X,
            715: X,
            728: X,
            730: X,
            770: X,
            771: X,
            776: X,
            915: X,
            916: X,
            920: X,
            923: X,
            926: X,
            928: X,
            931: X,
            933: X,
            934: X,
            936: X,
            937: X,
            8216: X,
            8217: X,
            8242: X,
            9251: [.11111, .21944, 0, 0]
        }
    };
    const ve = /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/,
        ke = {
            slant: [.25, .25, .25],
            space: [0, 0, 0],
            stretch: [0, 0, 0],
            shrink: [0, 0, 0],
            xHeight: [.431, .431, .431],
            quad: [1, 1.171, 1.472],
            extraSpace: [0, 0, 0],
            num1: [.677, .732, .925],
            num2: [.394, .384, .387],
            num3: [.444, .471, .504],
            denom1: [.686, .752, 1.025],
            denom2: [.345, .344, .532],
            sup1: [.413, .503, .504],
            sup2: [.363, .431, .404],
            sup3: [.289, .286, .294],
            sub1: [.15, .143, .2],
            sub2: [.247, .286, .4],
            supDrop: [.386, .353, .494],
            subDrop: [.05, .071, .1],
            delim1: [2.39, 1.7, 1.98],
            delim2: [1.01, 1.157, 1.42],
            axisHeight: [.25, .25, .25],
            defaultRuleThickness: [.04, .049, .049],
            bigOpSpacing1: [.111, .111, .111],
            bigOpSpacing2: [.166, .166, .166],
            bigOpSpacing3: [.2, .2, .2],
            bigOpSpacing4: [.6, .611, .611],
            bigOpSpacing5: [.1, .143, .143],
            sqrtRuleThickness: [.04, .04, .04]
        },
        xe = [0, .5, .7, .8, .9, 1, 1.2, 1.44, 1.728, 2.074, 2.488],
        we = {
            " ": " ",
            "​": " ",
            "Å": "A",
            "Ç": "C",
            "Ð": "D",
            "Þ": "o",
            "å": "a",
            "ç": "c",
            "ð": "d",
            "þ": "o",
            "А": "A",
            "Б": "B",
            "В": "B",
            "Г": "F",
            "Д": "A",
            "Е": "E",
            "Ж": "K",
            "З": "3",
            "И": "N",
            "Й": "N",
            "К": "K",
            "Л": "N",
            "М": "M",
            "Н": "H",
            "О": "O",
            "П": "N",
            "Р": "P",
            "С": "C",
            "Т": "T",
            "У": "y",
            "Ф": "O",
            "Х": "X",
            "Ц": "U",
            "Ч": "h",
            "Ш": "W",
            "Щ": "W",
            "Ъ": "B",
            "Ы": "X",
            "Ь": "B",
            "Э": "3",
            "Ю": "X",
            "Я": "R",
            "а": "a",
            "б": "b",
            "в": "a",
            "г": "r",
            "д": "y",
            "е": "e",
            "ж": "m",
            "з": "e",
            "и": "n",
            "й": "n",
            "к": "n",
            "л": "n",
            "м": "m",
            "н": "n",
            "о": "o",
            "п": "n",
            "р": "p",
            "с": "c",
            "т": "o",
            "у": "y",
            "ф": "b",
            "х": "x",
            "ц": "n",
            "ч": "n",
            "ш": "w",
            "щ": "w",
            "ъ": "a",
            "ы": "m",
            "ь": "a",
            "э": "e",
            "ю": "m",
            "я": "r"
        };

    function _e(e, t) {
        void 0 === e && (e = 77);
        const a = ge[t][e];
        if (a) return {
            defaultMetrics: !1,
            depth: a[0],
            height: a[1],
            italic: a[2],
            skew: a[3]
        };
        if (11034 === e) return {
            defaultMetrics: !0,
            depth: .2,
            height: .8,
            italic: 0,
            skew: 0
        };
        const i = String.fromCodePoint(e);
        if (i in we) e = we[i].codePointAt(0);
        else if (ve.test(i)) return e = 77, {
            defaultMetrics: !0,
            depth: .2,
            height: .9,
            italic: 0,
            skew: 0
        };
        return {
            defaultMetrics: !0,
            depth: .2,
            height: .7,
            italic: 0,
            skew: 0
        }
    }
    class Se {
        getFontSize(e) {
            return Math.max(1, e + this.sizeDelta)
        }
        get sup() {
            return Me[[0, 1, 0, 1, 2, 3, 2, 3][this.id]]
        }
        get sub() {
            return Me[[0, 0, 0, 0, 2, 2, 2, 2][this.id]]
        }
        get fracNum() {
            return Me[[0, 1, 0, 1, 2, 3, 4, 5][this.id]]
        }
        get fracDen() {
            return Me[[0, 0, 0, 0, 2, 2, 4, 4][this.id]]
        }
        get cramp() {
            return Me[[0, 0, 2, 2, 4, 4, 6, 6][this.id]]
        }
        get isTight() {
            return this.sizeDelta < 0
        }
        constructor(e, t, a) {
            this.id = e, this.sizeDelta = t, this.cramped = a;
            const i = {
                "-4": 2,
                "-3": 1,
                0: 0
            } [t];
            this.metrics = Object.keys(ke).reduce(((e, t) => ({
                ...e,
                [t]: ke[t][i]
            })), {})
        }
    }
    const Me = {
        7: new Se(7, 0, !1),
        6: new Se(6, 0, !0),
        5: new Se(5, 0, !1),
        4: new Se(4, 0, !0),
        3: new Se(3, -3, !1),
        2: new Se(2, -3, !0),
        1: new Se(1, -4, !1),
        0: new Se(0, -4, !0)
    };

    function Le(e, t) {
        return null === e ? 0 : function(e, t) {
            var a;
            if (!e) return 0;
            const i = {
                pt: 1,
                mm: 7227 / 2540,
                cm: 7227 / 254,
                ex: 35271 / 8192,
                px: 3 / 4,
                em: 10,
                bp: 1.00375,
                dd: 1238 / 1157,
                pc: 12,
                in: 72.27,
                mu: 10 / 18
            } [null !== (a = e.unit) && void 0 !== a ? a : "pt"];
            if (Number.isFinite(t)) {
                const a = 10 ** t;
                return Math.round(e.dimension / 10 * i * a) / a
            }
            return e.dimension * i
        }(e, t) / 10
    }

    function Ce(e) {
        var t;
        return `${e.dimension}${null!==(t=e.unit)&&void 0!==t?t:"pt"}`
    }
    Me.displaystyle = Me[7], Me.textstyle = Me[5], Me.scriptstyle = Me[3], Me.scriptscriptstyle = Me[1];
    class Ae {
        get mathstyle() {
            let e = this._mathstyle,
                t = this.parent;
            for (; !e;) e = t._mathstyle, t = t.parent;
            return e
        }
        getRegister(e) {
            var t;
            return (null === (t = this.registers) || void 0 === t ? void 0 : t[e]) ? this.registers[e] : this.parent ? this.parent.getRegister(e) : void 0
        }
        getRegisterAsGlue(e) {
            var t;
            if (null === (t = this.registers) || void 0 === t ? void 0 : t[e]) {
                const t = this.registers[e];
                return "object" == typeof t && "glue" in t ? t : "object" == typeof t && "dimension" in t ? {
                    glue: {
                        dimension: t.dimension
                    }
                } : "number" == typeof t ? {
                    glue: {
                        dimension: t
                    }
                } : void 0
            }
            if (this.parent) return this.parent.getRegisterAsGlue(e)
        }
        getRegisterAsEm(e) {
            return Le(this.getRegisterAsDimension(e))
        }
        getRegisterAsDimension(e) {
            var t;
            if (null === (t = this.registers) || void 0 === t ? void 0 : t[e]) {
                const t = this.registers[e];
                return "object" == typeof t && "glue" in t ? t.glue : "object" == typeof t && "dimension" in t ? t : "number" == typeof t ? {
                    dimension: t
                } : void 0
            }
            if (this.parent) return this.parent.getRegisterAsDimension(e)
        }
        setRegister(e, t) {
            void 0 !== t ? this.registers[e] = t : delete this.registers[e]
        }
        setGlobalRegister(e, t) {
            let a = this;
            for (; a.parent;) a.setRegister(e, void 0), a = a.parent;
            a.setRegister(e, t)
        }
        get size() {
            let e = this._size,
                t = this.parent;
            for (; !e;) e = t._size, t = t.parent;
            return e
        }
        makeID() {
            if (!this.atomIdsSettings) return;
            if (this.atomIdsSettings.overrideID) return this.atomIdsSettings.overrideID;
            if ("number" != typeof this.atomIdsSettings.seed) return Date.now().toString(36).slice(-2) + Math.floor(1e5 * Math.random()).toString(36);
            const e = this.atomIdsSettings.seed.toString(36);
            return this.atomIdsSettings.seed += 1, e
        }
        scale(e) {
            return e * this.effectiveFontSize
        }
        get scalingFactor() {
            return this.parent ? this.effectiveFontSize / this.parent.effectiveFontSize : 1
        }
        get isDisplayStyle() {
            return 7 === this.mathstyle.id || 6 === this.mathstyle.id
        }
        get isCramped() {
            return this.mathstyle.cramped
        }
        get isTight() {
            return this.mathstyle.isTight
        }
        get effectiveFontSize() {
            return xe[Math.max(1, this.size + this.mathstyle.sizeDelta)]
        }
        get computedColor() {
            let e = this.color,
                t = this.parent;
            return !e && t && (e = t.color, t = t.parent), null != e ? e : ""
        }
        get computedBackgroundColor() {
            let e = this.backgroundColor,
                t = this.parent;
            return !e && t && (e = t.backgroundColor, t = t.parent), null != e ? e : ""
        }
        get metrics() {
            return this.mathstyle.metrics
        }
        constructor(e, t, a) {
            var i, o, r, n, s, l;
            e instanceof Ae && (this.parent = e), e instanceof Ae || (this.registers = null !== (i = e.registers) && void 0 !== i ? i : {}), this.isPhantom = null !== (n = null !== (o = null == t ? void 0 : t.isPhantom) && void 0 !== o ? o : null === (r = this.parent) || void 0 === r ? void 0 : r.isPhantom) && void 0 !== n && n;
            const d = {
                ...e
            };
            let c;
            if (t && (t.letterShapeStyle && "auto" !== t.letterShapeStyle && (d.letterShapeStyle = t.letterShapeStyle), t.color && "none" !== t.color && (d.color = t.color), t.backgroundColor && "none" !== t.backgroundColor && (d.backgroundColor = t.backgroundColor), t.fontSize && "auto" !== t.fontSize && t.fontSize !== (null === (s = this.parent) || void 0 === s ? void 0 : s._size) && (this._size = t.fontSize)), this.letterShapeStyle = null !== (l = d.letterShapeStyle) && void 0 !== l ? l : "tex", this.color = d.color, this.backgroundColor = d.backgroundColor, "string" == typeof a) {
                if (e instanceof Ae) switch (a) {
                    case "cramp":
                        c = e.mathstyle.cramp;
                        break;
                    case "superscript":
                        c = e.mathstyle.sup;
                        break;
                    case "subscript":
                        c = e.mathstyle.sub;
                        break;
                    case "numerator":
                        c = e.mathstyle.fracNum;
                        break;
                    case "denominator":
                        c = e.mathstyle.fracDen
                }
                switch (a) {
                    case "textstyle":
                        c = Me.textstyle;
                        break;
                    case "displaystyle":
                        c = Me.displaystyle;
                        break;
                    case "scriptstyle":
                        c = Me.scriptstyle;
                        break;
                    case "scriptscriptstyle":
                        c = Me.scriptscriptstyle
                }
            }
            this._mathstyle = c, this.atomIdsSettings = e.atomIdsSettings, this.renderPlaceholder = d.renderPlaceholder
        }
    }
    const De = {
            overrightarrow: [
                ["rightarrow"], .888, 522, "xMaxYMin"
            ],
            overleftarrow: [
                ["leftarrow"], .888, 522, "xMinYMin"
            ],
            underrightarrow: [
                ["rightarrow"], .888, 522, "xMaxYMin"
            ],
            underleftarrow: [
                ["leftarrow"], .888, 522, "xMinYMin"
            ],
            xrightarrow: [
                ["rightarrow"], 1.469, 522, "xMaxYMin"
            ],
            xleftarrow: [
                ["leftarrow"], 1.469, 522, "xMinYMin"
            ],
            Overrightarrow: [
                ["doublerightarrow"], .888, 560, "xMaxYMin"
            ],
            xRightarrow: [
                ["doublerightarrow"], 1.526, 560, "xMaxYMin"
            ],
            xLeftarrow: [
                ["doubleleftarrow"], 1.526, 560, "xMinYMin"
            ],
            overleftharpoon: [
                ["leftharpoon"], .888, 522, "xMinYMin"
            ],
            xleftharpoonup: [
                ["leftharpoon"], .888, 522, "xMinYMin"
            ],
            xleftharpoondown: [
                ["leftharpoondown"], .888, 522, "xMinYMin"
            ],
            overrightharpoon: [
                ["rightharpoon"], .888, 522, "xMaxYMin"
            ],
            xrightharpoonup: [
                ["rightharpoon"], .888, 522, "xMaxYMin"
            ],
            xrightharpoondown: [
                ["rightharpoondown"], .888, 522, "xMaxYMin"
            ],
            xlongequal: [
                ["longequal"], .888, 334, "xMinYMin"
            ],
            xtwoheadleftarrow: [
                ["twoheadleftarrow"], .888, 334, "xMinYMin"
            ],
            xtwoheadrightarrow: [
                ["twoheadrightarrow"], .888, 334, "xMaxYMin"
            ],
            overleftrightarrow: [
                ["leftarrow", "rightarrow"], .888, 522
            ],
            overbrace: [
                ["leftbrace", "midbrace", "rightbrace"], 1.6, 548
            ],
            underbrace: [
                ["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548
            ],
            underleftrightarrow: [
                ["leftarrow", "rightarrow"], .888, 522
            ],
            xleftrightarrow: [
                ["leftarrow", "rightarrow"], 1.75, 522
            ],
            xLeftrightarrow: [
                ["doubleleftarrow", "doublerightarrow"], 1.75, 560
            ],
            xrightleftharpoons: [
                ["leftharpoondownplus", "rightharpoonplus"], 1.75, 716
            ],
            xleftrightharpoons: [
                ["leftharpoonplus", "rightharpoondownplus"], 1.75, 716
            ],
            xhookleftarrow: [
                ["leftarrow", "righthook"], 1.08, 522
            ],
            xhookrightarrow: [
                ["lefthook", "rightarrow"], 1.08, 522
            ],
            overlinesegment: [
                ["leftlinesegment", "rightlinesegment"], .888, 522
            ],
            underlinesegment: [
                ["leftlinesegment", "rightlinesegment"], .888, 522
            ],
            overgroup: [
                ["leftgroup", "rightgroup"], .888, 342
            ],
            undergroup: [
                ["leftgroupunder", "rightgroupunder"], .888, 342
            ],
            xmapsto: [
                ["leftmapsto", "rightarrow"], 1.5, 522
            ],
            xtofrom: [
                ["leftToFrom", "rightToFrom"], 1.75, 528
            ],
            xrightleftarrows: [
                ["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901
            ],
            xrightequilibrium: [
                ["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716
            ],
            xleftequilibrium: [
                ["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716
            ]
        },
        Te = {
            widehat1: [1062, 239, .24],
            widehat2: [2364, 300, .3],
            widehat3: [2364, 360, .36],
            widehat4: [2364, 420, .42],
            widecheck1: [1062, 239, .24],
            widecheck2: [2364, 300, .3],
            widecheck3: [2364, 360, .36],
            widecheck4: [2364, 420, .42],
            widetilde1: [600, 260, .26],
            widetilde2: [1033, 286, .286],
            widetilde3: [2339, 306, .306],
            widetilde4: [2340, 312, .34],
            overarc: [1061, 159, .3],
            underarc: [1061, 159, .3]
        },
        ze = {
            doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
            doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
            leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
            leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
            leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
            overarc: "M529 0c179 0 524 115 524 115 5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2s-338-93-512-92c-174 0-513 92-513 92h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13 0 0 342-115 520-115z",
            underarc: "m 529 160\n  c -179 0 -524 -115 -524 -115\n  c -5 -1 -9 -5 -9 -10\n  c 0 -1 1 -2 1 -3\n  l 4 -22\n  c 1 -5 5 -9 11 -9\n  h 2\n  s 338 93 512 92\n  c 174 0 513 -92 513 -92\n  h 2\n  c 5 0 9 4 11 9\n  l 5 22\n  c 1 6 -2 12 -8 13\n  c 0 0 -342 115 -520 115\n  z\n  ",
            leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
            leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
            leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
            leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
            leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
            leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
            lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
            leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
            leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
            leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
            longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
            midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
            midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
            oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
            oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
            oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
            oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
            rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
            rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
            rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
            rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
            rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
            rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
            rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
            rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
            rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
            righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
            rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
            rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
            twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
            twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
            widetilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
            widetilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
            widetilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
            widetilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
            vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
            widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
            widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
            widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
            rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
            baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
            rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
            shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
            shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
        };
    class Be {
        static createAtom(e, t, a, i) {
            return Be._registry[e].createAtom(t, a, i)
        }
        static serialize(e, t) {
            return Be._registry[e[0].mode].serialize(e, t)
        }
        static applyStyle(e, t, a) {
            return Be._registry[e].applyStyle(t, a)
        }
        constructor(e) {
            Be._registry[e] = this
        }
    }

    function Ke(e, t) {
        const a = [];
        let i, o = [];
        for (const r of e)
            if ("first" !== r.type && r.style) {
                let e;
                "variant" === t ? (e = r.style.variant, r.style.variantStyle && "up" !== r.style.variantStyle && (e += "-" + r.style.variantStyle)) : "cssClass" === t ? "group" === r.type && (e = r.customClass) : e = r.style[t], e === i ? o.push(r) : (o.length > 0 && a.push(o), o = [r], i = e)
            } return o.length > 0 && a.push(o), a
    }
    Be._registry = {};
    const qe = ["", "chem", "mord", "mbin", "mop", "mrel", "mopen", "mclose", "mpunct", "minner", "spacing", "first", "latex", "composition", "error", "placeholder", "supsub", "none", "mathfield"],
        $e = {
            mord: {
                mop: 3,
                mbin: 4,
                mrel: 5,
                minner: 3
            },
            mop: {
                mord: 3,
                mop: 3,
                rel: 5,
                minner: 3
            },
            mbin: {
                mord: 4,
                mop: 4,
                mopen: 4,
                minner: 4
            },
            mrel: {
                mord: 5,
                mop: 5,
                mopen: 5,
                minner: 5
            },
            mclose: {
                mop: 3,
                mbin: 4,
                mrel: 5,
                minner: 3
            },
            mpunct: {
                mord: 3,
                mop: 3,
                mrel: 3,
                mopen: 3,
                mpunct: 3,
                minner: 3
            },
            minner: {
                mord: 3,
                mop: 3,
                mbin: 4,
                mrel: 5,
                mopen: 3,
                mpunct: 3,
                minner: 3
            }
        },
        Ee = {
            mord: {
                mop: 3
            },
            mop: {
                mord: 3,
                mop: 3
            },
            mclose: {
                mop: 3
            },
            minner: {
                mop: 3
            }
        };

    function Oe(e, t) {
        if ("string" == typeof e) return e;
        if ("number" == typeof e) {
            const a = Math.ceil(100 * e) / 100;
            return 0 === a ? "0" : a.toString() + (null != t ? t : "")
        }
        return ""
    }
    class Ne {
        set atomID(e) {
            void 0 !== e && 0 !== e.length && (this.attributes || (this.attributes = {}), this.attributes["data-atom-id"] = e)
        }
        selected(e) {
            if (this.isSelected !== e && (this.isSelected = e, this.children))
                for (const t of this.children) t.selected(e)
        }
        setStyle(e, t, a) {
            if (void 0 === t) return;
            const i = Oe(t, a);
            i.length > 0 && (this.cssProperties || (this.cssProperties = {}), this.cssProperties[e] = i)
        }
        setTop(e) {
            Number.isFinite(e) && Math.abs(e) > .01 && (this.cssProperties || (this.cssProperties = {}), this.cssProperties.top = Oe(e, "em"), this.height -= e, this.depth += e)
        }
        get left() {
            var e;
            return (null === (e = this.cssProperties) || void 0 === e ? void 0 : e["margin-left"]) ? Number.parseFloat(this.cssProperties["margin-left"]) : 0
        }
        set left(e) {
            Number.isFinite(e) && (0 === e ? this.cssProperties && delete this.cssProperties["margin-left"] : (this.cssProperties || (this.cssProperties = {}), this.cssProperties["margin-left"] = Oe(e, "em")))
        }
        set right(e) {
            Number.isFinite(e) && (0 === e ? this.cssProperties && delete this.cssProperties["margin-right"] : (this.cssProperties || (this.cssProperties = {}), this.cssProperties["margin-right"] = Oe(e, "em")))
        }
        set width(e) {
            Number.isFinite(e) && (0 === e ? this.cssProperties && delete this.cssProperties.width : (this.cssProperties || (this.cssProperties = {}), this.cssProperties.width = Oe(e, "em")))
        }
        wrap(e, t) {
            const a = e.parent;
            if (!a) return this;
            e.isPhantom && this.setStyle("opacity", 0);
            let i = e.computedColor;
            i === a.computedColor && (i = ""), this.setStyle("color", i);
            const o = e.effectiveFontSize === a.effectiveFontSize ? void 0 : e.effectiveFontSize;
            let r, n = e.computedBackgroundColor;
            if (this.isSelected && (n = w(n)), n === a.computedBackgroundColor && (n = ""), !(o || n || t && (t.classes || t.type))) return this;
            n ? (r = je(this, t), r.selected(this.isSelected), r.setStyle("background-color", n), r.setStyle("display", "inline-block")) : r = new Ne(this, t);
            const s = e.scalingFactor;
            return 1 !== s && (r.setStyle("font-size", 100 * s, "%"), r.height *= s, r.depth *= s, r.italic *= s, r.skew *= s), r
        }
        wrapSelect(e) {
            if (!this.isSelected) return this;
            if (!e.parent) return this;
            const t = w(e.computedBackgroundColor),
                a = je(this);
            return a.selected(!0), a.setStyle("background-color", t), a.setStyle("display", "inline-block"), a
        }
        toMarkup() {
            var e, t, a;
            let i = null !== (e = this.value) && void 0 !== e ? e : "";
            if (this.children)
                for (const e of this.children) i += e.toMarkup();
            const o = this.classes.split(" ");
            o.push(null !== (t = {
                latex: "ML__latex",
                placeholder: "ML__placeholder",
                error: "ML__error"
            } [this.type]) && void 0 !== t ? t : ""), "latex" === this.caret && o.push("ML__latex-caret");
            const r = 1 === o.length ? o[0] : o.filter(((e, t, a) => e.length > 0 && a.indexOf(e) === t)).join(" ");
            let n = "";
            if (i.length > 0 && "​" !== i || r.length > 0 || this.cssId || this.htmlData || this.htmlStyle || this.attributes || this.cssProperties || this.svgBody || this.svgOverlay) {
                let e = "";
                if (this.cssId && (e += ` id=${this.cssId.replace(/ /g,"-")} `), this.htmlData) {
                    const t = this.htmlData.split(",");
                    for (const a of t) {
                        const t = a.match(/([^=]+)=(.+$)/);
                        if (t) {
                            const a = t[1].trim().replace(/ /g, "-");
                            a && (e += ` data-${a}=${t[2]} `)
                        } else {
                            const t = a.trim().replace(/ /g, "-");
                            t && (e += ` data-${t} `)
                        }
                    }
                }
                if (this.htmlStyle) {
                    const t = this.htmlStyle.split(";");
                    let a = "";
                    for (const e of t) {
                        const t = e.match(/([^=]+):(.+$)/);
                        if (t) {
                            const e = t[1].trim().replace(/ /g, "-");
                            e && (a += `${e}:${t[2]};`)
                        }
                    }
                    a && (e += ` style="${a}"`)
                }
                if (this.attributes && (e += " " + Object.keys(this.attributes).map((e => `${e}="${this.attributes[e]}"`)).join(" ")), r.length > 0 && (e += ` class="${r}"`), this.cssProperties) {
                    const t = Object.keys(this.cssProperties).map((e => `${e}:${this.cssProperties[e]}`)).join(";");
                    t.length > 0 && (e += ` style="${t}"`)
                }
                let t = "";
                this.svgBody ? t = function(e) {
                    if (Te[e]) {
                        const [t, a, i] = Te[e];
                        return `<span style="display:inline-block;height:${i/2}em;min-width:0"><span class="stretchy" style="height:${i}em"><svg width="100%" height="${i}em" viewBox="0 0 ${t} ${a}" preserveAspectRatio="none" ><path fill="currentcolor" d="${ze[e]}"></path></svg></span></span>`
                    }
                    const [t, a, i, o] = De[e];
                    let r, n;
                    const s = i / 1e3;
                    3 === t.length ? (r = ["slice-1-of-3", "slice-2-of-3", "slice-3-of-3"], n = ["xMinYMin", "xMidYMin", "xMaxYMin"]) : 2 === t.length ? (r = ["slice-1-of-2", "slice-2-of-2"], n = ["xMinYMin", "xMaxYMin"]) : (r = ["slice-1-of-1"], n = [o]);
                    const l = t.map(((e, t) => `<span class="${r[t]}" style=height:${s}em><svg width=400em height=${s}em viewBox="0 0 400000 ${i}" preserveAspectRatio="${n[t]} slice"><path fill="currentcolor" d="${ze[e]}"></path></svg></span>`)).join("");
                    return `<span style="display:inline-block;height:${s}em;min-width:${a}em;">${l}</span>`
                }(this.svgBody) : this.svgOverlay && (t = '<span style="', t += "display: inline-block;", t += `height:${this.height+this.depth}em;`, t += `vertical-align:${this.depth}em;`, t += '">', t += i, t += "</span>", t += '<svg style="position:absolute;overflow:overlay;', t += `height:${this.height+this.depth}em;`, (null === (a = this.cssProperties) || void 0 === a ? void 0 : a.padding) ? (t += `top:${this.cssProperties.padding}em;`, t += `left:${this.cssProperties.padding}em;`, t += `width:calc(100% - 2 * ${this.cssProperties.padding}em );`) : t += "top:0;left:0;width:100%;", t += "z-index:2;", t += '"', this.svgStyle && (t += ` style="${this.svgStyle}"`), t += `>${this.svgOverlay}</svg>`), n = `<span${e}>${i}${t}</span>`
            }
            return "text" === this.caret ? n += '<span class="ML__text-caret"></span>' : "math" === this.caret && (n += '<span class="ML__caret"></span>'), n
        }
        tryCoalesceWith(e) {
            if (this.type !== e.type) return !1;
            if (!/ML__text/.test(this.classes) && !["mord", "mbin", "mrel"].includes(this.type)) return !1;
            if (this.svgBody || !this.value) return !1;
            if (e.svgBody || !e.value) return !1;
            const t = this.children && this.children.length > 0,
                a = e.children && e.children.length > 0;
            if (t || a) return !1;
            const i = this.cssProperties ? Object.keys(this.cssProperties).length : 0;
            if (i !== (e.cssProperties ? Object.keys(e.cssProperties).length : 0)) return !1;
            if (i > 0)
                for (const t of Object.keys(this.cssProperties))
                    if (this.cssProperties[t] !== e.cssProperties[t]) return !1;
            const o = this.classes.trim().replace(/\s+/g, " ").split(" "),
                r = e.classes.trim().replace(/\s+/g, " ").split(" ");
            if (o.length !== r.length) return !1;
            o.sort(), r.sort();
            for (const [e, t] of o.entries()) {
                if ("vertical-separator" === t) return !1;
                if (t !== r[e]) return !1
            }
            return this.value += e.value, this.height = Math.max(this.height, e.height), this.depth = Math.max(this.depth, e.depth), this.maxFontSize = Math.max(this.maxFontSize, e.maxFontSize), this.italic = e.italic, !0
        }
        constructor(e, t) {
            var a, o, r, n, s, l;
            if ("number" == typeof e ? this.value = String.fromCodePoint(e) : "string" == typeof e ? this.value = e : i(e) ? this.children = e.filter((e => null !== e)) : e && e instanceof Ne && (this.children = [e]), this.type = null !== (a = null == t ? void 0 : t.type) && void 0 !== a ? a : "", this.isSelected = !1, this.isTight = null !== (o = null == t ? void 0 : t.isTight) && void 0 !== o && o, this.newList = null !== (r = null == t ? void 0 : t.newList) && void 0 !== r && r, null == t ? void 0 : t.properties)
                for (const e of Object.keys(t.properties)) this.setStyle(e, t.properties[e]);
            (null == t ? void 0 : t.attributes) && (this.attributes = t.attributes), this.classes = null !== (n = null == t ? void 0 : t.classes) && void 0 !== n ? n : "";
            let d = (null == t ? void 0 : t.fontFamily) || "Main-Regular";
            if ((null == t ? void 0 : t.style) && this.value && (d = Be.applyStyle(null !== (s = t.mode) && void 0 !== s ? s : "math", this, t.style) || "Main-Regular"), this.height = 0, this.depth = 0, this.skew = 0, this.italic = 0, this.maxFontSize = 0, "latex" === this.type) this.height = .8, this.depth = .2;
            else if ("number" == typeof e) {
                const t = _e(e, d);
                this.height = t.height, this.depth = t.depth, this.skew = t.skew, this.italic = t.italic
            } else if (this.value) {
                this.height = -1 / 0, this.depth = -1 / 0, this.skew = -1 / 0, this.italic = -1 / 0;
                for (let e = 0; e < this.value.length; e++) {
                    const t = _e(this.value.codePointAt(e), d || "Main-Regular");
                    this.height = Math.max(this.height, t.height), this.depth = Math.max(this.depth, t.depth), this.skew = t.skew, this.italic = t.italic
                }
            } else if (this.children && this.children.length > 0)
                if (1 === this.children.length) {
                    const e = this.children[0];
                    this.height = e.height, this.depth = e.depth, this.maxFontSize = e.maxFontSize, this.skew = e.skew, this.italic = e.italic
                } else {
                    let e = -1 / 0,
                        t = -1 / 0,
                        a = 0;
                    for (const i of this.children) i.height > e && (e = i.height), i.depth > t && (t = i.depth), a = Math.max(a, null !== (l = i.maxFontSize) && void 0 !== l ? l : 0);
                    this.height = e, this.depth = t, this.maxFontSize = a
                } void 0 !== (null == t ? void 0 : t.height) && (this.height = t.height), void 0 !== (null == t ? void 0 : t.depth) && (this.depth = t.depth), void 0 !== (null == t ? void 0 : t.maxFontSize) && (this.maxFontSize = t.maxFontSize)
        }
    }

    function Pe(e) {
        if (!e || 0 === e.length) return [];
        e[0].children = Pe(e[0].children);
        const t = [e[0]];
        for (let a = 1; a < e.length; a++) t[t.length - 1].tryCoalesceWith(e[a]) || (e[a].children = Pe(e[a].children), t.push(e[a]));
        return t
    }

    function Fe(e) {
        return e.children && (e.children = Pe(e.children)), e
    }

    function Re(e, t, a) {
        t.newList && (e = null);
        const i = t.type;
        if ("first" === i) return null;
        if ("spacing" === i) return e;
        if (a(e, t), t.children) {
            let o = null;
            void 0 !== i && 0 !== i.length || (o = e);
            for (const e of t.children) o = Re(o, e, a);
            void 0 !== i && 0 !== i.length || (e = o)
        }
        return "supsub" !== i && void 0 !== i && i.length > 0 && (e = t), e
    }

    function Ie(e, t) {
        e && Re(null, e, t)
    }

    function Ve(e, t = 1) {
        return function(e) {
                Ie(e, ((e, t) => {
                    "mbin" !== t.type || e && !/first|none|mbin|mop|mrel|mopen|mpunct/.test(e.type) || (t.type = "mord"), e && "mbin" === e.type && /mrel|mclose|mpunct|placeholder/.test(t.type) && (e.type = "mord")
                }))
            }(e),
            function(e, t) {
                Ie(e, ((e, a) => {
                    var i, o, r, n;
                    const s = null !== (i = null == e ? void 0 : e.type) && void 0 !== i ? i : "none",
                        l = a.isTight ? null !== (o = Ee[s]) && void 0 !== o ? o : null : null !== (r = $e[s]) && void 0 !== r ? r : null,
                        d = l && null !== (n = l[a.type]) && void 0 !== n ? n : 0;
                    d && (a.left += t * (d / 18))
                }))
            }(e, t), e
    }

    function je(e, t) {
        if (!e) return new Ne(null, t);
        const a = new Ne(null, {
            classes: "ML__strut"
        });
        a.setStyle("height", Math.max(0, e.height), "em");
        const i = [a];
        if (0 !== e.depth) {
            const t = new Ne(null, {
                classes: "ML__strut--bottom"
            });
            t.setStyle("height", e.height + e.depth, "em"), t.setStyle("vertical-align", -e.depth, "em"), i.push(t)
        }
        return i.push(e), new Ne(i, t)
    }

    function He(e) {
        const t = function(e) {
                return De[e] ? De[e][2] / 1e3 : Te[e][2]
            }(e) / 2,
            a = new Ne(null, {
                height: t + .166,
                depth: t - .166,
                maxFontSize: 0
            });
        return a.svgBody = e, a
    }
    class We extends Ne {
        constructor(e, t) {
            var a;
            const [i, o, r] = function(e) {
                var t;
                const [a, i] = function(e) {
                    if ("individualShift" in e) {
                        const t = e.individualShift;
                        let a = t[0];
                        const i = [a],
                            o = -a.shift - a.box.depth;
                        let r = o;
                        for (let e = 1; e < t.length; e++) {
                            const o = t[e],
                                n = -o.shift - r - o.box.depth,
                                s = n - (a.box.height + a.box.depth);
                            r += n, i.push(s), i.push(o), a = o
                        }
                        return [i, o]
                    }
                    if ("top" in e) {
                        let t = e.top;
                        for (const a of e.children) t -= "number" == typeof a ? a : a.box.height + a.box.depth;
                        return [e.children, t]
                    }
                    if ("bottom" in e) return [e.children, -e.bottom];
                    if ("firstBaseline" in e) {
                        const t = e.firstBaseline[0];
                        if ("number" == typeof t) throw new Error("First child must be an element.");
                        return [e.firstBaseline, -t.box.depth]
                    }
                    if ("shift" in e) {
                        const t = e.children[0];
                        if ("number" == typeof t) throw new Error("First child must be an element.");
                        return [e.children, -t.box.depth - e.shift]
                    }
                    return [null, 0]
                }(e);
                if (!a) return [
                    [], 0, 0
                ];
                let o = 0;
                for (const e of a)
                    if ("number" != typeof e) {
                        const t = e.box;
                        o = Math.max(o, t.maxFontSize, t.height)
                    } o += 2;
                const r = new Ne(null, {
                    classes: "pstrut"
                });
                r.setStyle("height", o, "em");
                const n = [];
                let s = i,
                    l = i,
                    d = i;
                for (const e of a) {
                    if ("number" == typeof e) d += e;
                    else {
                        const a = e.box,
                            i = null !== (t = e.classes) && void 0 !== t ? t : [],
                            s = new Ne([r, a], {
                                classes: i.join(" "),
                                style: e.style
                            });
                        s.setStyle("top", -o - d - a.depth, "em"), e.marginLeft && s.setStyle("margin-left", e.marginLeft, "em"), e.marginRight && s.setStyle("margin-right", e.marginRight, "em"), n.push(s), d += a.height + a.depth
                    }
                    s = Math.min(s, d), l = Math.max(l, d)
                }
                const c = new Ne(n, {
                    classes: "vlist"
                });
                if (c.setStyle("height", l, "em"), s >= 0) return [
                    [new Ne(c, {
                        classes: "vlist-r"
                    })], l, -s
                ];
                const u = new Ne(new Ne(null), {
                    classes: "vlist"
                });
                u.setStyle("height", -s, "em");
                const p = new Ne(8203, {
                    classes: "vlist-s",
                    maxFontSize: 0,
                    height: 0,
                    depth: 0
                });
                return [
                    [new Ne([c, p], {
                        classes: "vlist-r"
                    }), new Ne(u, {
                        classes: "vlist-r"
                    })], l, -s
                ]
            }(e);
            super(1 === i.length ? i[0] : i, {
                classes: (null !== (a = null == t ? void 0 : t.classes) && void 0 !== a ? a : "") + " vlist-t" + (2 === i.length ? " vlist-t2" : ""),
                height: o,
                depth: r,
                type: null == t ? void 0 : t.type
            })
        }
    }
    const Je = [
        [8205, 1],
        [65038, 2],
        [127995, 5],
        [129456, 4],
        [917536, 96]
    ];
    let Ue;
    const Xe = [127462, 127487];

    function Ge(e) {
        var t;
        if (void 0 === Ue) {
            Ue = {};
            for (const e of Je)
                for (let t = e[0]; t <= e[0] + e[1] - 1; t++) Ue[t] = !0
        }
        return null !== (t = Ue[e]) && void 0 !== t && t
    }

    function Ze(e) {
        return e >= Xe[0] && e <= Xe[1]
    }

    function Ye(e) {
        if (/^[\u0020-\u00FF]*$/.test(e)) return e;
        const t = [],
            a = function(e) {
                const t = [];
                for (let a = 0; a < e.length; a++) {
                    let i = e.charCodeAt(a);
                    if (13 === i && 10 === e.charCodeAt(a + 1) && (i = 10, a++), 13 !== i && 12 !== i || (i = 10), 0 === i && (i = 65533), i >= 55296 && i <= 56319) {
                        const t = e.charCodeAt(a + 1);
                        t >= 56320 && t <= 57343 && (i = 65536 + 1024 * (i - 55296) + (t - 56320), a++)
                    }
                    t.push(i)
                }
                return t
            }(e);
        let i = 0;
        for (; i < a.length;) {
            const e = a[i++],
                o = a[i];
            if (8205 === o) {
                const e = i - 1;
                for (i += 2; 8205 === a[i];) i += 2;
                t.push(String.fromCodePoint(...a.slice(e, i - e + 1)))
            } else if (Ge(o)) {
                const e = i - 1;
                for (; Ge(a[i]);) i += 8205 === a[i] ? 2 : 1;
                t.push(String.fromCodePoint(...a.slice(e, 2 * i - e - 1)))
            } else Ze(e) ? (i += 1, t.push(String.fromCodePoint(...a.slice(i - 2, 2)))) : t.push(String.fromCodePoint(e))
        }
        return t
    }
    class Qe {
        end() {
            return this.pos >= this.s.length
        }
        get() {
            return this.pos < this.s.length ? this.s[this.pos++] : ""
        }
        peek() {
            return this.s[this.pos]
        }
        match(e) {
            const t = "string" == typeof this.s ? e.exec(this.s.slice(this.pos)) : e.exec(this.s.slice(this.pos).join(""));
            return (null == t ? void 0 : t[0]) ? (this.pos += t[0].length, t[0]) : ""
        }
        next() {
            if (this.end()) return null;
            if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]+/)) return "<space>";
            if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]/)) return "<space>";
            const e = this.get();
            if ("\\" === e) {
                if (!this.end()) {
                    let e = this.match(/^[a-zA-Z\*]+/);
                    if (e) this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]*/);
                    else if (e = this.get(), " " === e) return "<space>";
                    return "\\" + e
                }
            } else {
                if ("{" === e) return "<{>";
                if ("}" === e) return "<}>";
                if ("^" === e) {
                    if ("^" === this.peek()) {
                        this.get();
                        const e = this.match(/^(\^(\^(\^(\^[\da-f])?[\da-f])?[\da-f])?[\da-f])?[\da-f]{2}/);
                        if (e) return String.fromCodePoint(Number.parseInt(e.slice(e.lastIndexOf("^") + 1), 16))
                    }
                    return e
                }
                if ("#" === e) {
                    if (!this.end()) {
                        let e = !1;
                        if (/[\d?@]/.test(this.peek()) && (e = !0, this.pos + 1 < this.s.length)) {
                            const t = this.s[this.pos + 1];
                            e = /[^\dA-Za-z]/.test(t)
                        }
                        return e ? "#" + this.get() : "#"
                    }
                } else if ("$" === e) return "$" === this.peek() ? (this.get(), "<$$>") : "<$>"
            }
            return e
        }
        constructor(e) {
            this.s = Ye(e), this.pos = 0, this.obeyspaces = !1
        }
    }

    function et(e, t) {
        var a, i, o, r;
        const n = [];
        let s = e.next();
        if (s)
            if ("\\relax" === s);
            else if ("\\noexpand" === s) s = e.next(), s && n.push(s);
        else if ("\\obeyspaces" === s) e.obeyspaces = !0;
        else if ("\\space" === s || "~" === s) n.push("<space>");
        else if ("\\bgroup" === s) n.push("<{>");
        else if ("\\egroup" === s) n.push("<}>");
        else if ("\\string" === s) {
            if (s = e.next(), s)
                if (s.startsWith("\\"))
                    for (const e of s) n.push("\\" === e ? "\\backslash" : e);
                else "<{>" === s ? n.push("\\{") : "<space>" === s ? n.push("~") : "<}>" === s && n.push("\\}")
        } else if ("\\csname" === s) {
            for (;
                "<space>" === e.peek();) e.next();
            let o = "",
                r = !1,
                l = [];
            do {
                if (0 === l.length)
                    if (/^#[\d?@]$/.test(e.peek())) {
                        const o = e.get().slice(1);
                        l = tt(null !== (i = null !== (a = null == t ? void 0 : t(o)) && void 0 !== a ? a : null == t ? void 0 : t("?")) && void 0 !== i ? i : "\\placeholder{}", t), s = l[0]
                    } else s = e.next(), l = s ? [s] : [];
                r = 0 === l.length, r || "\\endcsname" !== s || (r = !0, l.shift()), r || (r = "<$>" === s || "<$$>" === s || "<{>" === s || "<}>" === s || "string" == typeof s && s.length > 1 && s.startsWith("\\")), r || (o += l.shift())
            } while (!r);
            o && n.push("\\" + o), n.push(...l)
        } else if ("\\endcsname" === s);
        else if (s.length > 1 && s.startsWith("#")) {
            const e = s.slice(1);
            n.push(...tt(null !== (r = null !== (o = null == t ? void 0 : t(e)) && void 0 !== o ? o : null == t ? void 0 : t("?")) && void 0 !== r ? r : "\\placeholder{}", t))
        } else n.push(s);
        return n
    }

    function tt(e, t = null) {
        const a = [];
        let i = "";
        for (const t of e.toString().split(/\r?\n/)) {
            i && a.push(i), i = " ";
            const e = t.match(/((?:\\%)|[^%])*/);
            null !== e && a.push(e[0])
        }
        const o = new Qe(a.join("")),
            r = [];
        do {
            r.push(...et(o, t))
        } while (!o.end());
        return r
    }

    function at(e) {
        let t = "";
        const a = [];
        for (const i of e) i && (/[a-zA-Z\*]/.test(i[0]) && a.push(t), a.push(i), /\\[a-zA-Z]+\*?[\"\'][^\ ]+$/.test(i) && a.push(" "), t = /\\[a-zA-Z]+\*?$/.test(i) ? " " : "");
        return a.join("")
    }

    function it(e) {
        return at(e.map((e => {
            var t;
            return null !== (t = {
                "<space>": " ",
                "<$$>": "$$",
                "<$>": "$",
                "<{>": "{",
                "<}>": "}"
            } [e]) && void 0 !== t ? t : e
        })))
    }
    class ot extends Ne {
        toMarkup() {
            const e = [],
                t = this.classes.split(" "),
                a = 1 === t.length ? t[0] : t.filter(((e, t, a) => e.length > 0 && a.indexOf(e) === t)).join(" ");
            if (this.cssId && e.push(`id=${this.cssId.replace(/ /g,"-")}`), this.htmlData) {
                const t = this.htmlData.split(",");
                for (const a of t) {
                    const t = a.match(/([^=]+)=(.+$)/);
                    if (t) {
                        const a = t[1].trim().replace(/ /g, "-");
                        a && e.push(`data-${a}=${t[2]}`)
                    } else {
                        const t = a.trim().replace(/ /g, "-");
                        t && e.push(`data-${t}`)
                    }
                }
            }
            if (this.htmlStyle) {
                const t = this.htmlStyle.split(";");
                let a = "";
                for (const e of t) {
                    const t = e.match(/([^=]+):(.+$)/);
                    if (t) {
                        const e = t[1].trim().replace(/ /g, "-");
                        e && (a += `${e}:${t[2]};`)
                    }
                }
                a && e.push(`style="${a}"`)
            }
            this.attributes && e.push(...Object.keys(this.attributes).map((e => `${e}="${this.attributes[e]}"`))), a.length > 0 && e.push(`class="${a}"`);
            const i = this.mathfield;
            return e.push(`style="display:inline-block; width:${i.clientWidth}px; height:${i.clientHeight}px;" `), `<span ${e.join(" ")}></span>`
        }
        constructor(e, t, a) {
            super(null, a), this.mathfield = t, this.htmlData = `placeholder-id=${e} `;
            const i = function(e) {
                return je(Ve(e.model.root.render(new Ae({
                    registers: e.registers
                }, {
                    fontSize: 5,
                    letterShapeStyle: e.options.letterShapeStyle
                }, "inline-math" === e.options.defaultMode ? "textstyle" : "displaystyle")), e.options.horizontalSpacingScale), {
                    classes: "ML__mathlive",
                    attributes: {
                        translate: "no",
                        "aria-hidden": "true"
                    }
                })
            }(t._mathfield);
            this.height = i.height, this.depth = i.depth
        }
    }
    const rt = ["above", "body", "below", "superscript", "subscript"];

    function nt(e) {
        return "string" == typeof e && rt.includes(e)
    }

    function st(e) {
        return void 0 !== e && Array.isArray(e) && 2 === e.length
    }
    class lt {
        static createBox(e, t, a) {
            var i, o, r;
            if (!t) return null;
            const n = function(e) {
                let t;
                const a = [];
                let i = [];
                for (const o of e)
                    if (t || o.style) {
                        const e = o.computedStyle;
                        t && e.color === t.color && e.backgroundColor === t.backgroundColor && e.fontSize === t.fontSize ? i.push(o) : (i.length > 0 && a.push(i), i = [o], t = e)
                    } else i.push(o);
                return i.length > 0 && a.push(i), a
            }(t);
            if (1 === n.length) {
                const t = n[0];
                return t[0].style ? ct(e, t, {
                    ...a,
                    style: {
                        color: t[0].style.color,
                        backgroundColor: t[0].style.backgroundColor,
                        fontSize: t[0].style.fontSize
                    }
                }) : ct(e, t, a)
            }
            const s = [];
            let l = null == a ? void 0 : a.newList;
            for (const t of n) {
                const a = ct(new Ae(e, {
                    color: null === (i = t[0].style) || void 0 === i ? void 0 : i.color,
                    backgroundColor: null === (o = t[0].style) || void 0 === o ? void 0 : o.backgroundColor,
                    fontSize: null === (r = t[0].style) || void 0 === r ? void 0 : r.fontSize
                }), t, {
                    newList: l
                });
                a && (l = !1, s.push(a))
            }
            return 0 === s.length ? null : 1 !== s.length || (null == a ? void 0 : a.classes) || (null == a ? void 0 : a.type) ? new Ne(s, {
                classes: null == a ? void 0 : a.classes,
                type: null == a ? void 0 : a.type,
                newList: null == a ? void 0 : a.newList
            }).wrap(e) : s[0].wrap(e)
        }
        static serialize(e, t) {
            return i(e) ? dt(e, t) : "number" == typeof e || "boolean" == typeof e ? e.toString() : "string" == typeof e ? e.replace(/\s/g, "~") : void 0 === e ? "" : t.expandMacro || "string" != typeof e.verbatimLatex ? e.command && lt.customSerializer[e.command] ? lt.customSerializer[e.command](e, t) : e.serialize(t) : e.verbatimLatex
        }
        static commonAncestor(e, t) {
            if (e === t) return e.parent;
            if (e.parent === t.parent) return e.parent;
            const a = new WeakSet;
            let {
                parent: i
            } = e;
            for (; i;) a.add(i), i = i.parent;
            for (i = t.parent; i;) {
                if (a.has(i)) return i;
                i = i.parent
            }
        }
        static fromJson(e, t) {
            const a = new lt(e.type, t, e);
            for (const t of rt) e[t] && a.setChildren(e[t], t);
            return a
        }
        toJson() {
            const e = {
                type: this.type
            };
            if ("math" !== this.mode && (e.mode = this.mode), this.command && this.command !== this.value && (e.command = this.command), void 0 !== this.value && (e.value = this.value), this.style && Object.keys(this.style).length > 0 && (e.style = {
                    ...this.style
                }), void 0 !== this.verbatimLatex && (e.verbatimLatex = this.verbatimLatex), this.subsupPlacement && (e.subsupPlacement = this.subsupPlacement), this.explicitSubsupPlacement && (e.explicitSubsupPlacement = !0), this.isFunction && (e.isFunction = !0), this.displayContainsHighlight && (e.displayContainsHighlight = !0), this.isExtensibleSymbol && (e.isExtensibleSymbol = !0), this.skipBoundary && (e.skipBoundary = !0), this.captureSelection && (e.captureSelection = !0), this._branches)
                for (const t of Object.keys(this._branches)) this._branches[t] && (e[t] = this._branches[t].filter((e => "first" !== e.type)).map((e => e.toJson())));
            return e
        }
        get changeCounter() {
            return this._changeCounter
        }
        get isDirty() {
            return this._isDirty
        }
        set isDirty(e) {
            if (this._isDirty = e, e) {
                this._changeCounter++, this.verbatimLatex = void 0, this._children = void 0;
                let {
                    parent: e
                } = this;
                for (; e;) e._isDirty = !0, e._changeCounter++, e.verbatimLatex = void 0, e._children = void 0, e = e.parent
            }
        }
        serialize(e) {
            var t;
            return this.body && this.command ? at([this.command, "{", this.bodyToLatex(e), "}", this.supsubToLatex(e)]) : this.body ? at([this.bodyToLatex(e), this.supsubToLatex(e)]) : this.value && "​" !== this.value ? null !== (t = this.command) && void 0 !== t ? t : function(e, t) {
                var a;
                if ("text" === e) return null !== (a = $(e, t.codePointAt(0))) && void 0 !== a ? a : t;
                let i;
                if (i = $(e, t.codePointAt(0)), i) return i;
                const o = function(e) {
                    var t;
                    if ((e < 119808 || e > 120831) && (e < 8448 || e > 8527)) return {
                        char: String.fromCodePoint(e)
                    };
                    for (const a in E)
                        if (E[a] === e) {
                            e = null !== (t = a.codePointAt(0)) && void 0 !== t ? t : 0;
                            break
                        } for (const t of O)
                        if (e >= t.start && e < t.start + t.len) return {
                            char: String.fromCodePoint(e - t.start + t.offset),
                            variant: t.variant,
                            style: t.style
                        };
                    return {
                        char: String.fromCodePoint(e)
                    }
                }(t.codePointAt(0));
                return o.style || o.variant ? (i = o.char, o.variant && (i = "\\" + o.variant + "{" + i + "}"), "bold" === o.style ? i = "\\mathbf{" + i + "}" : "italic" === o.style ? i = "\\mathit{" + i + "}" : "bolditalic" === o.style && (i = "\\mathbfit{" + i + "}"), "\\mathord{" + i + "}") : ""
            }(this.mode, this.value) : ""
        }
        bodyToLatex(e) {
            return dt(this.body, e)
        }
        aboveToLatex(e) {
            return dt(this.above, e)
        }
        belowToLatex(e) {
            return dt(this.below, e)
        }
        supsubToLatex(e) {
            let t = "";
            if (void 0 !== this.branch("subscript")) {
                const a = dt(this.subscript, e);
                0 === a.length ? t += "_{}" : 1 === a.length ? t += "_" + a : t += `_{${a}}`
            }
            if (void 0 !== this.branch("superscript")) {
                const a = dt(this.superscript, e);
                0 === a.length ? t += "^{}" : 1 === a.length ? t += "′" === a ? "^\\prime " : "″" === a ? "^\\doubleprime " : "^" + a : t += `^{${a}}`
            }
            return t
        }
        get treeDepth() {
            let e = 1,
                t = this.parent;
            for (; t;) t = t.parent, e += 1;
            return e
        }
        get inCaptureSelection() {
            let e = !1,
                t = this;
            for (; t;) {
                if (t.captureSelection) {
                    e = !0;
                    break
                }
                t = t.parent
            }
            return e
        }
        branch(e) {
            if (nt(e) && this._branches) return this._branches[e]
        }
        get branches() {
            if (!this._branches) return [];
            const e = [];
            for (const t of rt) this._branches[t] && e.push(t);
            return e
        }
        createBranch(e) {
            return nt(e) ? (this._branches ? this._branches[e] || (this._branches[e] = [this.makeFirstAtom(e)]) : this._branches = {
                [e]: [this.makeFirstAtom(e)]
            }, this.isDirty = !0, this._branches[e]) : []
        }
        get row() {
            return st(this.treeBranch) ? this.treeBranch[0] : -1
        }
        get col() {
            return st(this.treeBranch) ? this.treeBranch[1] : -1
        }
        get body() {
            var e;
            return null === (e = this._branches) || void 0 === e ? void 0 : e.body
        }
        set body(e) {
            this.setChildren(e, "body")
        }
        get superscript() {
            var e;
            return null === (e = this._branches) || void 0 === e ? void 0 : e.superscript
        }
        set superscript(e) {
            this.setChildren(e, "superscript")
        }
        get subscript() {
            var e;
            return null === (e = this._branches) || void 0 === e ? void 0 : e.subscript
        }
        set subscript(e) {
            this.setChildren(e, "subscript")
        }
        get above() {
            var e;
            return null === (e = this._branches) || void 0 === e ? void 0 : e.above
        }
        set above(e) {
            this.setChildren(e, "above")
        }
        get below() {
            var e;
            return null === (e = this._branches) || void 0 === e ? void 0 : e.below
        }
        set below(e) {
            this.setChildren(e, "below")
        }
        get computedStyle() {
            var e;
            if (!this.parent) return {
                ...null !== (e = this.style) && void 0 !== e ? e : {}
            };
            const t = void 0 !== this.style.verbatimColor,
                a = void 0 !== this.style.verbatimBackgroundColor,
                i = {
                    ...this.parent.computedStyle,
                    ...this.style
                };
            return delete i.variant, delete i.variantStyle, a || delete i.verbatimBackgroundColor, t || delete i.verbatimColor, i
        }
        applyStyle(e) {
            this.isDirty = !0, this.style = {
                ...this.style,
                ...e
            }, "none" === this.style.fontFamily && delete this.style.fontFamily, "auto" === this.style.fontShape && delete this.style.fontShape, "auto" === this.style.fontSeries && delete this.style.fontSeries, "none" === this.style.color && (delete this.style.color, delete this.style.verbatimColor), "none" === this.style.backgroundColor && (delete this.style.backgroundColor, delete this.style.verbatimBackgroundColor), "auto" === this.style.fontSize && delete this.style.fontSize;
            for (const t of this.children) t.applyStyle(e)
        }
        getInitialBaseElement() {
            let e;
            return this.hasEmptyBranch("body") || (e = this.body[1].getInitialBaseElement()), null != e ? e : this
        }
        getFinalBaseElement() {
            return this.hasEmptyBranch("body") ? this : this.body[this.body.length - 1].getFinalBaseElement()
        }
        isCharacterBox() {
            if ("leftright" === this.type) return !1;
            const e = this.getInitialBaseElement();
            return /mord/.test(e.type)
        }
        hasEmptyBranch(e) {
            const t = this.branch(e);
            return !t || 1 === t.length
        }
        setChildren(e, t) {
            if (!e) return;
            if (!nt(t)) return;
            const a = [this.makeFirstAtom(t), ...e];
            this._branches ? this._branches[t] = a : this._branches = {
                [t]: a
            };
            for (const a of e) a.parent = this, a.treeBranch = t;
            this.isDirty = !0
        }
        makeFirstAtom(e) {
            const t = new lt("first", this.context, {
                mode: this.mode
            });
            return t.parent = this, t.treeBranch = e, t
        }
        addChild(e, t) {
            this.createBranch(t).push(e), this.isDirty = !0, e.parent = this, e.treeBranch = t
        }
        addChildBefore(e, t) {
            const a = this.createBranch(t.treeBranch);
            a.splice(a.indexOf(t), 0, e), this.isDirty = !0, e.parent = this, e.treeBranch = t.treeBranch
        }
        addChildAfter(e, t) {
            const a = this.createBranch(t.treeBranch);
            a.splice(a.indexOf(t) + 1, 0, e), this.isDirty = !0, e.parent = this, e.treeBranch = t.treeBranch
        }
        addChildren(e, t) {
            for (const a of e) this.addChild(a, t)
        }
        addChildrenAfter(e, t) {
            const a = this.createBranch(t.treeBranch);
            a.splice(a.indexOf(t) + 1, 0, ...e), this.isDirty = !0;
            for (const a of e) a.parent = this, a.treeBranch = t.treeBranch;
            return e[e.length - 1]
        }
        removeBranch(e) {
            const t = this.branch(e);
            if (nt(e) && (this._branches[e] = void 0), !t) return [];
            for (const e of t) e.parent = void 0, e.treeBranch = void 0;
            return t.shift(), this.isDirty = !0, t
        }
        removeChild(e) {
            if ("first" === e.type) return;
            const t = this.branch(e.treeBranch),
                a = t.indexOf(e);
            t.splice(a, 1), this.isDirty = !0, e.parent = void 0, e.treeBranch = void 0
        }
        get siblings() {
            return "root" === this.type ? [] : this.parent.branch(this.treeBranch)
        }
        get firstSibling() {
            return this.siblings[0]
        }
        get lastSibling() {
            const {
                siblings: e
            } = this;
            return e[e.length - 1]
        }
        get isFirstSibling() {
            return this === this.firstSibling
        }
        get isLastSibling() {
            return this === this.lastSibling
        }
        get hasNoSiblings() {
            return 1 === this.siblings.length
        }
        get leftSibling() {
            const e = this.parent.branch(this.treeBranch);
            return e[e.indexOf(this) - 1]
        }
        get rightSibling() {
            const e = this.parent.branch(this.treeBranch);
            return e[e.indexOf(this) + 1]
        }
        get hasChildren() {
            return Boolean(this._branches && this.children.length > 0)
        }
        get firstChild() {
            return this.children[0]
        }
        get lastChild() {
            const {
                children: e
            } = this;
            return e[e.length - 1]
        }
        get children() {
            if (this._children) return this._children;
            if (!this._branches) return [];
            const e = [];
            for (const t of rt)
                if (this._branches[t])
                    for (const a of this._branches[t]) e.push(...a.children), e.push(a);
            return this._children = e, e
        }
        render(e, t) {
            if ("first" === this.type && !e.atomIdsSettings) return null;
            const a = new Ae(e, this.style);
            let i = "";
            "root" === this.type && (i += " ML__base"), this.isSelected && (i += " ML__selected");
            let o = this.createBox(a, {
                classes: i,
                newList: !0 === (null == t ? void 0 : t.newList) || "first" === this.type
            });
            return o ? (this.subsupPlacement || !this.superscript && !this.subscript || (o = this.attachSupsub(a, {
                base: o
            })), o.wrap(a)) : null
        }
        attachSupsub(e, t) {
            var a, i;
            const o = t.base,
                r = this.superscript,
                n = this.subscript;
            if (!r && !n) return o;
            let s = null,
                l = null;
            const d = null !== (a = t.isCharacterBox) && void 0 !== a ? a : this.isCharacterBox();
            let c = 0;
            if (r) {
                const t = new Ae(e, void 0, "superscript");
                s = lt.createBox(t, r, {
                    newList: !0
                }), d || (c = o.height - e.metrics.supDrop * t.scalingFactor)
            }
            let u, p = 0;
            if (n) {
                const t = new Ae(e, void 0, "subscript");
                l = lt.createBox(t, n, {
                    newList: !0
                }), d || (p = o.depth + e.metrics.subDrop * t.scalingFactor)
            }
            u = e.isDisplayStyle ? e.metrics.sup1 : e.isCramped ? e.metrics.sup3 : e.metrics.sup2;
            const h = .05 / e.scalingFactor;
            let m = null;
            if (l && s) {
                c = Math.max(c, u, s.depth + .25 * e.metrics.xHeight), p = Math.max(p, e.metrics.sub2);
                const t = e.metrics.defaultRuleThickness;
                if (c - s.depth - (l.height - p) < 4 * t) {
                    p = 4 * t - (c - s.depth) + l.height;
                    const a = .8 * e.metrics.xHeight - (c - s.depth);
                    a > 0 && (c += a, p -= a)
                }
                const a = this.isExtensibleSymbol && o.italic ? -o.italic : 0;
                m = new We({
                    individualShift: [{
                        box: l,
                        shift: p,
                        marginLeft: a
                    }, {
                        box: s,
                        shift: -c
                    }]
                }).wrap(e)
            } else l && !s ? (p = Math.max(p, e.metrics.sub1, l.height - .3448), m = new We({
                shift: p,
                children: [{
                    box: l,
                    marginRight: h,
                    marginLeft: this.isCharacterBox() ? -(null !== (i = o.italic) && void 0 !== i ? i : 0) : 0
                }]
            })) : !l && s && (c = Math.max(c, u, s.depth + .10775), m = new We({
                shift: -c,
                children: [{
                    box: s,
                    marginRight: h
                }]
            }), m.wrap(e));
            const f = new Ne(m, {
                classes: "msubsup" + (this.isSelected ? " ML__selected" : "")
            });
            return this.caret && (f.caret = this.caret), new Ne([o, f], {
                type: t.type
            })
        }
        attachLimits(e, t) {
            var a;
            const i = this.superscript ? lt.createBox(new Ae(e, this.style, "superscript"), this.superscript, {
                    newList: !0
                }) : null,
                o = this.subscript ? lt.createBox(new Ae(e, this.style, "subscript"), this.subscript, {
                    newList: !0
                }) : null;
            return i || o ? function(e, t) {
                var a, i, o, r, n;
                const s = e.metrics,
                    l = new Ne(t.base),
                    d = null !== (a = t.baseShift) && void 0 !== a ? a : 0,
                    c = null !== (i = t.slant) && void 0 !== i ? i : 0;
                let u = 0,
                    p = 0;
                t.above && (u = null !== (o = t.aboveShift) && void 0 !== o ? o : Math.max(s.bigOpSpacing1, s.bigOpSpacing3 - t.above.depth)), t.below && (p = null !== (r = t.belowShift) && void 0 !== r ? r : Math.max(s.bigOpSpacing2, s.bigOpSpacing4 - t.below.height));
                let h = null;
                if (t.below && t.above) {
                    const a = s.bigOpSpacing5 + t.below.height + t.below.depth + p + l.depth + d;
                    h = new We({
                        bottom: a,
                        children: [s.bigOpSpacing5, {
                            box: t.below,
                            marginLeft: -c,
                            classes: ["ML__center"]
                        }, p, {
                            box: l,
                            classes: ["ML__center"]
                        }, u, {
                            box: t.above,
                            marginLeft: c,
                            classes: ["ML__center"]
                        }, s.bigOpSpacing5]
                    }).wrap(e)
                } else if (t.below && !t.above) h = new We({
                    top: l.height - d,
                    children: [s.bigOpSpacing5, {
                        box: t.below,
                        marginLeft: -c,
                        classes: ["ML__center"]
                    }, p, {
                        box: l,
                        classes: ["ML__center"]
                    }]
                }).wrap(e);
                else if (!t.below && t.above) {
                    const a = l.depth + d;
                    h = new We({
                        bottom: a,
                        children: [{
                            box: l,
                            classes: ["ML__center"]
                        }, u, {
                            box: t.above,
                            marginLeft: c,
                            classes: ["ML__center"]
                        }, s.bigOpSpacing5]
                    }).wrap(e)
                } else {
                    const t = l.depth + d;
                    h = new We({
                        bottom: t,
                        children: [{
                            box: l
                        }, s.bigOpSpacing5]
                    }).wrap(e)
                }
                return new Ne(h, {
                    type: null !== (n = t.type) && void 0 !== n ? n : "mop"
                })
            }(e, {
                ...t,
                above: i,
                below: o,
                type: null !== (a = null == t ? void 0 : t.type) && void 0 !== a ? a : "mop"
            }) : t.base.wrap(e)
        }
        bind(e, t) {
            if (!t || e.isPhantom || "​" === this.value) return t;
            let a = this.parent;
            for (; a && !a.captureSelection;) a = a.parent;
            return (null == a ? void 0 : a.captureSelection) || (this.id || (this.id = e.makeID()), t.atomID = this.id), t
        }
        createMathfieldBox(e, t, a) {
            const i = new ot(a, t, {
                type: "mathfield",
                mode: this.mode,
                maxFontSize: e.scalingFactor,
                style: {
                    variant: "normal",
                    ...this.style,
                    letterShapeStyle: e.letterShapeStyle,
                    fontSize: Math.max(1, e.size + e.mathstyle.sizeDelta)
                },
                classes: ""
            });
            return e.isTight && (i.isTight = !0), "math" === this.mode && "main" !== this.style.variant || (i.italic = 0), i.right = i.italic, this.bind(e, i), je(i, {
                type: "mord"
            })
        }
        createBox(e, t) {
            var a, i, o, r;
            const n = null !== (a = this.value) && void 0 !== a ? a : this.body,
                s = function(e) {
                    return qe.includes(e)
                }(this.type) ? this.type : void 0;
            let l = null !== (i = null == t ? void 0 : t.classes) && void 0 !== i ? i : "";
            "text" === this.mode && (l += " ML__text");
            const d = "string" == typeof n || void 0 === n ? new Ne(null !== (o = n) && void 0 !== o ? o : null, {
                type: s,
                mode: this.mode,
                maxFontSize: e.scalingFactor,
                style: {
                    variant: "normal",
                    ...this.style,
                    letterShapeStyle: e.letterShapeStyle,
                    fontSize: Math.max(1, e.size + e.mathstyle.sizeDelta)
                },
                classes: l,
                newList: null == t ? void 0 : t.newList
            }) : null !== (r = lt.createBox(e, n, {
                type: s,
                mode: this.mode,
                style: this.style,
                classes: l,
                newList: null == t ? void 0 : t.newList
            })) && void 0 !== r ? r : new Ne(null);
            return e.isTight && (d.isTight = !0), "math" === this.mode && "main" !== this.style.variant || (d.italic = 0), d.right = d.italic, this.bind(e, d), this.caret && (this.superscript || this.subscript || (d.caret = this.caret)), d
        }
        isDigit() {
            var e;
            return "mord" === this.type && this.value ? /^[\d,.]$/.test(this.value) : "group" === this.type && 2 === (null === (e = this.body) || void 0 === e ? void 0 : e.length) && "first" === this.body[0].type && "," === this.body[1].value
        }
        asDigit() {
            var e;
            return "mord" === this.type && this.value && /^[\d,.]$/.test(this.value) ? this.value : "group" === this.type && 2 === (null === (e = this.body) || void 0 === e ? void 0 : e.length) && "first" === this.body[0].type && "," === this.body[1].value ? "." : ""
        }
        constructor(e, t, a) {
            var i, o, r, n, s, l;
            this.id = void 0, this.verbatimLatex = void 0, this._isDirty = !1, this._changeCounter = 0, this.subsupPlacement = void 0, this.explicitSubsupPlacement = !1, this.skipBoundary = !1, this.captureSelection = !1, this.type = e, this.context = t, "string" == typeof(null == a ? void 0 : a.value) && (this.value = a.value), this.command = null !== (o = null !== (i = null == a ? void 0 : a.command) && void 0 !== i ? i : this.value) && void 0 !== o ? o : "", this.mode = null !== (r = null == a ? void 0 : a.mode) && void 0 !== r ? r : "math", this.isFunction = null !== (n = null == a ? void 0 : a.isFunction) && void 0 !== n && n, this.subsupPlacement = null == a ? void 0 : a.limits, this.style = null !== (s = null == a ? void 0 : a.style) && void 0 !== s ? s : {}, this.displayContainsHighlight = null !== (l = null == a ? void 0 : a.displayContainsHighlight) && void 0 !== l && l, (null == a ? void 0 : a.serialize) && (lt.customSerializer[a.command] = a.serialize)
        }
    }

    function dt(e, t) {
        if (!e || 0 === e.length) return "";
        if ("first" === e[0].type) {
            if (1 === e.length) return "";
            e = e.slice(1)
        }
        return 0 === e.length ? "" : at(Ke(e, "cssClass").map((e => at(Ke(e, "color").map((e => at(function(e) {
            const t = [];
            let a = [],
                i = "NONE";
            for (const o of e) "first" !== o.type && (o.mode !== i ? (a.length > 0 && t.push(a), a = [o], i = o.mode) : a.push(o));
            return a.length > 0 && t.push(a), t
        }(e).map((e => Be.serialize(e, t))))))))))
    }

    function ct(e, t, a) {
        var i, o, r, n;

        function s(e) {
            return "text" === e.mode
        }
        if (!t || 0 === t.length) return null;
        const l = new Ae(e, null == a ? void 0 : a.style),
            d = !l.atomIdsSettings || !l.atomIdsSettings.groupNumbers;
        let c, u = [],
            p = null !== (i = null == a ? void 0 : a.newList) && void 0 !== i && i;
        if (1 === t.length) {
            const e = t[0],
                a = e.render(l, {
                    newList: p
                });
            a && (d && e.isSelected && a.selected(!0), u = [a])
        } else {
            let e = "",
                a = !0;
            for (const i of t) {
                (null === (o = l.atomIdsSettings) || void 0 === o ? void 0 : o.groupNumbers) && e && (a && i.isDigit() || !a && s(i)) && (l.atomIdsSettings.overrideID = e);
                const t = i.render(l, {
                    newList: p
                });
                l.atomIdsSettings && (l.atomIdsSettings.overrideID = void 0), t && (p = "group" === i.type && !i.boxType, (null === (r = l.atomIdsSettings) || void 0 === r ? void 0 : r.groupNumbers) && ((i.isDigit() || s(i)) && (e && a === i.isDigit() || (a = i.isDigit(), e = null !== (n = i.id) && void 0 !== n ? n : "")), !e || (i.isDigit() || s(i)) && i.hasEmptyBranch("superscript") && i.hasEmptyBranch("subscript") || (e = "")), d && i.isSelected && t.selected(!0), u.push(t))
            }
        }
        return 0 === u.length ? null : (a || l.isTight || u.length > 1 ? (c = new Ne(u, {
            isTight: l.isTight,
            ...null != a ? a : {}
        }), c.isSelected = u.every((e => e.isSelected))) : c = u[0], c.wrap(l).wrap(e))
    }
    lt.customSerializer = {};
    class ut extends lt {
        static fromJson(e, t) {
            return new ut(e.command, e.body, t, {
                accentChar: e.accentChar,
                svgAccent: e.svgAccent,
                style: e.style
            })
        }
        toJson() {
            return {
                ...super.toJson(),
                accentChar: this.accent,
                svgAccent: this.svgAccent
            }
        }
        render(e) {
            var t;
            const a = new Ae(e, this.style, "cramp"),
                i = null !== (t = lt.createBox(a, this.body)) && void 0 !== t ? t : new Ne(null);
            let o = 0;
            !this.hasEmptyBranch("body") && 2 === this.body.length && this.body[1].isCharacterBox() && (o = i.skew);
            let r, n = Math.min(i.height, .431);
            if (this.svgAccent) r = He(this.svgAccent), n = a.metrics.bigOpSpacing1 - n;
            else if (this.accent) {
                const e = new Ne(this.accent, {
                    fontFamily: "Main-Regular"
                });
                e.italic = 0;
                const t = 8407 === this.accent ? " ML__accent-vec" : "";
                r = new Ne(new Ne(e), {
                    classes: "ML__accent-body" + t
                })
            }
            r = new We({
                shift: 0,
                children: [{
                    box: new Ne(i)
                }, -n, {
                    box: r,
                    marginLeft: i.left + 2 * o,
                    classes: ["ML__center"]
                }]
            });
            const s = new Ne(r, {
                newList: !0,
                type: "mord"
            });
            return this.caret && (s.caret = this.caret), this.bind(a, s.wrap(a)), this.attachSupsub(a, {
                base: s
            })
        }
        constructor(e, t, a, i) {
            super("accent", a, {
                command: e,
                style: i.style
            }), i.accentChar ? this.accent = i.accentChar : this.svgAccent = null == i ? void 0 : i.svgAccent, this.body = t, this.skipBoundary = !0
        }
    }
    const pt = {
            "(": ")",
            "{": "}",
            "[": "]",
            "|": "|",
            "\\lbrace": "\\rbrace",
            "\\lparen": "\\rparen",
            "\\{": "\\}",
            "\\langle": "\\rangle",
            "\\lfloor": "\\rfloor",
            "\\lceil": "\\rceil",
            "\\vert": "\\vert",
            "\\lvert": "\\rvert",
            "\\Vert": "\\Vert",
            "\\lVert": "\\rVert",
            "\\lbrack": "\\rbrack",
            "\\ulcorner": "\\urcorner",
            "\\llcorner": "\\lrcorner",
            "\\lgroup": "\\rgroup",
            "\\lmoustache": "\\rmoustache"
        },
        ht = Object.fromEntries(Object.entries(pt).map((([e, t]) => [t, e])));

    function mt(e) {
        var t;
        return null !== (t = {
            "[": 91,
            "]": 93,
            "(": 40,
            ")": 41,
            "\\mid": 8739,
            "|": 8739,
            "∣": 8739,
            "∥": 8741,
            "\\|": 8739,
            "\\{": 123,
            "\\}": 125,
            "\\lbrace": 123,
            "\\rbrace": 125,
            "\\lparen": 40,
            "\\rparen": 41,
            "\\lbrack": 91,
            "\\rbrack": 93,
            "\\vert": 8739,
            "\\lvert": 8739,
            "\\mvert": 8739,
            "\\rvert": 8739,
            "\\Vert": 8741,
            "\\lVert": 8741,
            "\\mVert": 8741,
            "\\rVert": 8741,
            "\\parallel": 8741,
            "\\shortparallel": 8741,
            "\\langle": 10216,
            "\\rangle": 10217,
            "\\lfloor": 8970,
            "\\rfloor": 8971,
            "\\lceil": 8968,
            "\\rceil": 8969,
            "\\ulcorner": 9484,
            "\\urcorner": 9488,
            "\\llcorner": 9492,
            "\\lrcorner": 9496,
            "\\lgroup": 10222,
            "\\rgroup": 10223,
            "\\lmoustache": 9136,
            "\\rmoustache": 9137,
            "\\surd": 8730
        } [e]) && void 0 !== t ? t : e.codePointAt(0)
    }

    function ft(e, t, a, i, o) {
        const r = new Ae(i, null == o ? void 0 : o.style, "textstyle"),
            n = new Ne(mt(e), {
                fontFamily: "Size" + t + "-Regular",
                classes: "ML__delim-size" + t
            }).wrap(r);
        return a && n.setTop(.25 * (1 - r.scalingFactor)), n
    }

    function yt(e, t, a, i, o) {
        var r;
        let n, s, l, d;
        n = l = d = mt(e), s = null;
        let c = "Size1-Regular";
        "\\vert" === e || "\\lvert" === e || "\\rvert" === e || "\\mvert" === e || "\\mid" === e ? l = n = d = 8739 : "\\Vert" === e || "\\lVert" === e || "\\rVert" === e || "\\mVert" === e || "\\|" === e ? l = n = d = 8741 : "\\uparrow" === e ? l = d = 9168 : "\\Uparrow" === e ? l = d = 8214 : "\\downarrow" === e ? n = l = 9168 : "\\Downarrow" === e ? n = l = 8214 : "\\updownarrow" === e ? (n = 8593, l = 9168, d = 8595) : "\\Updownarrow" === e ? (n = 8657, l = 8214, d = 8659) : "[" === e || "\\lbrack" === e ? (n = 9121, l = 9122, d = 9123, c = "Size4-Regular") : "]" === e || "\\rbrack" === e ? (n = 9124, l = 9125, d = 9126, c = "Size4-Regular") : "\\lfloor" === e || "⌊" === e ? (l = n = 9122, d = 9123, c = "Size4-Regular") : "\\lceil" === e || "⌈" === e ? (n = 9121, l = d = 9122, c = "Size4-Regular") : "\\rfloor" === e || "⌋" === e ? (l = n = 9125, d = 9126, c = "Size4-Regular") : "\\rceil" === e || "⌉" === e ? (n = 9124, l = d = 9125, c = "Size4-Regular") : "(" === e || "\\lparen" === e ? (n = 9115, l = 9116, d = 9117, c = "Size4-Regular") : ")" === e || "\\rparen" === e ? (n = 9118, l = 9119, d = 9120, c = "Size4-Regular") : "\\{" === e || "\\lbrace" === e ? (n = 9127, s = 9128, d = 9129, l = 9130, c = "Size4-Regular") : "\\}" === e || "\\rbrace" === e ? (n = 9131, s = 9132, d = 9133, l = 9130, c = "Size4-Regular") : "\\lgroup" === e || "⟮" === e ? (n = 9127, d = 9129, l = 9130, c = "Size4-Regular") : "\\rgroup" === e || "⟯" === e ? (n = 9131, d = 9133, l = 9130, c = "Size4-Regular") : "\\lmoustache" === e || "⎰" === e ? (n = 9127, d = 9133, l = 9130, c = "Size4-Regular") : "\\rmoustache" === e || "⎱" === e ? (n = 9131, d = 9129, l = 9130, c = "Size4-Regular") : "\\surd" === e ? (n = 57345, d = 9143, l = 57344, c = "Size4-Regular") : "\\ulcorner" === e ? (n = 9484, l = d = 32) : "\\urcorner" === e ? (n = 9488, l = d = 32) : "\\llcorner" === e ? (d = 9492, l = n = 32) : "\\lrcorner" === e && (n = 9496, l = n = 32);
        const u = _e(n, c),
            p = u.height + u.depth,
            h = _e(l, c),
            m = h.height + h.depth,
            f = _e(d, c),
            y = f.height + f.depth;
        let b = 0,
            g = 1;
        if (null !== s) {
            const e = _e(s, c);
            b = e.height + e.depth, g = 2
        }
        const v = p + y + b,
            k = Math.max(0, Math.ceil((t - v) / (g * m))),
            x = v + k * g * m;
        let w = .25;
        a && (w *= i.scalingFactor);
        const _ = x / 2 - w,
            S = [];
        S.push({
            box: new Ne(d, {
                fontFamily: c
            })
        }), S.push(-.008);
        const M = new Ne(l, {
            fontFamily: c
        });
        if (null === s)
            for (let e = 0; e < k; e++) S.push({
                box: M
            });
        else {
            for (let e = 0; e < k; e++) S.push({
                box: M
            });
            S.push(-.008), S.push({
                box: new Ne(s, {
                    fontFamily: c
                })
            }), S.push(-.008);
            for (let e = 0; e < k; e++) S.push({
                box: M
            })
        }
        S.push(-.008), S.push({
            box: new Ne(n, {
                fontFamily: c
            })
        });
        let L = "";
        "Size1-Regular" === c ? L = " delim-size1" : "Size4-Regular" === c && (L = " delim-size4");
        const C = new We({
            bottom: _,
            children: S
        }, {
            classes: L
        });
        return new Ne(C, {
            ...null != o ? o : {},
            classes: (null !== (r = null == o ? void 0 : o.classes) && void 0 !== r ? r : "") + " ML__delim-mult"
        })
    }
    const bt = new Set(["(", ")", "\\lparen", "\\rparen", "[", "]", "\\lbrack", "\\rbrack", "\\{", "\\}", "\\lbrace", "\\rbrace", "\\lfloor", "\\rfloor", "\\lceil", "\\rceil", "\\surd", "⌊", "⌋", "⌈", "⌉"]),
        gt = new Set(["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\mvert", "\\mid", "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache", "⟮", "⟯", "⎰", "⎱"]),
        vt = new Set(["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"]),
        kt = [0, 1.2, 1.8, 2.4, 3],
        xt = [{
            type: "small",
            mathstyle: "scriptscriptstyle"
        }, {
            type: "small",
            mathstyle: "scriptstyle"
        }, {
            type: "small",
            mathstyle: "textstyle"
        }, {
            type: "large",
            size: 1
        }, {
            type: "large",
            size: 2
        }, {
            type: "large",
            size: 3
        }, {
            type: "large",
            size: 4
        }],
        wt = [{
            type: "small",
            mathstyle: "scriptscriptstyle"
        }, {
            type: "small",
            mathstyle: "scriptscriptstyle"
        }, {
            type: "small",
            mathstyle: "textstyle"
        }, {
            type: "stack"
        }],
        _t = [{
            type: "small",
            mathstyle: "scriptscriptstyle"
        }, {
            type: "small",
            mathstyle: "scriptstyle"
        }, {
            type: "small",
            mathstyle: "textstyle"
        }, {
            type: "large",
            size: 1
        }, {
            type: "large",
            size: 2
        }, {
            type: "large",
            size: 3
        }, {
            type: "large",
            size: 4
        }, {
            type: "stack"
        }];

    function St(e, t, a, i, o, r) {
        var n;
        if (!t || 0 === t.length || "." === t) return Lt(o, e, e);
        let s;
        "<" === t || "\\lt" === t ? t = "\\langle" : ">" !== t && "\\gt" !== t || (t = "\\rangle"), s = vt.has(t) ? xt : bt.has(t) ? _t : wt;
        const l = function(e, t, a, i) {
                for (let r = {
                        "-4": 0,
                        "-3": 1,
                        0: 2
                    } [i.mathstyle.sizeDelta]; r < a.length && "stack" !== a[r].type; r++) {
                    const n = _e(e, "small" === (o = a[r]).type ? "Main-Regular" : "large" === o.type ? "Size" + o.size + "-Regular" : "Size4-Regular");
                    if (n.defaultMetrics) return {
                        type: "small",
                        mathstyle: "scriptstyle"
                    };
                    let s = n.height + n.depth;
                    if ("small" === a[r].type && ("scriptscriptstyle" === a[r].mathstyle ? s *= xe[Math.max(1, i.size - 2)] : "scriptstyle" === a[r].mathstyle && (s *= xe[Math.max(1, i.size - 1)])), s > t) return a[r]
                }
                var o;
                return a[a.length - 1]
            }(mt(t), a, s, o),
            d = new Ae(o, null == r ? void 0 : r.style, l.mathstyle);
        return "small" === l.type ? function(e, t, a, i) {
            const o = new Ne(mt(e), {
                fontFamily: "Main-Regular"
            }).wrap(t, i);
            return a && o.setTop(.25 * (1 - t.scalingFactor)), o
        }(t, d, i, {
            type: e,
            classes: "ML__small-delim " + (null !== (n = null == r ? void 0 : r.classes) && void 0 !== n ? n : "")
        }) : "large" === l.type ? ft(t, l.size, i, d, {
            ...r,
            type: e
        }) : yt(t, a, i, d, {
            ...r,
            type: e
        })
    }

    function Mt(e, t, a, i, o, r) {
        if ("." === t) return Lt(o, e, null == r ? void 0 : r.classes);
        const n = .25 * o.scalingFactor,
            s = Math.max(a - n, i + n);
        return St(e, t, Math.max(s / 500 * 901, 2 * s - .5), !0, o, r)
    }

    function Lt(e, t, a) {
        const i = new Ae(e, void 0, "textstyle");
        return new Ne(null, {
            classes: " nulldelimiter " + (null != a ? a : ""),
            type: t
        }).wrap(i)
    }
    class Ct extends lt {
        static fromJson(e, t) {
            return new Ct(e.command, t, e)
        }
        toJson() {
            const e = {};
            return this.skipBoundary || (e.skipBoundary = !1), this.subsupPlacement && (e.subsupPlacement = this.subsupPlacement), this.svgAbove && (e.svgAbove = this.svgAbove), this.svgBelow && (e.svgBelow = this.svgBelow), this.svgBody && (e.svgBody = this.svgBody), "mord" !== this.boxType && (e.boxType = this.boxType), this.paddedBody && (e.paddedBody = !0), this.paddedLabels && (e.paddedLabels = !0), {
                ...super.toJson(),
                ...e
            }
        }
        render(e) {
            let t = this.svgBody ? He(this.svgBody) : lt.createBox(e, this.body, {
                newList: !0
            });
            const a = new Ae(e, this.style, "scriptstyle");
            let i = null;
            this.svgAbove ? i = He(this.svgAbove) : this.above && (i = lt.createBox(a, this.above, {
                newList: !0
            }));
            let o = null;
            this.svgBelow ? o = He(this.svgBelow) : this.below && (o = lt.createBox(a, this.below, {
                newList: !0
            })), this.paddedBody && (t = new Ne([Lt(e, "mopen"), t, Lt(e, "mclose")], {
                newList: !0
            }));
            let r = function(e, t) {
                if (!t.base) return null;
                if (!t.above && !t.below) {
                    const e = new Ne(t.base, {
                        type: t.type
                    });
                    return e.setStyle("position", "relative"), e
                }
                let a = 0;
                t.above && (a = -t.above.depth + e.metrics.bigOpSpacing2);
                let i = null;
                const o = t.base,
                    r = ["ML__center"];
                if (t.paddedAboveBelow && r.push("ML__label_padding"), t.below && t.above) {
                    const n = e.metrics.bigOpSpacing5 + t.below.height + t.below.depth + o.depth + 0;
                    i = new We({
                        bottom: n,
                        children: [e.metrics.bigOpSpacing5, {
                            box: t.below,
                            classes: r
                        }, {
                            box: o,
                            classes: ["ML__center"]
                        }, a, {
                            box: t.above,
                            classes: r
                        }, e.metrics.bigOpSpacing5]
                    })
                } else t.below ? i = new We({
                    top: o.height - 0,
                    children: [e.metrics.bigOpSpacing5, {
                        box: t.below,
                        classes: r
                    }, {
                        box: o,
                        classes: ["ML__center"]
                    }]
                }) : t.above && (i = new We({
                    bottom: o.depth + 0,
                    children: [{
                        box: o,
                        classes: ["ML__center"]
                    }, a, {
                        box: t.above,
                        classes: r
                    }, e.metrics.bigOpSpacing5]
                }));
                return new Ne(i, {
                    type: t.type
                })
            }(e, {
                base: t,
                above: i,
                below: o,
                type: "mbin" === this.boxType || "mrel" === this.boxType ? this.boxType : "mord",
                paddedAboveBelow: this.paddedLabels
            });
            return r ? (r = "over-under" === this.subsupPlacement ? this.attachLimits(e, {
                base: r,
                type: r.type
            }) : this.attachSupsub(e, {
                base: r
            }), this.caret && (r.caret = this.caret), this.bind(e, r)) : null
        }
        constructor(e, t, a) {
            var i, o, r, n;
            super("overunder", t, {
                command: e,
                serialize: a.serialize,
                style: a.style
            }), this.skipBoundary = null === (i = a.skipBoundary) || void 0 === i || i, this.subsupPlacement = a.supsubPlacement, this.body = a.body, this.svgAbove = a.svgAbove, this.svgBelow = a.svgBelow, this.svgBody = a.svgBody, this.above = a.above, this.below = a.below, this.boxType = null !== (o = a.boxType) && void 0 !== o ? o : "mord", this.paddedBody = null !== (r = a.paddedBody) && void 0 !== r && r, this.paddedLabels = null !== (n = a.paddedLabels) && void 0 !== n && n
        }
    }
    class At extends lt {
        static fromJson(e, t) {
            return new At(e.body, t, e)
        }
        toJson() {
            const e = {};
            return this.mathstyleName && (e.mathstyleName = this.mathstyleName), this.latexOpen && (e.latexOpen = this.latexOpen), this.latexClose && (e.latexClose = this.latexClose), this.cssId && (e.cssId = this.cssId), this.htmlData && (e.htmlData = this.htmlData), this.htmlStyle && (e.htmlStyle = this.htmlStyle), this.customClass && (e.customClass = this.customClass), this.boxType && (e.boxType = this.boxType), this.captureSelection && (e.captureSelection = !0), this.changeMode && (e.changeMode = !0), {
                ...super.toJson(),
                ...e
            }
        }
        render(e) {
            const t = new Ae(e, this.style, this.mathstyleName),
                a = lt.createBox(t, this.body, {
                    type: this.boxType,
                    classes: this.customClass,
                    mode: this.mode,
                    style: {
                        backgroundColor: this.style.backgroundColor
                    },
                    newList: !this.boxType
                });
            return a ? (this.cssId && (a.cssId = this.cssId), this.htmlData && (a.htmlData = this.htmlData), this.htmlStyle && (a.htmlStyle = this.htmlStyle), this.caret && (a.caret = this.caret), this.bind(e, a)) : null
        }
        serialize(e) {
            let t = this.bodyToLatex(e);
            return "string" == typeof this.latexOpen && (t = this.latexOpen + t + this.latexClose), this.htmlData && (t = `\\htmlData{${this.htmlData}}{${t}}`), this.htmlStyle && (t = `\\htmlStyle{${this.htmlStyle}}{${t}}`), this.customClass && (t = `\\class{${this.customClass}}{${t}}`), this.cssId && (t = `\\cssId{${this.cssId}}{${t}}`), t
        }
        constructor(e, t, a) {
            var i, o, r;
            super("group", t, {
                command: null == a ? void 0 : a.command,
                mode: null !== (i = null == a ? void 0 : a.mode) && void 0 !== i ? i : "math",
                serialize: null == a ? void 0 : a.serialize,
                style: null == a ? void 0 : a.style
            }), this.body = e, this.mathstyleName = null == a ? void 0 : a.mathstyleName, this.latexOpen = null == a ? void 0 : a.latexOpen, this.latexClose = null == a ? void 0 : a.latexClose, this.cssId = null == a ? void 0 : a.cssId, this.htmlData = null == a ? void 0 : a.htmlData, this.htmlStyle = null == a ? void 0 : a.htmlStyle, this.customClass = null == a ? void 0 : a.customClass, this.boxType = null == a ? void 0 : a.boxType, this.skipBoundary = !0, this.captureSelection = null !== (o = null == a ? void 0 : a.captureSelection) && void 0 !== o && o, this.changeMode = null !== (r = null == a ? void 0 : a.changeMode) && void 0 !== r && r, this.displayContainsHighlight = !1, e && 1 === e.length && "," === e[0].command && (this.captureSelection = !0)
        }
    }
    class Dt extends lt {
        static fromJson(e, t) {
            return new Dt(e.command, e.style, t, e.width)
        }
        toJson() {
            const e = {};
            return this.width && (e.width = this.width), {
                ...super.toJson(),
                ...e
            }
        }
        render(e) {
            var t;
            let a;
            if (this.width) a = new Ne(null, {
                classes: "mspace"
            }), a.left = Le(this.width.glue);
            else {
                const e = null !== (t = {
                    "\\qquad": "qquad",
                    "\\quad": "quad",
                    "\\enspace": "enspace",
                    "\\;": "thickspace",
                    "\\:": "mediumspace",
                    "\\,": "thinspace",
                    "\\!": "negativethinspace"
                } [this.command]) && void 0 !== t ? t : "mediumspace";
                a = new Ne(null, {
                    classes: e
                })
            }
            return a = this.bind(e, a), this.caret && (a.caret = this.caret), a
        }
        serialize(e) {
            var t;
            let a = null !== (t = this.command) && void 0 !== t ? t : "";
            return "\\hspace" === this.command || "\\hspace*" === this.command ? Number.isFinite(this.width) ? a += `{${this.width}em'}` : a += "{0pt}" : Number.isFinite(this.width) && (a += ` ${this.width}em`), a
        }
        constructor(e, t, a, i) {
            super("spacing", a, {
                command: e,
                style: t
            }), this.width = i
        }
    }
    class Tt extends lt {
        static fromJson(e, t) {
            var a;
            return new Tt(null !== (a = e.variant) && void 0 !== a ? a : "", e.body, t, e)
        }
        toJson() {
            const e = super.toJson();
            return this.variant && (e.variant = this.variant), this.leftDelim && (e.leftDelim = this.leftDelim), this.rightDelim && (e.rightDelim = this.rightDelim), e
        }
        serialize(e) {
            var t, a;
            const i = this.matchingRightDelim();
            return "left...right" === this.variant ? at(["\\left" + (null !== (t = this.leftDelim) && void 0 !== t ? t : "."), this.bodyToLatex(e), "\\right" + i]) : "mleft...mright" === this.variant ? at(["\\mleft" + (null !== (a = this.leftDelim) && void 0 !== a ? a : "."), this.bodyToLatex(e), "\\mright" + i]) : at([this.leftDelim && "." !== this.leftDelim ? this.leftDelim : "", this.bodyToLatex(e), i])
        }
        matchingRightDelim() {
            var e, t;
            if (this.rightDelim && "?" !== this.rightDelim) return this.rightDelim;
            const a = null !== (e = this.leftDelim) && void 0 !== e ? e : ".";
            return null !== (t = pt[a]) && void 0 !== t ? t : a
        }
        render(e) {
            var t, a, i;
            const o = new Ae(e, this.style),
                r = new Ae(e, this.style, "textstyle"),
                n = null !== (t = lt.createBox(o, this.body, {
                    newList: !0
                })) && void 0 !== t ? t : new Ne(null, {
                    newList: !0
                }),
                s = n.height / r.scalingFactor,
                l = n.depth / r.scalingFactor,
                d = [];
            if (this.leftDelim && d.push(this.bind(r, Mt("mopen", this.leftDelim, s, l, r, {
                    classes: "ML__open" + (this.containsCaret ? " ML__contains-caret" : ""),
                    mode: this.mode,
                    style: this.style
                }))), n) {
                if (n.children)
                    for (let e = 0; e < n.children.length; e++) {
                        const t = n.children[e];
                        if (t.delim) {
                            const a = t.caret;
                            n.children[e] = this.bind(o, Mt("minner", t.delim, s, l, o)), n.children[e].caret = a
                        }
                    }
                d.push(n)
            }
            if (this.rightDelim) {
                let e = this.containsCaret ? " ML__contains-caret" : "",
                    t = this.rightDelim;
                "?" === t && (this.context.smartFence ? (t = this.matchingRightDelim(), e += " ML__smart-fence__close") : t = "."), d.push(this.bind(r, Mt("mclose", t, s, l, r, {
                    classes: e + " ML__close",
                    mode: this.mode,
                    style: this.style
                })))
            }
            const c = null !== (i = "mleft...mright" === this.variant || (null === (a = this.leftSibling) || void 0 === a ? void 0 : a.isFunction)) && void 0 !== i && i,
                u = new Ne(d, {
                    type: c ? "mclose" : "minner",
                    classes: "left-right"
                });
            return this.caret && (u.caret = this.caret), this.bind(o, u.wrap(o))
        }
        constructor(e, t, a, i) {
            super("leftright", a, {
                style: i.style,
                displayContainsHighlight: !0
            }), this.variant = e, this.body = t, this.leftDelim = i.leftDelim, this.rightDelim = i.rightDelim
        }
    }
    class zt extends lt {
        static fromJson(e, t) {
            const a = new zt(t, e);
            for (const t of rt) e[t] && a.setChildren(e[t], t);
            return a
        }
        toJson() {
            return super.toJson()
        }
        render(e) {
            var t;
            const a = this.leftSibling,
                i = new Ae(e, {
                    isPhantom: !0
                }),
                o = null !== (t = a.render(i)) && void 0 !== t ? t : new Ne(null),
                r = new Ne(null, {
                    height: o.height,
                    depth: o.depth
                });
            return this.attachSupsub(e, {
                base: r,
                isCharacterBox: a.isCharacterBox(),
                type: "supsub"
            })
        }
        serialize(e) {
            return this.supsubToLatex(e)
        }
        constructor(e, t) {
            super("msubsup", e, {
                style: null == t ? void 0 : t.style
            })
        }
    }
    class Bt extends lt {
        static fromJson(e, t) {
            return new Bt(t, e)
        }
        toJson() {
            const e = super.toJson();
            return this.placeholderId && (e.placeholderId = this.placeholderId), this.value === this.context.placeholderSymbol && delete e.value, this.defaultValue && (e.defaultValue = this.defaultValue.map((e => e.toJson()))), e
        }
        render(e) {
            if ("function" == typeof e.renderPlaceholder) return e.renderPlaceholder(e, this);
            let t = "";
            return this.caret && (t += "ML__placeholder-selected "), this.isSelected && (t += " ML__selected "), this.createBox(e, {
                classes: t
            })
        }
        serialize(e) {
            var t;
            let a = null !== (t = this.value) && void 0 !== t ? t : "";
            return a === this.context.placeholderSymbol && (a = ""), `\\placeholder${this.placeholderId?`[${this.placeholderId}]`:""}${this.defaultValue?`[${lt.serialize(this.defaultValue,e)}]`:""}{${a}}`
        }
        constructor(e, t) {
            var a;
            const i = (null == t ? void 0 : t.value) || e.placeholderSymbol;
            super("placeholder", e, {
                mode: null !== (a = null == t ? void 0 : t.mode) && void 0 !== a ? a : "math",
                style: null == t ? void 0 : t.style,
                value: i,
                command: "\\placeholder"
            }), this.captureSelection = !0, this.placeholderId = null == t ? void 0 : t.placeholderId, (null == t ? void 0 : t.default) && (this.defaultValue = null == t ? void 0 : t.default)
        }
    }
    class Kt extends lt {
        static fromJson(e, t) {
            return new Kt(e.command, t)
        }
        toJson() {
            return super.toJson()
        }
        render(e) {
            const t = this.createBox(e, {
                classes: "ML__error"
            });
            return this.caret && (t.caret = this.caret), t
        }
        constructor(e, t) {
            super("error", t, {
                value: e,
                command: e,
                mode: "math"
            }), this.verbatimLatex = e
        }
    }
    class qt extends lt {
        static fromJson(e, t) {
            return new qt(e.command, t, e)
        }
        toJson() {
            const e = super.toJson();
            return this.expand && (e.expand = !0), void 0 !== this.captureSelection && (e.captureSelection = this.captureSelection), this.macroArgs && (e.args = this.macroArgs), e
        }
        serialize(e) {
            return e.expandMacro && this.expand ? this.bodyToLatex(e) : this.command + this.macroArgs
        }
        render(e) {
            const t = lt.createBox(e, this.body);
            return t ? (this.caret && (t.caret = this.caret), this.bind(e, t)) : null
        }
        constructor(e, t, a) {
            var i, o;
            super("macro", t, {
                command: e
            }), this.body = a.body, void 0 === a.captureSelection ? a.args ? this.captureSelection = !1 : this.captureSelection = !0 : this.captureSelection = a.captureSelection, this.macroArgs = null !== (i = a.args) && void 0 !== i ? i : "", this.expand = null !== (o = a.expand) && void 0 !== o && o
        }
    }
    class $t extends lt {
        static fromJson(e, t) {
            return new $t(e.command, e.value, e.style, t)
        }
        toJson() {
            return super.toJson()
        }
        render(e) {
            const t = this.createBox(e);
            return this.caret && (t.caret = this.caret), t
        }
        serialize(e) {
            var t;
            return null !== (t = this.verbatimLatex) && void 0 !== t ? t : $("text", this.value.codePointAt(0))
        }
        constructor(e, t, a, i) {
            super("text", i, {
                command: e,
                mode: "text",
                displayContainsHighlight: !0
            }), this.value = t, this.verbatimLatex = t, this.applyStyle(a)
        }
    }

    function Et(e) {
        return !/^<({|}|\$|\$\$|space)>$/.test(e)
    }
    class Ot {
        get currentContext() {
            return this._currentParsingContext
        }
        get rootContext() {
            let e = this._currentParsingContext;
            for (; e.parent;) e = e.parent;
            return e
        }
        beginContext(e) {
            var t, a, i;
            const o = {
                parent: this.currentContext,
                mathlist: [],
                style: {
                    ...this.currentContext.style
                },
                parseMode: null !== (t = null == e ? void 0 : e.mode) && void 0 !== t ? t : this.currentContext.parseMode,
                mathstyle: null !== (a = null == e ? void 0 : e.mathstyle) && void 0 !== a ? a : this.currentContext.mathstyle,
                registers: null,
                tabular: null !== (i = null == e ? void 0 : e.tabular) && void 0 !== i && i
            };
            this._currentParsingContext = o
        }
        endContext() {
            this._currentParsingContext = this._currentParsingContext.parent
        }
        onError(e) {
            this.errors.push({
                before: it(this.tokens.slice(this.index, this.index + 10)),
                after: it(this.tokens.slice(Math.max(0, this.index - 10), this.index)),
                ...e
            })
        }
        get mathlist() {
            return this.currentContext.mathlist
        }
        set mathlist(e) {
            this.currentContext.mathlist = e
        }
        get parseMode() {
            return this.currentContext.parseMode
        }
        set parseMode(e) {
            this.currentContext.parseMode = e
        }
        get tabularMode() {
            return this.currentContext.tabular
        }
        get style() {
            let e = this.currentContext;
            for (; e;) {
                if (e.style) return e.style;
                e = e.parent
            }
            return {}
        }
        set style(e) {
            this.currentContext.style = e
        }
        getRegister(e) {
            var t, a, i;
            if (e.startsWith("global ")) return null !== (a = null === (t = this.rootContext.registers) || void 0 === t ? void 0 : t[e.slice(7)]) && void 0 !== a ? a : 0;
            let o = this.currentContext;
            for (; o;) {
                if (null === (i = o.registers) || void 0 === i ? void 0 : i[e]) return o.registers[e];
                o = o.parent
            }
            return 0
        }
        setRegister(e, t) {
            var a;
            if (e.startsWith("global ")) {
                e = e.slice(7);
                let i = this.currentContext;
                for (; i;)(null === (a = i.registers) || void 0 === a ? void 0 : a[e]) && delete i.registers[e], i = i.parent;
                this.rootContext.registers[e] = t
            } else this.currentContext.registers || (this.currentContext.registers = {}), this.currentContext.registers[e] = t
        }
        end() {
            return this.endCount++, this.index >= this.tokens.length || this.endCount > 1e3
        }
        get() {
            return this.endCount = 0, this.index < this.tokens.length ? this.tokens[this.index++] : ""
        }
        peek() {
            return this.tokens[this.index]
        }
        match(e) {
            return this.tokens[this.index] === e && (this.index++, !0)
        }
        lastSubsupAtom() {
            let e;
            if (this.mathlist.length > 0) {
                if (e = this.mathlist[this.mathlist.length - 1], "msubsup" === e.type) return e;
                if (void 0 !== e.subsupPlacement) return e
            }
            return e = new zt(this.context, {
                style: this.style
            }), this.mathlist.push(e), e
        }
        hasPattern(e) {
            return e.test(this.tokens[this.index])
        }
        hasInfixCommand() {
            var e;
            const {
                index: t
            } = this;
            if (t < this.tokens.length && this.tokens[t].startsWith("\\")) {
                const a = this.context.getDefinition(this.tokens[t], this.parseMode);
                return !(!a || "symbol" === a.definitionType) && !(a.ifMode && !a.ifMode.includes(this.parseMode)) && null !== (e = a.infix) && void 0 !== e && e
            }
            return !1
        }
        matchColumnSeparator() {
            const {
                index: e
            } = this;
            return !(!this.tabularMode || "&" !== this.tokens[e] || (this.index++, 0))
        }
        matchRowSeparator() {
            const {
                index: e
            } = this;
            return !(!this.tabularMode || "\\\\" !== this.tokens[e] && "\\cr" !== this.tokens[e] || (this.index++, 0))
        }
        placeholder() {
            var e;
            const t = null === (e = this.args) || void 0 === e ? void 0 : e.call(this, "?");
            return t ? Nt(t, this.context, {
                parseMode: this.parseMode,
                mathstyle: "textstyle"
            }) : [new Bt(this.context, {
                mode: this.parseMode,
                style: this.style
            })]
        }
        matchWhitespace() {
            let e = !1;
            for (; this.match("<space>");) e = !0;
            return e
        }
        skipUntilToken(e) {
            let t = this.tokens[this.index];
            for (; t && t !== e;) t = this.tokens[++this.index];
            t === e && this.index++
        }
        skipFiller() {
            let e = !1;
            do {
                const t = this.matchWhitespace(),
                    a = this.match("\\relax");
                e = !t && !a
            } while (!e)
        }
        matchKeyword(e) {
            const t = this.index;
            let a = this.end(),
                i = "";
            for (; !a;) {
                const t = this.get();
                Et(t) ? (i += t, a = this.end() || i.length >= e.length) : a = !0
            }
            const o = e.toUpperCase() === i.toUpperCase();
            return o || (this.index = t), o
        }
        scanString() {
            let e = "";
            for (; !this.end();)
                if (this.match("<space>")) e += " ";
                else {
                    const t = this.peek();
                    if ("]" === t) break;
                    if (Et(t)) e += this.get();
                    else {
                        if (!t.startsWith("\\")) break;
                        this.onError({
                            code: "unbalanced-braces"
                        }), e += this.get()
                    }
                } return e
        }
        scanBalancedString() {
            let e = "",
                t = this.end(),
                a = 1;
            for (; !t;) {
                if (this.match("<space>")) e += " ";
                else {
                    const t = this.get();
                    "<{>" === t ? (e += "{", a += 1) : "<}>" === t ? (a -= 1, a > 0 ? e += "}" : this.index -= 1) : e += "<$>" === t ? "$" : "<$$>" === t ? "$$" : t
                }
                t = 0 === a || this.end()
            }
            return e
        }
        matchLiteralArg() {
            var e;
            let t = "";
            if (this.match("<{>")) {
                let a = 1;
                for (; a > 0 && !this.end();) {
                    const i = this.get();
                    "<}>" === i ? (a -= 1, a > 0 && (t += "}")) : "<{>" === i ? (a += 1, t += "{") : t += null !== (e = {
                        "<space>": " ",
                        "<$$>": "$$",
                        "<$>": "$"
                    } [i]) && void 0 !== e ? e : i
                }
            }
            return t
        }
        scanNumber(e = !0) {
            var t, a;
            let i = !1,
                o = this.peek();
            for (;
                "<space>" === o || "+" === o || "-" === o;) this.get(), "-" === o && (i = !i), o = this.peek();
            e = Boolean(e);
            let r = 10,
                n = /\d/;
            if (this.match("'")) r = 8, n = /[0-7]/, e = !0;
            else if (this.match('"') || this.match("x")) r = 16, n = /[\dA-F]/, e = !0;
            else if (this.match("`")) return o = this.get(), o ? o.startsWith("\\") && 2 === o.length ? (i ? -1 : 1) * (null !== (t = o.codePointAt(1)) && void 0 !== t ? t : 0) : (i ? -1 : 1) * (null !== (a = o.codePointAt(0)) && void 0 !== a ? a : 0) : null;
            let s = "";
            for (; this.hasPattern(n);) s += this.get();
            if (!e && (this.match(".") || this.match(",")))
                for (s += "."; this.hasPattern(n);) s += this.get();
            const l = e ? Number.parseInt(s, r) : Number.parseFloat(s);
            return Number.isNaN(l) ? null : i ? -l : l
        }
        scanDimen() {
            var e, t, a;
            let i, o = this.scanNumber(!1);
            if (null === o) {
                if (!(null === (e = this.peek()) || void 0 === e ? void 0 : e.startsWith("\\"))) return null;
                o = 1
            }
            return this.matchWhitespace(), this.matchKeyword("pt") ? i = {
                dimension: o,
                unit: "pt"
            } : this.matchKeyword("mm") ? i = {
                dimension: o,
                unit: "mm"
            } : this.matchKeyword("cm") ? i = {
                dimension: o,
                unit: "cm"
            } : this.matchKeyword("ex") ? i = {
                dimension: o,
                unit: "ex"
            } : this.matchKeyword("px") ? i = {
                dimension: o,
                unit: "px"
            } : this.matchKeyword("em") ? i = {
                dimension: o,
                unit: "em"
            } : this.matchKeyword("bp") ? i = {
                dimension: o,
                unit: "bp"
            } : this.matchKeyword("dd") ? i = {
                dimension: o,
                unit: "dd"
            } : this.matchKeyword("pc") ? i = {
                dimension: o,
                unit: "pc"
            } : this.matchKeyword("in") ? i = {
                dimension: o,
                unit: "in"
            } : this.matchKeyword("mu") ? i = {
                dimension: o,
                unit: "mu"
            } : (null === (t = this.peek()) || void 0 === t ? void 0 : t.startsWith("\\")) ? (i = null !== (a = Rt(this.getRegister(this.get().slice(1)), this.context)) && void 0 !== a ? a : {
                dimension: 0
            }, i.dimension *= o) : (this.match("\\relax") || this.onError({
                code: "missing-unit"
            }), i = {
                dimension: o,
                unit: "pt"
            }), i
        }
        scanGlue() {
            const e = this.scanDimen();
            if (null === e) return null;
            const t = {
                glue: e
            };
            return this.matchWhitespace(), this.match("\\relax") || (this.matchKeyword("plus") && this.scanDimen(), this.matchWhitespace(), this.match("\\relax") || (this.matchWhitespace(), this.matchKeyword("minus") && this.scanDimen())), t
        }
        scanColspec() {
            this.matchWhitespace();
            const e = [];
            for (; !this.end() && "<}>" !== this.peek() && "]" !== this.peek();) {
                const t = this.get();
                "c" === t || "r" === t || "l" === t ? e.push({
                    align: t
                }) : "|" === t ? e.push({
                    separator: "solid"
                }) : ":" === t ? e.push({
                    separator: "dashed"
                }) : "@" === t && (this.match("<{>") && (this.beginContext({
                    mode: "math"
                }), e.push({
                    gap: this.parse((e => "<}>" === e))
                }), this.endContext()), this.match("<}>") || this.onError({
                    code: "unbalanced-braces"
                }))
            }
            return e
        }
        parseModeSet() {
            let e = "";
            if (this.match("\\(") && (e = "\\)"), !e && this.match("\\[") && (e = "\\]"), !e) return null;
            this.beginContext({
                mode: "math",
                mathstyle: "\\)" === e ? "textstyle" : "displaystyle"
            });
            const t = new At(this.parse((t => t === e)), this.context, {
                mathstyleName: "\\)" === e ? "textstyle" : "displaystyle",
                latexOpen: "\\]" === e ? "\\[" : "\\(",
                latexClose: e,
                boxType: "mord"
            });
            return this.match(e) || this.onError({
                code: "unbalanced-mode-shift"
            }), this.endContext(), t.hasEmptyBranch("body") ? null : t
        }
        parseModeShift() {
            let e = "";
            if (this.match("<$>") && (e = "<$>"), !e && this.match("<$$>") && (e = "<$$>"), !e) return null;
            this.beginContext({
                mode: "math",
                mathstyle: "textstyle"
            });
            const t = new At(this.parse((t => t === e)), this.context, {
                mathstyleName: "<$>" === e ? "textstyle" : "displaystyle",
                latexOpen: "<$>" === e ? "$ " : "$$ ",
                latexClose: "<$>" === e ? " $" : " $$"
            });
            return this.match(e) || this.onError({
                code: "unbalanced-mode-shift"
            }), this.endContext(), t.hasEmptyBranch("body") ? null : t
        }
        parseEnvironment() {
            if (!this.match("\\begin")) return null;
            const e = this.parseArgument("string");
            if (!e) return null;
            const t = function(e) {
                var t;
                return null !== (t = L[e]) && void 0 !== t ? t : null
            }(e);
            if (!t) return this.onError({
                code: "unknown-environment",
                arg: e
            }), null;
            const a = [];
            if (t.params)
                for (const i of t.params)
                    if (i.isOptional) a.push(this.parseOptionalArgument(i.type));
                    else {
                        const t = this.parseArgument(i.type);
                        t || this.onError({
                            code: "missing-argument",
                            arg: e
                        }), a.push(t)
                    } this.beginContext({
                tabular: t.tabular
            });
            const i = [],
                o = [];
            let r = [],
                n = !1;
            do {
                if (this.end() && (this.onError({
                        code: "unbalanced-environment",
                        arg: e
                    }), n = !0), !n && this.match("\\end") && (this.parseArgument("string") !== e && this.onError({
                        code: "unbalanced-environment",
                        arg: e
                    }), n = !0), !n)
                    if (this.matchColumnSeparator()) r.push(this.mathlist), this.mathlist = [];
                    else if (this.matchRowSeparator()) {
                    r.push(this.mathlist), this.mathlist = [];
                    let e = null;
                    this.matchWhitespace(), this.match("[") && (e = this.scanDimen(), this.matchWhitespace(), this.match("]")), o.push(null != e ? e : {
                        dimension: 0
                    }), i.push(r), r = []
                } else this.mathlist.push(...this.parse((e => "<}>" === e || "&" === e || "\\end" === e || "\\cr" === e || "\\\\" === e)))
            } while (!n);
            return r.push(this.mathlist), r.length > 0 && i.push(r), this.endContext(), t.createAtom(this.context, e, i, o, a)
        }
        parse(e) {
            this.beginContext(), e || (e = e => "<}>" === e);
            let t = "",
                a = null,
                i = [],
                o = null;
            const r = this.mathlist;
            for (this.mathlist = []; !this.end() && !e(this.peek());) this.hasInfixCommand() && !t ? (t = this.get(), a = this.context.getDefinition(t, "math"), a && (i = this.parseArguments(a)[1]), o = this.mathlist, this.mathlist = []) : this.parseToken();
            let n;
            return t ? (i.unshift(this.mathlist), this.mathlist = r, o && i.unshift(o), n = [a.createAtom(t, i, this.style, this.context)]) : (n = this.mathlist, this.mathlist = r), this.endContext(), n
        }
        parseGroup() {
            if (!this.match("<{>")) return null;
            const e = new At(this.parse((e => "<}>" === e)), this.context, {
                mode: this.parseMode,
                latexOpen: "{",
                latexClose: "}"
            });
            return this.match("<}>") || this.onError({
                code: "unbalanced-braces"
            }), e
        }
        scanSmartFence() {
            if (this.matchWhitespace(), !this.match("(")) return null;
            this.beginContext();
            let e = 1;
            for (; !this.end() && 0 !== e;) this.match("(") && (e += 1), this.match(")") && (e -= 1), 0 !== e && this.parseToken();
            0 === e && this.match(")");
            const t = new Tt("", this.mathlist, this.context, {
                leftDelim: "(",
                rightDelim: 0 === e ? ")" : "?"
            });
            return this.endContext(), t
        }
        scanDelim() {
            this.matchWhitespace();
            const e = this.get();
            if (!e) return this.onError({
                code: "unexpected-end-of-string"
            }), null;
            let t = ".";
            (e.startsWith("\\") || Et(e)) && (t = e);
            const a = this.context.getDefinition(t, "math");
            return a ? "function" === a.definitionType && a.ifMode && !a.ifMode.includes(this.parseMode) ? (this.onError({
                code: "unexpected-delimiter",
                arg: t
            }), null) : "symbol" !== a.definitionType || "mopen" !== a.type && "mclose" !== a.type ? /^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(t) ? t : (this.onError({
                code: "unexpected-delimiter",
                arg: t
            }), null) : t : (this.onError({
                code: "unknown-command",
                arg: t
            }), null)
        }
        parseLeftRight() {
            var e;
            if (this.match("\\right") || this.match("\\mright")) return this.onError({
                code: "unbalanced-braces"
            }), null;
            let t = "\\right";
            if (!this.match("\\left")) {
                if (!this.match("\\mleft")) return null;
                t = "\\mright"
            }
            const a = this.scanDelim();
            if (!a) return null;
            for (this.beginContext(); !this.end() && !this.match(t);) this.parseToken();
            const i = this.mathlist;
            this.endContext();
            const o = null !== (e = this.scanDelim()) && void 0 !== e ? e : ".";
            return new Tt("\\right" === t ? "left...right" : "mleft...mright", i, this.context, {
                leftDelim: a,
                rightDelim: o,
                style: this.style
            })
        }
        parseSupSub() {
            if ("math" !== this.parseMode) return !1;
            let e = this.peek();
            if ("^" !== e && "_" !== e && "'" !== e) return !1;
            for (;
                "^" === e || "_" === e || "'" === e;) {
                if (this.match("'")) this.match("'") ? this.lastSubsupAtom().addChild(new lt("mord", this.context, {
                    command: "\\doubleprime",
                    mode: "math",
                    value: "′′"
                }), "superscript") : this.lastSubsupAtom().addChild(new lt("mord", this.context, {
                    command: "\\prime",
                    mode: "math",
                    value: "′"
                }), "superscript");
                else if (this.match("^") || this.match("_")) {
                    const t = this.parseArgument("math");
                    t ? this.lastSubsupAtom().addChildren(t, "_" === e ? "subscript" : "superscript") : this.lastSubsupAtom().createBranch("_" === e ? "subscript" : "superscript")
                }
                e = this.peek()
            }
            return !0
        }
        parseLimits() {
            const e = this.match("\\limits"),
                t = !e && this.match("\\nolimits"),
                a = !t && !e && this.match("\\displaylimits");
            if (!e && !t && !a) return !1;
            const i = this.mathlist.length > 0 ? this.mathlist[this.mathlist.length - 1] : null;
            return !(null === i || "mop" !== i.type || (e ? (i.subsupPlacement = "over-under", i.explicitSubsupPlacement = !0, 0) : t ? (i.subsupPlacement = "adjacent", i.explicitSubsupPlacement = !0, 0) : !a || (i.subsupPlacement = "auto", i.explicitSubsupPlacement = !0, 0)))
        }
        parseArguments(e) {
            if (!(null == e ? void 0 : e.params)) return [void 0, []];
            let t;
            const a = [];
            let i = e.infix ? 2 : 0;
            for (; i < e.params.length;) {
                const o = e.params[i];
                if ("rest" === o.type) a.push(this.parse((e => "<}>" === e || "&" === e || "\\end" === e || "\\cr" === e || "\\\\" === e)));
                else if (o.isOptional) a.push(this.parseOptionalArgument(o.type));
                else if (o.type.endsWith("*")) t = o.type.slice(0, -1);
                else {
                    const e = this.parseArgument(o.type);
                    if (null !== e) a.push(e);
                    else switch (this.onError({
                            code: "missing-argument"
                        }), o.type) {
                        case "number":
                            a.push(0);
                            break;
                        case "dimen":
                            a.push({
                                dimension: 0,
                                unit: "pt"
                            });
                            break;
                        case "glue":
                            a.push({
                                glue: {
                                    dimension: 0,
                                    unit: "pt"
                                }
                            });
                            break;
                        case "string":
                        case "balanced-string":
                            a.push("");
                            break;
                        case "delim":
                            a.push(".");
                            break;
                        case "colspec":
                            a.push("llllllllll");
                            break;
                        default:
                            a.push(this.placeholder())
                    }
                }
                i += 1
            }
            return [t, a]
        }
        parseArgument(e) {
            var t, a;
            this.skipFiller(), "auto" === e && (e = this.parseMode);
            let i = null;
            const o = "<{>" === this.peek();
            if (!o) {
                if ("delim" === e) return null !== (t = this.scanDelim()) && void 0 !== t ? t : ".";
                if ("text" === e || "math" === e) {
                    this.beginContext();
                    const e = this.parseSimpleToken();
                    return this.endContext(), e
                }
            }
            if (o && this.get(), "text" === e || "math" === e) {
                this.beginContext({
                    mode: e
                });
                do {
                    this.mathlist.push(...this.parse())
                } while (!this.match("<}>") && !this.end())
            } else if (this.beginContext(), "string" === e ? i = this.scanString() : "balanced-string" === e ? i = this.scanBalancedString() : "number" === e ? i = this.scanNumber() : "colspec" === e ? i = this.scanColspec() : "dimen" === e ? i = this.scanDimen() : "glue" === e ? i = this.scanGlue() : "delim" === e && (i = null !== (a = this.scanDelim()) && void 0 !== a ? a : "."), o && this.skipUntilToken("<}>"), null === i) return this.endContext(), null;
            const r = this.mathlist;
            return this.endContext(), null != i ? i : r
        }
        parseOptionalArgument(e) {
            var t, a;
            if (e = "auto" === e ? this.parseMode : e, this.matchWhitespace(), !this.match("[")) return null;
            let i = null;
            for (; !this.end() && !this.match("]");)
                if ("string" === e) i = this.scanString();
                else if ("number" === e) i = this.scanNumber();
            else if ("dimen" === e) i = this.scanDimen();
            else if ("glue" === e) i = this.scanGlue();
            else if ("colspec" === e) i = this.scanColspec();
            else if ("bbox" === e) {
                const e = this.scanString().toLowerCase().trim().split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/),
                    o = {};
                for (const i of e) {
                    const e = null === (a = (t = this.context).backgroundColorMap) || void 0 === a ? void 0 : a.call(t, i);
                    if (e) o.backgroundcolor = e;
                    else {
                        const e = i.match(/^\s*([\d.]+)\s*([a-z]{2})/);
                        if (e) o.padding = e[0];
                        else {
                            const e = i.match(/^\s*border\s*:\s*(.*)/);
                            e && (o.border = e[1])
                        }
                    }
                }
                i = o
            } else "math" === e && (this.beginContext({
                mode: "math"
            }), i = this.mathlist.concat(this.parse((e => "]" === e))), this.endContext());
            return i
        }
        parseCommand(e) {
            var t, a, i, o, r, n, s;
            if ("\\placeholder" === e) {
                const e = this.parseOptionalArgument("string"),
                    a = this.parseOptionalArgument("math"),
                    i = null !== (t = this.parseArgument("string")) && void 0 !== t ? t : void 0;
                return [new Bt(this.context, {
                    mode: this.parseMode,
                    placeholderId: e,
                    value: i,
                    default: a,
                    style: this.style
                })]
            }
            let l = null;
            if ("\\char" === e) {
                const e = this.index;
                let t = Math.floor(null !== (a = this.scanNumber(!0)) && void 0 !== a ? a : Number.NaN);
                (!Number.isFinite(t) || t < 0 || t > 1114111) && (t = 10067);
                const i = "\\char" + it(this.tokens.slice(e, this.index));
                return l = new lt("math" === this.parseMode ? "mord" : "text", this.context, {
                    command: "\\char",
                    mode: this.parseMode,
                    value: String.fromCodePoint(t),
                    serialize: () => i
                }), l.verbatimLatex = i, [l]
            }
            if ("\\hskip" === e || "\\kern" === e) {
                const t = this.scanGlue();
                return t ? [new Dt(e, this.style, this.context, t)] : null
            }
            if (l = this.scanMacro(e), l) return [l];
            const d = this.context.getDefinition(e, this.parseMode);
            if (!d) return this.onError({
                code: "unknown-command",
                arg: e
            }), [new Kt(e, this.context)];
            const c = this.index;
            if ("symbol" === d.definitionType) {
                const t = {
                    ...this.style
                };
                d.variant && (t.variant = d.variant), l = new lt(null !== (i = d.type) && void 0 !== i ? i : "mop", this.context, {
                    command: e,
                    style: t,
                    value: String.fromCodePoint(d.codepoint),
                    mode: this.parseMode
                })
            } else {
                if (d.ifMode && !d.ifMode.includes(this.parseMode)) return [];
                const t = this.parseMode;
                d.applyMode && (this.parseMode = d.applyMode);
                const [a, i] = this.parseArguments(d);
                if (this.parseMode = t, !i) return null;
                if (d.applyMode && !d.applyStyle && !d.createAtom) return i[0];
                if (d.infix) return this.onError({
                    code: "too-many-infix-commands",
                    arg: e
                }), null;
                if ("function" == typeof d.createAtom) l = d.createAtom(e, i, this.style, this.context), a && (l.body = null !== (o = this.parseArgument(a)) && void 0 !== o ? o : void 0);
                else if ("function" == typeof d.applyStyle) {
                    const t = d.applyStyle(e, i, this.context),
                        o = this.parseMode;
                    if (d.applyMode && (this.parseMode = d.applyMode), a) {
                        const e = this.style;
                        this.style = {
                            ...this.style,
                            ...t
                        };
                        const i = this.parseArgument(a);
                        return this.style = e, this.parseMode = o, i
                    }
                    this.style = {
                        ...this.style,
                        ...t
                    }, this.parseMode = o
                } else l = new lt("mop", this.context, {
                    command: null !== (r = d.command) && void 0 !== r ? r : e,
                    style: {
                        ...this.style
                    },
                    value: e,
                    mode: null !== (n = d.applyMode) && void 0 !== n ? n : this.parseMode
                })
            }
            if (l instanceof lt && void 0 === l.verbatimLatex && !/^\\(llap|rlap|class|cssId|htmlData)$/.test(e) && (l.verbatimLatex = (null !== (s = l.command) && void 0 !== s ? s : "") + it(this.tokens.slice(c, this.index)), 0 === l.verbatimLatex.length && (l.verbatimLatex = void 0), l.isFunction && this.smartFence)) {
                const e = this.scanSmartFence();
                if (e) return [l, e]
            }
            return l ? [l] : null
        }
        parseLiteral(e) {
            const t = Be.createAtom(this.parseMode, e, this.context, {
                ...this.style
            });
            if (!t) return null;
            if (t.isFunction && this.smartFence) {
                const e = this.scanSmartFence();
                if (e) return [t, e]
            }
            return [t]
        }
        parseSimpleToken() {
            const e = this.get();
            return e ? "<space>" === e ? "text" === this.parseMode ? [new $t(" ", " ", this.style, this.context)] : null : e.startsWith("\\") ? this.parseCommand(e) : Et(e) ? this.parseLiteral(e) : ("<}>" === e ? this.onError({
                latex: "",
                code: "unbalanced-braces"
            }) : this.onError({
                latex: "",
                code: "unexpected-token",
                arg: e
            }), null) : null
        }
        scanMacro(e) {
            var t;
            const a = this.context.getMacro(e);
            if (!a) return null;
            const i = this.index,
                o = a.args,
                r = {
                    "?": null === (t = this.args) || void 0 === t ? void 0 : t.call(this, "?")
                };
            for (let e = 1; e <= o; e++) r[e] = this.matchLiteralArg();
            return new qt(e, this.context, {
                expand: a.expand,
                captureSelection: a.captureSelection,
                args: it(this.tokens.slice(i, this.index)),
                body: Nt(a.def, this.context, {
                    parseMode: this.parseMode,
                    args: e => r[e],
                    mathstyle: this.currentContext.mathstyle
                })
            })
        }
        parseToken() {
            var e, t, a, o;
            let r = null !== (o = null !== (a = null !== (t = null !== (e = this.parseEnvironment()) && void 0 !== e ? e : this.parseModeShift()) && void 0 !== t ? t : this.parseModeSet()) && void 0 !== a ? a : this.parseGroup()) && void 0 !== o ? o : this.parseLeftRight();
            if (null === r) {
                if (this.parseSupSub()) return !0;
                if (this.parseLimits()) return !0;
                r = this.parseSimpleToken()
            }
            return i(r) ? this.mathlist.push(...r) : r && this.mathlist.push(r), null !== r
        }
        constructor(e, t, a) {
            var i, o, r, n, s, l;
            this.index = 0, this.endCount = 0, this.tokens = e, this.context = t, this.errors = [], this.args = null !== (i = a.args) && void 0 !== i ? i : null, this.smartFence = null !== (o = a.smartFence) && void 0 !== o ? o : t.smartFence, this._currentParsingContext = {
                parent: void 0,
                mathlist: [],
                style: null !== (r = a.style) && void 0 !== r ? r : {},
                parseMode: null !== (n = a.parseMode) && void 0 !== n ? n : "math",
                mathstyle: null !== (s = a.mathstyle) && void 0 !== s ? s : "displaystyle",
                registers: null !== (l = a.registers) && void 0 !== l ? l : t.registers,
                tabular: !1
            }
        }
    }

    function Nt(e, t, a) {
        var i, o, r;
        const n = null !== (i = null == a ? void 0 : a.args) && void 0 !== i ? i : null,
            s = new Ot(tt(e, n), t, {
                args: n,
                mathstyle: null !== (o = null == a ? void 0 : a.mathstyle) && void 0 !== o ? o : "displaystyle",
                parseMode: null !== (r = null == a ? void 0 : a.parseMode) && void 0 !== r ? r : "math"
            }),
            l = [];
        for (; !s.end();) l.push(...s.parse());
        return l
    }

    function Pt(e, t, a) {
        var i;
        const o = new Ot(tt(e, null), t, {
            args: null,
            mathstyle: "displaystyle",
            parseMode: null !== (i = null == a ? void 0 : a.parseMode) && void 0 !== i ? i : "math"
        });
        for (; !o.end();) o.parse();
        return o.errors
    }

    function Ft(e, t, a) {
        return "object" == typeof e && "glue" in e ? e : "object" == typeof e && "dimension" in e ? {
            glue: e
        } : "number" == typeof e ? {
            glue: {
                dimension: e
            }
        } : new Ot(tt(e), t, {
            registers: a
        }).scanGlue()
    }

    function Rt(e, t, a) {
        return "number" == typeof e ? {
            dimension: e,
            unit: "pt"
        } : ("object" == typeof e && "glue" in e && (e = e.glue), "object" == typeof e && "dimension" in e ? e : new Ot(tt(e), t, {
            registers: a
        }).scanDimen())
    }
    class It extends lt {
        static fromJson(e, t) {
            return new It(e.command, e.body, t, e)
        }
        toJson() {
            return {
                ...super.toJson(),
                framecolor: this.framecolor,
                verbatimFramecolor: this.verbatimFramecolor,
                backgroundcolor: this.backgroundcolor,
                verbatimBackgroundcolor: this.verbatimBackgroundcolor,
                padding: this.padding,
                border: this.border
            }
        }
        render(e) {
            const t = new Ae(e, this.style),
                a = Le(t.getRegisterAsDimension("fboxsep")),
                i = void 0 === this.padding ? a : Le(Rt(this.padding, {
                    ...this.context,
                    registers: e.registers
                })),
                o = lt.createBox(e, this.body);
            if (!o) return null;
            o.setStyle("vertical-align", -o.height, "em");
            const r = new Ne(o, {
                    type: "mord"
                }),
                n = new Ne(null, {
                    classes: "ML__box"
                });
            n.height = r.height + i, n.depth = r.depth + i, n.setStyle("box-sizing", "border-box"), n.setStyle("position", "absolute"), n.setStyle("height", r.height + r.depth + 2 * i, "em"), 0 === i ? n.setStyle("width", "100%") : (n.setStyle("width", `calc(100% + ${2*i}em)`), n.setStyle("top", a, "em"), n.setStyle("left", -i, "em")), n.setStyle("z-index", "-1"), this.backgroundcolor && n.setStyle("background-color", this.backgroundcolor), this.framecolor && n.setStyle("border", `${Le(t.getRegisterAsDimension("fboxrule"))}em solid ${this.framecolor}`), this.border && n.setStyle("border", this.border), r.setStyle("display", "inline-block"), r.setStyle("height", o.height + o.depth, "em"), r.setStyle("vertical-align", -i, "em");
            const s = new Ne([n, r]);
            return s.setStyle("position", "relative"), s.setStyle("display", "inline-block"), s.setStyle("line-height", 0), s.height = r.height + i, s.depth = r.depth + i, s.left = i, s.right = i, s.setStyle("height", r.height + i, "em"), s.setStyle("top", r.depth - r.height, "em"), s.setStyle("vertical-align", r.depth + i, "em"), this.caret && (s.caret = this.caret), this.attachSupsub(e, {
                base: s
            })
        }
        constructor(e, t, a, i) {
            super("box", a, {
                command: e,
                serialize: i.serialize,
                style: i.style
            }), this.body = t, this.framecolor = i.framecolor, this.verbatimFramecolor = i.verbatimBackgroundcolor, this.backgroundcolor = i.backgroundcolor, this.verbatimBackgroundcolor = i.verbatimBackgroundcolor, this.padding = i.padding, this.border = i.border
        }
    }
    class Vt extends lt {
        static fromJson(e, t) {
            return new Vt(t, e.environmentName, e.array, e.rowGaps, e)
        }
        toJson() {
            const e = {
                ...super.toJson(),
                environmentName: this.environmentName,
                array: this.array.map((e => e.map((e => e.map((e => e.toJson())))))),
                rowGaps: this.rowGaps,
                columns: this.colFormat,
                colSeparationType: this.colSeparationType
            };
            return 1 !== this.arraystretch && (e.arraystretch = this.arraystretch), this.arraycolsep && (e.arraycolsep = this.arraycolsep), this.leftDelim && (e.leftDelim = this.leftDelim), this.rightDelim && (e.rightDelim = this.rightDelim), void 0 !== this.jot && (e.jot = this.jot), e
        }
        branch(e) {
            var t;
            if (st(e)) return null !== (t = this.array[e[0]][e[1]]) && void 0 !== t ? t : void 0
        }
        get branches() {
            const e = super.branches;
            return this.array.forEach(((t, a) => {
                this.array[a].forEach(((t, i) => {
                    this.array[a][i] && e.push([a, i])
                }))
            })), e
        }
        createBranch(e) {
            var t;
            return st(e) ? (this.isDirty = !0, null !== (t = this.branch(e)) && void 0 !== t ? t : []) : []
        }
        get rowCount() {
            return this.array.length
        }
        get colCount() {
            return this.array[0].length
        }
        get maxColumns() {
            return this.colFormat.filter((e => Boolean(e.align))).length
        }
        removeBranch(e) {
            if (nt(e)) return super.removeBranch(e);
            const t = this.branch(e);
            return this.array[e[0]][e[1]] = void 0, t.forEach((e => {
                e.parent = void 0, e.treeBranch = void 0
            })), t.shift(), this.isDirty = !0, t
        }
        get hasChildren() {
            return this.children.length > 0
        }
        get children() {
            const e = [];
            for (const t of this.array)
                for (const a of t)
                    if (a)
                        for (const t of a) e.push(...t.children), e.push(t);
            return [...e, ...super.children]
        }
        render(e) {
            var t, a, i, o, r;
            const n = new Ae(e, this.style, this.mathstyleName),
                s = n.getRegisterAsEm("arrayrulewidth"),
                l = n.getRegisterAsEm("arraycolsep"),
                d = n.getRegisterAsEm("doublerulesep"),
                c = null !== (t = this.arraystretch) && void 0 !== t ? t : 1;
            let u = "number" == typeof this.arraycolsep ? this.arraycolsep : l;
            "small" === this.colSeparationType && (u = new Ae(e, void 0, "scriptstyle").scalingFactor / e.scalingFactor * .2778);
            const p = 1.2 * c,
                h = .7 * p,
                m = .3 * p;
            let f = 0;
            const y = [];
            let b = 0;
            const g = this.array.length;
            for (let e = 0; e < g; ++e) {
                const t = this.array[e];
                b = Math.max(b, t.length);
                const o = new Ae(n, this.style, this.mathstyleName);
                let r = h / o.scalingFactor,
                    s = m / o.scalingFactor;
                const l = {
                    cells: [],
                    height: 0,
                    depth: 0,
                    pos: 0
                };
                for (const e of t) {
                    const t = null !== (a = lt.createBox(o, e, {
                        newList: !0
                    })) && void 0 !== a ? a : new Ne(null, {
                        newList: !0
                    });
                    s = Math.max(s, t.depth), r = Math.max(r, t.height), l.cells.push(t)
                }
                let d = null !== (i = Le(this.rowGaps[e])) && void 0 !== i ? i : 0;
                d > 0 && (d += m, s = Math.max(s, d), d = 0), void 0 !== this.jot && (s += this.jot), l.height = r, l.depth = s, f += r, l.pos = f, f += s + d, y.push(l)
            }
            const v = f / 2 + .25,
                k = [];
            for (let e = 0; e < b; e++) {
                const t = [];
                for (const a of y) {
                    const i = a.cells[e];
                    i.depth = a.depth, i.height = a.height, t.push({
                        box: i,
                        shift: a.pos - v
                    })
                }
                t.length > 0 && k.push(new We({
                    individualShift: t
                }))
            }
            const x = [];
            let w = !1,
                _ = !1,
                S = 0,
                M = !this.leftDelim;
            const {
                colFormat: L
            } = this;
            for (const t of L) {
                if ("align" in t && S >= k.length) break;
                if ("align" in t) w ? x.push(Ht(2 * u)) : (_ || M) && x.push(Ht(u)), x.push(new Ne(k[S], {
                    classes: "col-align-" + t.align
                })), S++, w = !0, _ = !1, M = !1;
                else if ("gap" in t) {
                    if ("number" == typeof t.gap) x.push(Ht(t.gap));
                    else {
                        const a = Wt(e, y, v, t.gap);
                        a && x.push(a)
                    }
                    w = !1, _ = !1, M = !1
                } else if ("separator" in t) {
                    const e = new Ne(null, {
                        classes: "vertical-separator"
                    });
                    e.setStyle("height", f, "em"), e.setStyle("border-right", `${s}em ${t.separator} currentColor`), e.setStyle("vertical-align", -(f - v), "em");
                    let a = 0;
                    _ ? a = d - s : w && (a = u - s), e.left = a, x.push(e), w = !1, _ = !0, M = !1
                }
            }
            w && !this.rightDelim && x.push(Ht(u));
            const C = new Ne(x, {
                classes: "mtable"
            });
            if (!(this.leftDelim && "." !== this.leftDelim || this.rightDelim && "." !== this.rightDelim)) return this.caret && (C.caret = this.caret), C;
            const A = C.height,
                D = C.depth,
                T = this.bind(e, new Ne([this.bind(e, Mt("mopen", null !== (o = this.leftDelim) && void 0 !== o ? o : ".", A, D, n)), C, this.bind(e, Mt("mclose", null !== (r = this.rightDelim) && void 0 !== r ? r : ".", A, D, n))], {
                    type: "mord"
                }));
            return T ? (this.caret && (T.caret = this.caret), this.attachSupsub(e, {
                base: T
            })) : null
        }
        serialize(e) {
            let t = "\\begin{" + this.environmentName + "}";
            if ("array" === this.environmentName) {
                if (t += "{", void 0 !== this.colFormat)
                    for (const e of this.colFormat) "align" in e ? t += e.align : "separator" in e && "solid" === e.separator ? t += "|" : "separator" in e && "dashed" === e.separator && (t += ":");
                t += "}"
            }
            for (let a = 0; a < this.array.length; a++) {
                for (let i = 0; i < this.array[a].length; i++) i > 0 && (t += " & "), t = at([t, lt.serialize(this.array[a][i], e)]);
                a < this.array.length - 1 && (t += " \\\\ ")
            }
            return t += "\\end{" + this.environmentName + "}", t
        }
        getCell(e, t) {
            return this.array[e][t]
        }
        setCell(e, t, a) {
            for (const a of this.array[e][t]) a.parent = void 0, a.treeBranch = void 0;
            let i = a;
            0 !== a.length && "first" === a[0].type || (i = [new lt("first", this.context, {
                mode: this.mode
            }), ...a]), this.array[e][t] = i;
            for (const a of i) a.parent = this, a.treeBranch = [e, t];
            this.isDirty = !0
        }
        addRowBefore(e) {
            const t = [];
            for (let e = 0; e < this.colCount; e++) t.push(jt(this));
            this.array.splice(e, 0, t);
            for (let t = e; t < this.rowCount; t++)
                for (let e = 0; e < this.colCount; e++) {
                    const a = this.array[t][e];
                    if (a)
                        for (const i of a) i.treeBranch = [t, e]
                }
            this.isDirty = !0
        }
        addRowAfter(e) {
            const t = [];
            for (let e = 0; e < this.colCount; e++) t.push(jt(this));
            this.array.splice(e + 1, 0, t);
            for (let t = e + 1; t < this.rowCount; t++)
                for (let e = 0; e < this.colCount; e++) {
                    const a = this.array[t][e];
                    if (a)
                        for (const i of a) i.treeBranch = [t, e]
                }
            this.isDirty = !0
        }
        removeRow(e) {
            const t = this.array.splice(e, 1);
            for (const e of t)
                for (const t of e)
                    if (t)
                        for (const e of t) e.parent = void 0, e.treeBranch = void 0;
            for (let t = e; t < this.rowCount; t++)
                for (let e = 0; e < this.colCount; e++) {
                    const a = this.array[t][e];
                    if (a)
                        for (const i of a) i.treeBranch = [t, e]
                }
            this.isDirty = !0
        }
        addColumnBefore(e) {
            for (const t of this.array) t.splice(e, 0, jt(this));
            for (let t = 0; t < this.rowCount; t++)
                for (let a = e; a < this.colCount; a++) {
                    const e = this.array[t][a];
                    if (e)
                        for (const i of e) i.treeBranch = [t, a]
                }
            this.isDirty = !0
        }
        addColumnAfter(e) {
            for (const t of this.array) t.splice(e + 1, 0, jt(this));
            for (let t = 0; t < this.rowCount; t++)
                for (let a = e + 1; a < this.colCount; a++) {
                    const e = this.array[t][a];
                    if (e)
                        for (const i of e) i.treeBranch = [t, a]
                }
            this.isDirty = !0
        }
        addColumn() {
            this.addColumnAfter(this.colCount - 1)
        }
        removeColumn(e) {
            for (const t of this.array) {
                const a = t.splice(e, 1);
                for (const e of a)
                    if (e)
                        for (const t of e) t.parent = void 0, t.treeBranch = void 0
            }
            for (let t = 0; t < this.rowCount; t++)
                for (let a = e; a < this.colCount; a++) {
                    const e = this.array[t][a];
                    if (e)
                        for (const i of e) i.treeBranch = [t, a]
                }
            this.isDirty = !0
        }
        get cells() {
            const e = [];
            for (const t of this.array)
                for (const a of t) a && e.push(a);
            return e
        }
        constructor(e, t, a, i, o = {}) {
            var r, n;
            super("array", e), this.environmentName = t, this.rowGaps = i, o.mathstyleName && (this.mathstyleName = o.mathstyleName), o.columns && (0 === o.columns.length ? this.colFormat = [{
                align: "l"
            }] : this.colFormat = o.columns), this.colFormat || (this.colFormat = [{
                align: "l"
            }, {
                align: "l"
            }, {
                align: "l"
            }, {
                align: "l"
            }, {
                align: "l"
            }, {
                align: "l"
            }, {
                align: "l"
            }, {
                align: "l"
            }, {
                align: "l"
            }, {
                align: "l"
            }]), this.array = function(e, t, a, i) {
                let o = 0;
                for (const e of i) "align" in e && (o += 1);
                let r = 0;
                const n = [];
                for (const i of a) {
                    let a = 0;
                    for (r = Math.max(r, Math.min(i.length, o)); a < i.length;) {
                        const r = [],
                            s = Math.min(i.length, a + o);
                        for (; a < s;) 0 === i[a].length ? r.push([new lt("first", e, {
                            mode: t.mode
                        })]) : "first" !== i[a][0].type ? r.push([new lt("first", e, {
                            mode: t.mode
                        }), ...i[a]]) : r.push(i[a]), a += 1;
                        n.push(r)
                    }
                }
                1 === n[n.length - 1].length && 0 === n[n.length - 1][0].length && n.pop();
                const s = [];
                for (const a of n) {
                    if (a.length !== r)
                        for (let i = a.length; i < r; i++) a.push([new lt("first", e, {
                            mode: t.mode
                        }), new Bt(e)]);
                    s.push(a)
                }
                let l = 0,
                    d = 0;
                for (const e of s) {
                    d = 0;
                    for (const a of e) {
                        for (const e of a) e.parent = t, e.treeBranch = [l, d];
                        d += 1
                    }
                    l += 1
                }
                return t.isDirty = !0, s
            }(e, this, a, this.colFormat), o.leftDelim && (this.leftDelim = o.leftDelim), o.rightDelim && (this.rightDelim = o.rightDelim), void 0 !== o.jot && (this.jot = o.jot), o.arraycolsep && (this.arraycolsep = o.arraycolsep), this.colSeparationType = o.colSeparationType, this.arraystretch = null !== (r = o.arraystretch) && void 0 !== r ? r : 1, this.minColumns = null !== (n = o.minColumns) && void 0 !== n ? n : 1
        }
    }

    function jt(e) {
        const t = new lt("first", e.context, {
            mode: e.mode
        });
        t.parent = e;
        const a = new Bt(e.context, {
            mode: e.mode
        });
        return a.parent = e, [t, a]
    }

    function Ht(e) {
        const t = new Ne(null, {
            classes: "arraycolsep"
        });
        return t.width = e, t
    }

    function Wt(e, t, a, i) {
        if (!i) return null;
        const o = [];
        for (const r of t) {
            const t = lt.createBox(e, i, {
                newList: !0
            });
            t && (t.depth = r.depth, t.height = r.height, o.push({
                box: t,
                shift: r.pos - a
            }))
        }
        return new We({
            individualShift: o
        }).wrap(e)
    }
    class Jt extends lt {
        static fromJson(e, t) {
            return new Jt(e.value, t, e)
        }
        toJson() {
            return super.toJson()
        }
        get computedStyle() {
            return {}
        }
        render(e) {
            const t = new Ne(this.value, {
                classes: "ML__composition",
                type: "composition"
            });
            return this.bind(e, t), this.caret && (t.caret = this.caret), t
        }
        serialize(e) {
            return ""
        }
        constructor(e, t, a) {
            var i;
            super("composition", t, {
                mode: null !== (i = null == a ? void 0 : a.mode) && void 0 !== i ? i : "math",
                value: e
            })
        }
    }
    class Ut extends lt {
        static fromJson(e, t) {
            return new Ut(e.command, e.arg, t)
        }
        toJson() {
            return {
                ...super.toJson(),
                arg: this.arg
            }
        }
        render(e) {
            const t = lt.createBox(e, this.body, {
                type: "chem",
                newList: !0
            });
            return this.caret && (t.caret = this.caret), this.bind(e, t)
        }
        serialize(e) {
            return this.verbatimLatex
        }
        constructor(e, t, a) {
            super("chem", a, {
                command: e,
                mode: "math"
            });
            const i = Gt.go(Xt.go(t, "\\pu" === e ? "pu" : "ce"), !1);
            this.body = Nt(i, a), this.verbatimLatex = e + "{" + t + "}", this.arg = t, this.captureSelection = !0
        }
    }
    V(["ce", "pu"], "{chemformula:balanced-string}", {
        createAtom: (e, t, a, i) => new Ut(e, t[0], i)
    });
    var Xt = {
        go: function(e, t) {
            if (!e) return [];
            void 0 === t && (t = "ce");
            var a, i = "0",
                o = {
                    parenthesisLevel: 0
                };
            e = (e = (e = e.replace(/\n/g, " ")).replace(/[\u2212\u2013\u2014\u2010]/g, "-")).replace(/[\u2026]/g, "...");
            for (var r = 10, n = [];;) {
                a !== e ? (r = 10, a = e) : r--;
                var s = Xt.stateMachines[t],
                    l = s.transitions[i] || s.transitions["*"];
                e: for (var d = 0; d < l.length; d++) {
                    var c = Xt.patterns.match_(l[d].pattern, e);
                    if (c) {
                        for (var u = l[d].task, p = 0; p < u.action_.length; p++) {
                            var h;
                            if (s.actions[u.action_[p].type_]) h = s.actions[u.action_[p].type_](o, c.match_, u.action_[p].option);
                            else {
                                if (!Xt.actions[u.action_[p].type_]) throw ["MhchemBugA", "mhchem bug A. Please report. (" + u.action_[p].type_ + ")"];
                                h = Xt.actions[u.action_[p].type_](o, c.match_, u.action_[p].option)
                            }
                            Xt.concatArray(n, h)
                        }
                        if (i = u.nextState || i, !(e.length > 0)) return n;
                        if (u.revisit || (e = c.remainder), !u.toContinue) break e
                    }
                }
                if (r <= 0) throw ["MhchemBugU", "mhchem bug U. Please report."]
            }
        },
        concatArray: function(e, t) {
            if (t)
                if (Array.isArray(t))
                    for (var a = 0; a < t.length; a++) e.push(t[a]);
                else e.push(t)
        },
        patterns: {
            patterns: {
                empty: /^$/,
                else: /^./,
                else2: /^./,
                space: /^\s/,
                "space A": /^\s(?=[A-Z\\$])/,
                space$: /^\s$/,
                "a-z": /^[a-z]/,
                x: /^x/,
                x$: /^x$/,
                i$: /^i$/,
                letters: /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
                "\\greek": /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
                "one lowercase latin letter $": /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
                "$one lowercase latin letter$ $": /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
                "one lowercase greek letter $": /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
                digits: /^[0-9]+/,
                "-9.,9": /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
                "-9.,9 no missing 0": /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
                "(-)(9.,9)(e)(99)": function(e) {
                    var t = e.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
                    return t && t[0] ? {
                        match_: t.splice(1),
                        remainder: e.substr(t[0].length)
                    } : null
                },
                "(-)(9)^(-9)": function(e) {
                    var t = e.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);
                    return t && t[0] ? {
                        match_: t.splice(1),
                        remainder: e.substr(t[0].length)
                    } : null
                },
                "state of aggregation $": function(e) {
                    var t = Xt.patterns.findObserveGroups(e, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");
                    if (t && t.remainder.match(/^($|[\s,;\)\]\}])/)) return t;
                    var a = e.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);
                    return a ? {
                        match_: a[0],
                        remainder: e.substr(a[0].length)
                    } : null
                },
                "_{(state of aggregation)}$": /^_\{(\([a-z]{1,3}\))\}/,
                "{[(": /^(?:\\\{|\[|\()/,
                ")]}": /^(?:\)|\]|\\\})/,
                ", ": /^[,;]\s*/,
                ",": /^[,;]/,
                ".": /^[.]/,
                ". ": /^([.\u22C5\u00B7\u2022])\s*/,
                "...": /^\.\.\.(?=$|[^.])/,
                "* ": /^([*])\s*/,
                "^{(...)}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "^{", "", "", "}")
                },
                "^($...$)": function(e) {
                    return Xt.patterns.findObserveGroups(e, "^", "$", "$", "")
                },
                "^a": /^\^([0-9]+|[^\\_])/,
                "^\\x{}{}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", !0)
                },
                "^\\x{}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "^", /^\\[a-zA-Z]+\{/, "}", "")
                },
                "^\\x": /^\^(\\[a-zA-Z]+)\s*/,
                "^(-1)": /^\^(-?\d+)/,
                "'": /^'/,
                "_{(...)}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "_{", "", "", "}")
                },
                "_($...$)": function(e) {
                    return Xt.patterns.findObserveGroups(e, "_", "$", "$", "")
                },
                _9: /^_([+\-]?[0-9]+|[^\\])/,
                "_\\x{}{}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", !0)
                },
                "_\\x{}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "_", /^\\[a-zA-Z]+\{/, "}", "")
                },
                "_\\x": /^_(\\[a-zA-Z]+)\s*/,
                "^_": /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
                "{}": /^\{\}/,
                "{...}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "", "{", "}", "")
                },
                "{(...)}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "{", "", "", "}")
                },
                "$...$": function(e) {
                    return Xt.patterns.findObserveGroups(e, "", "$", "$", "")
                },
                "${(...)}$": function(e) {
                    return Xt.patterns.findObserveGroups(e, "${", "", "", "}$")
                },
                "$(...)$": function(e) {
                    return Xt.patterns.findObserveGroups(e, "$", "", "", "$")
                },
                "=<>": /^[=<>]/,
                "#": /^[#\u2261]/,
                "+": /^\+/,
                "-$": /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,
                "-9": /^-(?=[0-9])/,
                "- orbital overlap": /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
                "-": /^-/,
                "pm-operator": /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
                operator: /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
                arrowUpDown: /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
                "\\bond{(...)}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "\\bond{", "", "", "}")
                },
                "->": /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
                CMT: /^[CMT](?=\[)/,
                "[(...)]": function(e) {
                    return Xt.patterns.findObserveGroups(e, "[", "", "", "]")
                },
                "1st-level escape": /^(&|\\\\|\\hline)\s*/,
                "\\,": /^(?:\\[,\ ;:])/,
                "\\x{}{}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", !0)
                },
                "\\x{}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "", /^\\[a-zA-Z]+\{/, "}", "")
                },
                "\\ca": /^\\ca(?:\s+|(?![a-zA-Z]))/,
                "\\x": /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
                orbital: /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,
                others: /^[\/~|]/,
                "\\frac{(...)}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "\\frac{", "", "", "}", "{", "", "", "}")
                },
                "\\overset{(...)}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "\\overset{", "", "", "}", "{", "", "", "}")
                },
                "\\underset{(...)}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "\\underset{", "", "", "}", "{", "", "", "}")
                },
                "\\underbrace{(...)}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "\\underbrace{", "", "", "}_", "{", "", "", "}")
                },
                "\\color{(...)}0": function(e) {
                    return Xt.patterns.findObserveGroups(e, "\\color{", "", "", "}")
                },
                "\\color{(...)}{(...)}1": function(e) {
                    return Xt.patterns.findObserveGroups(e, "\\color{", "", "", "}", "{", "", "", "}")
                },
                "\\color(...){(...)}2": function(e) {
                    return Xt.patterns.findObserveGroups(e, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}")
                },
                "\\ce{(...)}": function(e) {
                    return Xt.patterns.findObserveGroups(e, "\\ce{", "", "", "}")
                },
                oxidation$: /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
                "d-oxidation$": /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
                "roman numeral": /^[IVX]+/,
                "1/2$": /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
                amount: function(e) {
                    var t;
                    if (t = e.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/)) return {
                        match_: t[0],
                        remainder: e.substr(t[0].length)
                    };
                    var a = Xt.patterns.findObserveGroups(e, "", "$", "$", "");
                    return a && (t = a.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/)) ? {
                        match_: t[0],
                        remainder: e.substr(t[0].length)
                    } : null
                },
                amount2: function(e) {
                    return this.amount(e)
                },
                "(KV letters),": /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
                formula$: function(e) {
                    if (e.match(/^\([a-z]+\)$/)) return null;
                    var t = e.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
                    return t ? {
                        match_: t[0],
                        remainder: e.substr(t[0].length)
                    } : null
                },
                uprightEntities: /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
                "/": /^\s*(\/)\s*/,
                "//": /^\s*(\/\/)\s*/,
                "*": /^\s*[*.]\s*/
            },
            findObserveGroups: function(e, t, a, i, o, r, n, s, l, d) {
                var c = function(e, t) {
                        if ("string" == typeof t) return 0 !== e.indexOf(t) ? null : t;
                        var a = e.match(t);
                        return a ? a[0] : null
                    },
                    u = c(e, t);
                if (null === u) return null;
                if (e = e.substr(u.length), null === (u = c(e, a))) return null;
                var p = function(e, t, a) {
                    for (var i = 0; t < e.length;) {
                        var o = e.charAt(t),
                            r = c(e.substr(t), a);
                        if (null !== r && 0 === i) return {
                            endMatchBegin: t,
                            endMatchEnd: t + r.length
                        };
                        if ("{" === o) i++;
                        else if ("}" === o) {
                            if (0 === i) throw ["ExtraCloseMissingOpen", "Extra close brace or missing open brace"];
                            i--
                        }
                        t++
                    }
                    return null
                }(e, u.length, i || o);
                if (null === p) return null;
                var h = e.substring(0, i ? p.endMatchEnd : p.endMatchBegin);
                if (r || n) {
                    var m = this.findObserveGroups(e.substr(p.endMatchEnd), r, n, s, l);
                    if (null === m) return null;
                    var f = [h, m.match_];
                    return {
                        match_: d ? f.join("") : f,
                        remainder: m.remainder
                    }
                }
                return {
                    match_: h,
                    remainder: e.substr(p.endMatchEnd)
                }
            },
            match_: function(e, t) {
                var a = Xt.patterns.patterns[e];
                if (void 0 === a) throw ["MhchemBugP", "mhchem bug P. Please report. (" + e + ")"];
                if ("function" == typeof a) return Xt.patterns.patterns[e](t);
                var i = t.match(a);
                return i ? {
                    match_: i[2] ? [i[1], i[2]] : i[1] ? i[1] : i[0],
                    remainder: t.substr(i[0].length)
                } : null
            }
        },
        actions: {
            "a=": function(e, t) {
                e.a = (e.a || "") + t
            },
            "b=": function(e, t) {
                e.b = (e.b || "") + t
            },
            "p=": function(e, t) {
                e.p = (e.p || "") + t
            },
            "o=": function(e, t) {
                e.o = (e.o || "") + t
            },
            "q=": function(e, t) {
                e.q = (e.q || "") + t
            },
            "d=": function(e, t) {
                e.d = (e.d || "") + t
            },
            "rm=": function(e, t) {
                e.rm = (e.rm || "") + t
            },
            "text=": function(e, t) {
                e.text_ = (e.text_ || "") + t
            },
            insert: function(e, t, a) {
                return {
                    type_: a
                }
            },
            "insert+p1": function(e, t, a) {
                return {
                    type_: a,
                    p1: t
                }
            },
            "insert+p1+p2": function(e, t, a) {
                return {
                    type_: a,
                    p1: t[0],
                    p2: t[1]
                }
            },
            copy: function(e, t) {
                return t
            },
            rm: function(e, t) {
                return {
                    type_: "rm",
                    p1: t || ""
                }
            },
            text: function(e, t) {
                return Xt.go(t, "text")
            },
            "{text}": function(e, t) {
                var a = ["{"];
                return Xt.concatArray(a, Xt.go(t, "text")), a.push("}"), a
            },
            "tex-math": function(e, t) {
                return Xt.go(t, "tex-math")
            },
            "tex-math tight": function(e, t) {
                return Xt.go(t, "tex-math tight")
            },
            bond: function(e, t, a) {
                return {
                    type_: "bond",
                    kind_: a || t
                }
            },
            "color0-output": function(e, t) {
                return {
                    type_: "color0",
                    color: t[0]
                }
            },
            ce: function(e, t) {
                return Xt.go(t)
            },
            "1/2": function(e, t) {
                var a = [];
                t.match(/^[+\-]/) && (a.push(t.substr(0, 1)), t = t.substr(1));
                var i = t.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
                return i[1] = i[1].replace(/\$/g, ""), a.push({
                    type_: "frac",
                    p1: i[1],
                    p2: i[2]
                }), i[3] && (i[3] = i[3].replace(/\$/g, ""), a.push({
                    type_: "tex-math",
                    p1: i[3]
                })), a
            },
            "9,9": function(e, t) {
                return Xt.go(t, "9,9")
            }
        },
        createTransitions: function(e) {
            var t, a, i, o, r = {};
            for (t in e)
                for (a in e[t])
                    for (i = a.split("|"), e[t][a].stateArray = i, o = 0; o < i.length; o++) r[i[o]] = [];
            for (t in e)
                for (a in e[t])
                    for (i = e[t][a].stateArray || [], o = 0; o < i.length; o++) {
                        var n = e[t][a];
                        if (n.action_) {
                            n.action_ = [].concat(n.action_);
                            for (var s = 0; s < n.action_.length; s++) "string" == typeof n.action_[s] && (n.action_[s] = {
                                type_: n.action_[s]
                            })
                        } else n.action_ = [];
                        for (var l = t.split("|"), d = 0; d < l.length; d++)
                            if ("*" === i[o])
                                for (var c in r) r[c].push({
                                    pattern: l[d],
                                    task: n
                                });
                            else r[i[o]].push({
                                pattern: l[d],
                                task: n
                            })
                    }
            return r
        },
        stateMachines: {}
    };
    Xt.stateMachines = {
        ce: {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {
                        action_: "output"
                    }
                },
                else: {
                    "0|1|2": {
                        action_: "beginsWithBond=false",
                        revisit: !0,
                        toContinue: !0
                    }
                },
                oxidation$: {
                    0: {
                        action_: "oxidation-output"
                    }
                },
                CMT: {
                    r: {
                        action_: "rdt=",
                        nextState: "rt"
                    },
                    rd: {
                        action_: "rqt=",
                        nextState: "rdt"
                    }
                },
                arrowUpDown: {
                    "0|1|2|as": {
                        action_: ["sb=false", "output", "operator"],
                        nextState: "1"
                    }
                },
                uprightEntities: {
                    "0|1|2": {
                        action_: ["o=", "output"],
                        nextState: "1"
                    }
                },
                orbital: {
                    "0|1|2|3": {
                        action_: "o=",
                        nextState: "o"
                    }
                },
                "->": {
                    "0|1|2|3": {
                        action_: "r=",
                        nextState: "r"
                    },
                    "a|as": {
                        action_: ["output", "r="],
                        nextState: "r"
                    },
                    "*": {
                        action_: ["output", "r="],
                        nextState: "r"
                    }
                },
                "+": {
                    o: {
                        action_: "d= kv",
                        nextState: "d"
                    },
                    "d|D": {
                        action_: "d=",
                        nextState: "d"
                    },
                    q: {
                        action_: "d=",
                        nextState: "qd"
                    },
                    "qd|qD": {
                        action_: "d=",
                        nextState: "qd"
                    },
                    dq: {
                        action_: ["output", "d="],
                        nextState: "d"
                    },
                    3: {
                        action_: ["sb=false", "output", "operator"],
                        nextState: "0"
                    }
                },
                amount: {
                    "0|2": {
                        action_: "a=",
                        nextState: "a"
                    }
                },
                "pm-operator": {
                    "0|1|2|a|as": {
                        action_: ["sb=false", "output", {
                            type_: "operator",
                            option: "\\pm"
                        }],
                        nextState: "0"
                    }
                },
                operator: {
                    "0|1|2|a|as": {
                        action_: ["sb=false", "output", "operator"],
                        nextState: "0"
                    }
                },
                "-$": {
                    "o|q": {
                        action_: ["charge or bond", "output"],
                        nextState: "qd"
                    },
                    d: {
                        action_: "d=",
                        nextState: "d"
                    },
                    D: {
                        action_: ["output", {
                            type_: "bond",
                            option: "-"
                        }],
                        nextState: "3"
                    },
                    q: {
                        action_: "d=",
                        nextState: "qd"
                    },
                    qd: {
                        action_: "d=",
                        nextState: "qd"
                    },
                    "qD|dq": {
                        action_: ["output", {
                            type_: "bond",
                            option: "-"
                        }],
                        nextState: "3"
                    }
                },
                "-9": {
                    "3|o": {
                        action_: ["output", {
                            type_: "insert",
                            option: "hyphen"
                        }],
                        nextState: "3"
                    }
                },
                "- orbital overlap": {
                    o: {
                        action_: ["output", {
                            type_: "insert",
                            option: "hyphen"
                        }],
                        nextState: "2"
                    },
                    d: {
                        action_: ["output", {
                            type_: "insert",
                            option: "hyphen"
                        }],
                        nextState: "2"
                    }
                },
                "-": {
                    "0|1|2": {
                        action_: [{
                            type_: "output",
                            option: 1
                        }, "beginsWithBond=true", {
                            type_: "bond",
                            option: "-"
                        }],
                        nextState: "3"
                    },
                    3: {
                        action_: {
                            type_: "bond",
                            option: "-"
                        }
                    },
                    a: {
                        action_: ["output", {
                            type_: "insert",
                            option: "hyphen"
                        }],
                        nextState: "2"
                    },
                    as: {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, {
                            type_: "bond",
                            option: "-"
                        }],
                        nextState: "3"
                    },
                    b: {
                        action_: "b="
                    },
                    o: {
                        action_: {
                            type_: "- after o/d",
                            option: !1
                        },
                        nextState: "2"
                    },
                    q: {
                        action_: {
                            type_: "- after o/d",
                            option: !1
                        },
                        nextState: "2"
                    },
                    "d|qd|dq": {
                        action_: {
                            type_: "- after o/d",
                            option: !0
                        },
                        nextState: "2"
                    },
                    "D|qD|p": {
                        action_: ["output", {
                            type_: "bond",
                            option: "-"
                        }],
                        nextState: "3"
                    }
                },
                amount2: {
                    "1|3": {
                        action_: "a=",
                        nextState: "a"
                    }
                },
                letters: {
                    "0|1|2|3|a|as|b|p|bp|o": {
                        action_: "o=",
                        nextState: "o"
                    },
                    "q|dq": {
                        action_: ["output", "o="],
                        nextState: "o"
                    },
                    "d|D|qd|qD": {
                        action_: "o after d",
                        nextState: "o"
                    }
                },
                digits: {
                    o: {
                        action_: "q=",
                        nextState: "q"
                    },
                    "d|D": {
                        action_: "q=",
                        nextState: "dq"
                    },
                    q: {
                        action_: ["output", "o="],
                        nextState: "o"
                    },
                    a: {
                        action_: "o=",
                        nextState: "o"
                    }
                },
                "space A": {
                    "b|p|bp": {}
                },
                space: {
                    a: {
                        nextState: "as"
                    },
                    0: {
                        action_: "sb=false"
                    },
                    "1|2": {
                        action_: "sb=true"
                    },
                    "r|rt|rd|rdt|rdq": {
                        action_: "output",
                        nextState: "0"
                    },
                    "*": {
                        action_: ["output", "sb=true"],
                        nextState: "1"
                    }
                },
                "1st-level escape": {
                    "1|2": {
                        action_: ["output", {
                            type_: "insert+p1",
                            option: "1st-level escape"
                        }]
                    },
                    "*": {
                        action_: ["output", {
                            type_: "insert+p1",
                            option: "1st-level escape"
                        }],
                        nextState: "0"
                    }
                },
                "[(...)]": {
                    "r|rt": {
                        action_: "rd=",
                        nextState: "rd"
                    },
                    "rd|rdt": {
                        action_: "rq=",
                        nextState: "rdq"
                    }
                },
                "...": {
                    "o|d|D|dq|qd|qD": {
                        action_: ["output", {
                            type_: "bond",
                            option: "..."
                        }],
                        nextState: "3"
                    },
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 1
                        }, {
                            type_: "insert",
                            option: "ellipsis"
                        }],
                        nextState: "1"
                    }
                },
                ". |* ": {
                    "*": {
                        action_: ["output", {
                            type_: "insert",
                            option: "addition compound"
                        }],
                        nextState: "1"
                    }
                },
                "state of aggregation $": {
                    "*": {
                        action_: ["output", "state of aggregation"],
                        nextState: "1"
                    }
                },
                "{[(": {
                    "a|as|o": {
                        action_: ["o=", "output", "parenthesisLevel++"],
                        nextState: "2"
                    },
                    "0|1|2|3": {
                        action_: ["o=", "output", "parenthesisLevel++"],
                        nextState: "2"
                    },
                    "*": {
                        action_: ["output", "o=", "output", "parenthesisLevel++"],
                        nextState: "2"
                    }
                },
                ")]}": {
                    "0|1|2|3|b|p|bp|o": {
                        action_: ["o=", "parenthesisLevel--"],
                        nextState: "o"
                    },
                    "a|as|d|D|q|qd|qD|dq": {
                        action_: ["output", "o=", "parenthesisLevel--"],
                        nextState: "o"
                    }
                },
                ", ": {
                    "*": {
                        action_: ["output", "comma"],
                        nextState: "0"
                    }
                },
                "^_": {
                    "*": {}
                },
                "^{(...)}|^($...$)": {
                    "0|1|2|as": {
                        action_: "b=",
                        nextState: "b"
                    },
                    p: {
                        action_: "b=",
                        nextState: "bp"
                    },
                    "3|o": {
                        action_: "d= kv",
                        nextState: "D"
                    },
                    q: {
                        action_: "d=",
                        nextState: "qD"
                    },
                    "d|D|qd|qD|dq": {
                        action_: ["output", "d="],
                        nextState: "D"
                    }
                },
                "^a|^\\x{}{}|^\\x{}|^\\x|'": {
                    "0|1|2|as": {
                        action_: "b=",
                        nextState: "b"
                    },
                    p: {
                        action_: "b=",
                        nextState: "bp"
                    },
                    "3|o": {
                        action_: "d= kv",
                        nextState: "d"
                    },
                    q: {
                        action_: "d=",
                        nextState: "qd"
                    },
                    "d|qd|D|qD": {
                        action_: "d="
                    },
                    dq: {
                        action_: ["output", "d="],
                        nextState: "d"
                    }
                },
                "_{(state of aggregation)}$": {
                    "d|D|q|qd|qD|dq": {
                        action_: ["output", "q="],
                        nextState: "q"
                    }
                },
                "_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x": {
                    "0|1|2|as": {
                        action_: "p=",
                        nextState: "p"
                    },
                    b: {
                        action_: "p=",
                        nextState: "bp"
                    },
                    "3|o": {
                        action_: "q=",
                        nextState: "q"
                    },
                    "d|D": {
                        action_: "q=",
                        nextState: "dq"
                    },
                    "q|qd|qD|dq": {
                        action_: ["output", "q="],
                        nextState: "q"
                    }
                },
                "=<>": {
                    "0|1|2|3|a|as|o|q|d|D|qd|qD|dq": {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, "bond"],
                        nextState: "3"
                    }
                },
                "#": {
                    "0|1|2|3|a|as|o": {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, {
                            type_: "bond",
                            option: "#"
                        }],
                        nextState: "3"
                    }
                },
                "{}": {
                    "*": {
                        action_: {
                            type_: "output",
                            option: 1
                        },
                        nextState: "1"
                    }
                },
                "{...}": {
                    "0|1|2|3|a|as|b|p|bp": {
                        action_: "o=",
                        nextState: "o"
                    },
                    "o|d|D|q|qd|qD|dq": {
                        action_: ["output", "o="],
                        nextState: "o"
                    }
                },
                "$...$": {
                    a: {
                        action_: "a="
                    },
                    "0|1|2|3|as|b|p|bp|o": {
                        action_: "o=",
                        nextState: "o"
                    },
                    "as|o": {
                        action_: "o="
                    },
                    "q|d|D|qd|qD|dq": {
                        action_: ["output", "o="],
                        nextState: "o"
                    }
                },
                "\\bond{(...)}": {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, "bond"],
                        nextState: "3"
                    }
                },
                "\\frac{(...)}": {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 1
                        }, "frac-output"],
                        nextState: "3"
                    }
                },
                "\\overset{(...)}": {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, "overset-output"],
                        nextState: "3"
                    }
                },
                "\\underset{(...)}": {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, "underset-output"],
                        nextState: "3"
                    }
                },
                "\\underbrace{(...)}": {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, "underbrace-output"],
                        nextState: "3"
                    }
                },
                "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, "color-output"],
                        nextState: "3"
                    }
                },
                "\\color{(...)}0": {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, "color0-output"]
                    }
                },
                "\\ce{(...)}": {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 2
                        }, "ce"],
                        nextState: "3"
                    }
                },
                "\\,": {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 1
                        }, "copy"],
                        nextState: "1"
                    }
                },
                "\\x{}{}|\\x{}|\\x": {
                    "0|1|2|3|a|as|b|p|bp|o|c0": {
                        action_: ["o=", "output"],
                        nextState: "3"
                    },
                    "*": {
                        action_: ["output", "o=", "output"],
                        nextState: "3"
                    }
                },
                others: {
                    "*": {
                        action_: [{
                            type_: "output",
                            option: 1
                        }, "copy"],
                        nextState: "3"
                    }
                },
                else2: {
                    a: {
                        action_: "a to o",
                        nextState: "o",
                        revisit: !0
                    },
                    as: {
                        action_: ["output", "sb=true"],
                        nextState: "1",
                        revisit: !0
                    },
                    "r|rt|rd|rdt|rdq": {
                        action_: ["output"],
                        nextState: "0",
                        revisit: !0
                    },
                    "*": {
                        action_: ["output", "copy"],
                        nextState: "3"
                    }
                }
            }),
            actions: {
                "o after d": function(e, t) {
                    var a;
                    if ((e.d || "").match(/^[0-9]+$/)) {
                        var i = e.d;
                        e.d = void 0, a = this.output(e), e.b = i
                    } else a = this.output(e);
                    return Xt.actions["o="](e, t), a
                },
                "d= kv": function(e, t) {
                    e.d = t, e.dType = "kv"
                },
                "charge or bond": function(e, t) {
                    if (e.beginsWithBond) {
                        var a = [];
                        return Xt.concatArray(a, this.output(e)), Xt.concatArray(a, Xt.actions.bond(e, t, "-")), a
                    }
                    e.d = t
                },
                "- after o/d": function(e, t, a) {
                    var i = Xt.patterns.match_("orbital", e.o || ""),
                        o = Xt.patterns.match_("one lowercase greek letter $", e.o || ""),
                        r = Xt.patterns.match_("one lowercase latin letter $", e.o || ""),
                        n = Xt.patterns.match_("$one lowercase latin letter$ $", e.o || ""),
                        s = "-" === t && (i && "" === i.remainder || o || r || n);
                    !s || e.a || e.b || e.p || e.d || e.q || i || !r || (e.o = "$" + e.o + "$");
                    var l = [];
                    return s ? (Xt.concatArray(l, this.output(e)), l.push({
                        type_: "hyphen"
                    })) : (i = Xt.patterns.match_("digits", e.d || ""), a && i && "" === i.remainder ? (Xt.concatArray(l, Xt.actions["d="](e, t)), Xt.concatArray(l, this.output(e))) : (Xt.concatArray(l, this.output(e)), Xt.concatArray(l, Xt.actions.bond(e, t, "-")))), l
                },
                "a to o": function(e) {
                    e.o = e.a, e.a = void 0
                },
                "sb=true": function(e) {
                    e.sb = !0
                },
                "sb=false": function(e) {
                    e.sb = !1
                },
                "beginsWithBond=true": function(e) {
                    e.beginsWithBond = !0
                },
                "beginsWithBond=false": function(e) {
                    e.beginsWithBond = !1
                },
                "parenthesisLevel++": function(e) {
                    e.parenthesisLevel++
                },
                "parenthesisLevel--": function(e) {
                    e.parenthesisLevel--
                },
                "state of aggregation": function(e, t) {
                    return {
                        type_: "state of aggregation",
                        p1: Xt.go(t, "o")
                    }
                },
                comma: function(e, t) {
                    var a = t.replace(/\s*$/, "");
                    return a !== t && 0 === e.parenthesisLevel ? {
                        type_: "comma enumeration L",
                        p1: a
                    } : {
                        type_: "comma enumeration M",
                        p1: a
                    }
                },
                output: function(e, t, a) {
                    var i, o, r;
                    for (var n in e.r ? (o = "M" === e.rdt ? Xt.go(e.rd, "tex-math") : "T" === e.rdt ? [{
                            type_: "text",
                            p1: e.rd || ""
                        }] : Xt.go(e.rd), r = "M" === e.rqt ? Xt.go(e.rq, "tex-math") : "T" === e.rqt ? [{
                            type_: "text",
                            p1: e.rq || ""
                        }] : Xt.go(e.rq), i = {
                            type_: "arrow",
                            r: e.r,
                            rd: o,
                            rq: r
                        }) : (i = [], (e.a || e.b || e.p || e.o || e.q || e.d || a) && (e.sb && i.push({
                            type_: "entitySkip"
                        }), e.o || e.q || e.d || e.b || e.p || 2 === a ? e.o || e.q || e.d || !e.b && !e.p ? e.o && "kv" === e.dType && Xt.patterns.match_("d-oxidation$", e.d || "") ? e.dType = "oxidation" : e.o && "kv" === e.dType && !e.q && (e.dType = void 0) : (e.o = e.a, e.d = e.b, e.q = e.p, e.a = e.b = e.p = void 0) : (e.o = e.a, e.a = void 0), i.push({
                            type_: "chemfive",
                            a: Xt.go(e.a, "a"),
                            b: Xt.go(e.b, "bd"),
                            p: Xt.go(e.p, "pq"),
                            o: Xt.go(e.o, "o"),
                            q: Xt.go(e.q, "pq"),
                            d: Xt.go(e.d, "oxidation" === e.dType ? "oxidation" : "bd"),
                            dType: e.dType
                        }))), e) "parenthesisLevel" !== n && "beginsWithBond" !== n && delete e[n];
                    return i
                },
                "oxidation-output": function(e, t) {
                    var a = ["{"];
                    return Xt.concatArray(a, Xt.go(t, "oxidation")), a.push("}"), a
                },
                "frac-output": function(e, t) {
                    return {
                        type_: "frac-ce",
                        p1: Xt.go(t[0]),
                        p2: Xt.go(t[1])
                    }
                },
                "overset-output": function(e, t) {
                    return {
                        type_: "overset",
                        p1: Xt.go(t[0]),
                        p2: Xt.go(t[1])
                    }
                },
                "underset-output": function(e, t) {
                    return {
                        type_: "underset",
                        p1: Xt.go(t[0]),
                        p2: Xt.go(t[1])
                    }
                },
                "underbrace-output": function(e, t) {
                    return {
                        type_: "underbrace",
                        p1: Xt.go(t[0]),
                        p2: Xt.go(t[1])
                    }
                },
                "color-output": function(e, t) {
                    return {
                        type_: "color",
                        color1: t[0],
                        color2: Xt.go(t[1])
                    }
                },
                "r=": function(e, t) {
                    e.r = t
                },
                "rdt=": function(e, t) {
                    e.rdt = t
                },
                "rd=": function(e, t) {
                    e.rd = t
                },
                "rqt=": function(e, t) {
                    e.rqt = t
                },
                "rq=": function(e, t) {
                    e.rq = t
                },
                operator: function(e, t, a) {
                    return {
                        type_: "operator",
                        kind_: a || t
                    }
                }
            }
        },
        a: {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {}
                },
                "1/2$": {
                    0: {
                        action_: "1/2"
                    }
                },
                else: {
                    0: {
                        nextState: "1",
                        revisit: !0
                    }
                },
                "$(...)$": {
                    "*": {
                        action_: "tex-math tight",
                        nextState: "1"
                    }
                },
                ",": {
                    "*": {
                        action_: {
                            type_: "insert",
                            option: "commaDecimal"
                        }
                    }
                },
                else2: {
                    "*": {
                        action_: "copy"
                    }
                }
            }),
            actions: {}
        },
        o: {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {}
                },
                "1/2$": {
                    0: {
                        action_: "1/2"
                    }
                },
                else: {
                    0: {
                        nextState: "1",
                        revisit: !0
                    }
                },
                letters: {
                    "*": {
                        action_: "rm"
                    }
                },
                "\\ca": {
                    "*": {
                        action_: {
                            type_: "insert",
                            option: "circa"
                        }
                    }
                },
                "\\x{}{}|\\x{}|\\x": {
                    "*": {
                        action_: "copy"
                    }
                },
                "${(...)}$|$(...)$": {
                    "*": {
                        action_: "tex-math"
                    }
                },
                "{(...)}": {
                    "*": {
                        action_: "{text}"
                    }
                },
                else2: {
                    "*": {
                        action_: "copy"
                    }
                }
            }),
            actions: {}
        },
        text: {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {
                        action_: "output"
                    }
                },
                "{...}": {
                    "*": {
                        action_: "text="
                    }
                },
                "${(...)}$|$(...)$": {
                    "*": {
                        action_: "tex-math"
                    }
                },
                "\\greek": {
                    "*": {
                        action_: ["output", "rm"]
                    }
                },
                "\\,|\\x{}{}|\\x{}|\\x": {
                    "*": {
                        action_: ["output", "copy"]
                    }
                },
                else: {
                    "*": {
                        action_: "text="
                    }
                }
            }),
            actions: {
                output: function(e) {
                    if (e.text_) {
                        var t = {
                            type_: "text",
                            p1: e.text_
                        };
                        for (var a in e) delete e[a];
                        return t
                    }
                }
            }
        },
        pq: {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {}
                },
                "state of aggregation $": {
                    "*": {
                        action_: "state of aggregation"
                    }
                },
                i$: {
                    0: {
                        nextState: "!f",
                        revisit: !0
                    }
                },
                "(KV letters),": {
                    0: {
                        action_: "rm",
                        nextState: "0"
                    }
                },
                formula$: {
                    0: {
                        nextState: "f",
                        revisit: !0
                    }
                },
                "1/2$": {
                    0: {
                        action_: "1/2"
                    }
                },
                else: {
                    0: {
                        nextState: "!f",
                        revisit: !0
                    }
                },
                "${(...)}$|$(...)$": {
                    "*": {
                        action_: "tex-math"
                    }
                },
                "{(...)}": {
                    "*": {
                        action_: "text"
                    }
                },
                "a-z": {
                    f: {
                        action_: "tex-math"
                    }
                },
                letters: {
                    "*": {
                        action_: "rm"
                    }
                },
                "-9.,9": {
                    "*": {
                        action_: "9,9"
                    }
                },
                ",": {
                    "*": {
                        action_: {
                            type_: "insert+p1",
                            option: "comma enumeration S"
                        }
                    }
                },
                "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
                    "*": {
                        action_: "color-output"
                    }
                },
                "\\color{(...)}0": {
                    "*": {
                        action_: "color0-output"
                    }
                },
                "\\ce{(...)}": {
                    "*": {
                        action_: "ce"
                    }
                },
                "\\,|\\x{}{}|\\x{}|\\x": {
                    "*": {
                        action_: "copy"
                    }
                },
                else2: {
                    "*": {
                        action_: "copy"
                    }
                }
            }),
            actions: {
                "state of aggregation": function(e, t) {
                    return {
                        type_: "state of aggregation subscript",
                        p1: Xt.go(t, "o")
                    }
                },
                "color-output": function(e, t) {
                    return {
                        type_: "color",
                        color1: t[0],
                        color2: Xt.go(t[1], "pq")
                    }
                }
            }
        },
        bd: {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {}
                },
                x$: {
                    0: {
                        nextState: "!f",
                        revisit: !0
                    }
                },
                formula$: {
                    0: {
                        nextState: "f",
                        revisit: !0
                    }
                },
                else: {
                    0: {
                        nextState: "!f",
                        revisit: !0
                    }
                },
                "-9.,9 no missing 0": {
                    "*": {
                        action_: "9,9"
                    }
                },
                ".": {
                    "*": {
                        action_: {
                            type_: "insert",
                            option: "electron dot"
                        }
                    }
                },
                "a-z": {
                    f: {
                        action_: "tex-math"
                    }
                },
                x: {
                    "*": {
                        action_: {
                            type_: "insert",
                            option: "KV x"
                        }
                    }
                },
                letters: {
                    "*": {
                        action_: "rm"
                    }
                },
                "'": {
                    "*": {
                        action_: {
                            type_: "insert",
                            option: "prime"
                        }
                    }
                },
                "${(...)}$|$(...)$": {
                    "*": {
                        action_: "tex-math"
                    }
                },
                "{(...)}": {
                    "*": {
                        action_: "text"
                    }
                },
                "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
                    "*": {
                        action_: "color-output"
                    }
                },
                "\\color{(...)}0": {
                    "*": {
                        action_: "color0-output"
                    }
                },
                "\\ce{(...)}": {
                    "*": {
                        action_: "ce"
                    }
                },
                "\\,|\\x{}{}|\\x{}|\\x": {
                    "*": {
                        action_: "copy"
                    }
                },
                else2: {
                    "*": {
                        action_: "copy"
                    }
                }
            }),
            actions: {
                "color-output": function(e, t) {
                    return {
                        type_: "color",
                        color1: t[0],
                        color2: Xt.go(t[1], "bd")
                    }
                }
            }
        },
        oxidation: {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {}
                },
                "roman numeral": {
                    "*": {
                        action_: "roman-numeral"
                    }
                },
                "${(...)}$|$(...)$": {
                    "*": {
                        action_: "tex-math"
                    }
                },
                else: {
                    "*": {
                        action_: "copy"
                    }
                }
            }),
            actions: {
                "roman-numeral": function(e, t) {
                    return {
                        type_: "roman numeral",
                        p1: t || ""
                    }
                }
            }
        },
        "tex-math": {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {
                        action_: "output"
                    }
                },
                "\\ce{(...)}": {
                    "*": {
                        action_: ["output", "ce"]
                    }
                },
                "{...}|\\,|\\x{}{}|\\x{}|\\x": {
                    "*": {
                        action_: "o="
                    }
                },
                else: {
                    "*": {
                        action_: "o="
                    }
                }
            }),
            actions: {
                output: function(e) {
                    if (e.o) {
                        var t = {
                            type_: "tex-math",
                            p1: e.o
                        };
                        for (var a in e) delete e[a];
                        return t
                    }
                }
            }
        },
        "tex-math tight": {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {
                        action_: "output"
                    }
                },
                "\\ce{(...)}": {
                    "*": {
                        action_: ["output", "ce"]
                    }
                },
                "{...}|\\,|\\x{}{}|\\x{}|\\x": {
                    "*": {
                        action_: "o="
                    }
                },
                "-|+": {
                    "*": {
                        action_: "tight operator"
                    }
                },
                else: {
                    "*": {
                        action_: "o="
                    }
                }
            }),
            actions: {
                "tight operator": function(e, t) {
                    e.o = (e.o || "") + "{" + t + "}"
                },
                output: function(e) {
                    if (e.o) {
                        var t = {
                            type_: "tex-math",
                            p1: e.o
                        };
                        for (var a in e) delete e[a];
                        return t
                    }
                }
            }
        },
        "9,9": {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {}
                },
                ",": {
                    "*": {
                        action_: "comma"
                    }
                },
                else: {
                    "*": {
                        action_: "copy"
                    }
                }
            }),
            actions: {
                comma: function() {
                    return {
                        type_: "commaDecimal"
                    }
                }
            }
        },
        pu: {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {
                        action_: "output"
                    }
                },
                space$: {
                    "*": {
                        action_: ["output", "space"]
                    }
                },
                "{[(|)]}": {
                    "0|a": {
                        action_: "copy"
                    }
                },
                "(-)(9)^(-9)": {
                    0: {
                        action_: "number^",
                        nextState: "a"
                    }
                },
                "(-)(9.,9)(e)(99)": {
                    0: {
                        action_: "enumber",
                        nextState: "a"
                    }
                },
                space: {
                    "0|a": {}
                },
                "pm-operator": {
                    "0|a": {
                        action_: {
                            type_: "operator",
                            option: "\\pm"
                        },
                        nextState: "0"
                    }
                },
                operator: {
                    "0|a": {
                        action_: "copy",
                        nextState: "0"
                    }
                },
                "//": {
                    d: {
                        action_: "o=",
                        nextState: "/"
                    }
                },
                "/": {
                    d: {
                        action_: "o=",
                        nextState: "/"
                    }
                },
                "{...}|else": {
                    "0|d": {
                        action_: "d=",
                        nextState: "d"
                    },
                    a: {
                        action_: ["space", "d="],
                        nextState: "d"
                    },
                    "/|q": {
                        action_: "q=",
                        nextState: "q"
                    }
                }
            }),
            actions: {
                enumber: function(e, t) {
                    var a = [];
                    return "+-" === t[0] || "+/-" === t[0] ? a.push("\\pm ") : t[0] && a.push(t[0]), t[1] && (Xt.concatArray(a, Xt.go(t[1], "pu-9,9")), t[2] && (t[2].match(/[,.]/) ? Xt.concatArray(a, Xt.go(t[2], "pu-9,9")) : a.push(t[2])), t[3] = t[4] || t[3], t[3] && (t[3] = t[3].trim(), "e" === t[3] || "*" === t[3].substr(0, 1) ? a.push({
                        type_: "cdot"
                    }) : a.push({
                        type_: "times"
                    }))), t[3] && a.push("10^{" + t[5] + "}"), a
                },
                "number^": function(e, t) {
                    var a = [];
                    return "+-" === t[0] || "+/-" === t[0] ? a.push("\\pm ") : t[0] && a.push(t[0]), Xt.concatArray(a, Xt.go(t[1], "pu-9,9")), a.push("^{" + t[2] + "}"), a
                },
                operator: function(e, t, a) {
                    return {
                        type_: "operator",
                        kind_: a || t
                    }
                },
                space: function() {
                    return {
                        type_: "pu-space-1"
                    }
                },
                output: function(e) {
                    var t, a = Xt.patterns.match_("{(...)}", e.d || "");
                    a && "" === a.remainder && (e.d = a.match_);
                    var i = Xt.patterns.match_("{(...)}", e.q || "");
                    if (i && "" === i.remainder && (e.q = i.match_), e.d && (e.d = e.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C"), e.d = e.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F")), e.q) {
                        e.q = e.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C"), e.q = e.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
                        var o = {
                            d: Xt.go(e.d, "pu"),
                            q: Xt.go(e.q, "pu")
                        };
                        "//" === e.o ? t = {
                            type_: "pu-frac",
                            p1: o.d,
                            p2: o.q
                        } : (t = o.d, o.d.length > 1 || o.q.length > 1 ? t.push({
                            type_: " / "
                        }) : t.push({
                            type_: "/"
                        }), Xt.concatArray(t, o.q))
                    } else t = Xt.go(e.d, "pu-2");
                    for (var r in e) delete e[r];
                    return t
                }
            }
        },
        "pu-2": {
            transitions: Xt.createTransitions({
                empty: {
                    "*": {
                        action_: "output"
                    }
                },
                "*": {
                    "*": {
                        action_: ["output", "cdot"],
                        nextState: "0"
                    }
                },
                "\\x": {
                    "*": {
                        action_: "rm="
                    }
                },
                space: {
                    "*": {
                        action_: ["output", "space"],
                        nextState: "0"
                    }
                },
                "^{(...)}|^(-1)": {
                    1: {
                        action_: "^(-1)"
                    }
                },
                "-9.,9": {
                    0: {
                        action_: "rm=",
                        nextState: "0"
                    },
                    1: {
                        action_: "^(-1)",
                        nextState: "0"
                    }
                },
                "{...}|else": {
                    "*": {
                        action_: "rm=",
                        nextState: "1"
                    }
                }
            }),
            actions: {
                cdot: function() {
                    return {
                        type_: "tight cdot"
                    }
                },
                "^(-1)": function(e, t) {
                    e.rm += "^{" + t + "}"
                },
                space: function() {
                    return {
                        type_: "pu-space-2"
                    }
                },
                output: function(e) {
                    var t = [];
                    if (e.rm) {
                        var a = Xt.patterns.match_("{(...)}", e.rm || "");
                        t = a && "" === a.remainder ? Xt.go(a.match_, "pu") : {
                            type_: "rm",
                            p1: e.rm
                        }
                    }
                    for (var i in e) delete e[i];
                    return t
                }
            }
        },
        "pu-9,9": {
            transitions: Xt.createTransitions({
                empty: {
                    0: {
                        action_: "output-0"
                    },
                    o: {
                        action_: "output-o"
                    }
                },
                ",": {
                    0: {
                        action_: ["output-0", "comma"],
                        nextState: "o"
                    }
                },
                ".": {
                    0: {
                        action_: ["output-0", "copy"],
                        nextState: "o"
                    }
                },
                else: {
                    "*": {
                        action_: "text="
                    }
                }
            }),
            actions: {
                comma: function() {
                    return {
                        type_: "commaDecimal"
                    }
                },
                "output-0": function(e) {
                    var t = [];
                    if (e.text_ = e.text_ || "", e.text_.length > 4) {
                        var a = e.text_.length % 3;
                        0 === a && (a = 3);
                        for (var i = e.text_.length - 3; i > 0; i -= 3) t.push(e.text_.substr(i, 3)), t.push({
                            type_: "1000 separator"
                        });
                        t.push(e.text_.substr(0, a)), t.reverse()
                    } else t.push(e.text_);
                    for (var o in e) delete e[o];
                    return t
                },
                "output-o": function(e) {
                    var t = [];
                    if (e.text_ = e.text_ || "", e.text_.length > 4) {
                        for (var a = e.text_.length - 3, i = 0; i < a; i += 3) t.push(e.text_.substr(i, 3)), t.push({
                            type_: "1000 separator"
                        });
                        t.push(e.text_.substr(i))
                    } else t.push(e.text_);
                    for (var o in e) delete e[o];
                    return t
                }
            }
        }
    };
    var Gt = {
        go: function(e, t) {
            if (!e) return "";
            for (var a = "", i = !1, o = 0; o < e.length; o++) {
                var r = e[o];
                "string" == typeof r ? a += r : (a += Gt._go2(r), "1st-level escape" === r.type_ && (i = !0))
            }
            return t || i || !a || (a = "{" + a + "}"), a
        },
        _goInner: function(e) {
            return e ? Gt.go(e, !0) : e
        },
        _go2: function(e) {
            var t;
            switch (e.type_) {
                case "chemfive":
                    t = "";
                    var a = {
                        a: Gt._goInner(e.a),
                        b: Gt._goInner(e.b),
                        p: Gt._goInner(e.p),
                        o: Gt._goInner(e.o),
                        q: Gt._goInner(e.q),
                        d: Gt._goInner(e.d)
                    };
                    a.a && (a.a.match(/^[+\-]/) && (a.a = "{" + a.a + "}"), t += a.a + "\\,"), (a.b || a.p) && (t += "{\\vphantom{X}}", t += "^{\\hphantom{" + (a.b || "") + "}}_{\\hphantom{" + (a.p || "") + "}}", t += "{\\vphantom{X}}", t += "^{\\smash[t]{\\vphantom{2}}\\mathllap{" + (a.b || "") + "}}", t += "_{\\vphantom{2}\\mathllap{\\smash[t]{" + (a.p || "") + "}}}"), a.o && (a.o.match(/^[+\-]/) && (a.o = "{" + a.o + "}"), t += a.o), "kv" === e.dType ? ((a.d || a.q) && (t += "{\\vphantom{X}}"), a.d && (t += "^{" + a.d + "}"), a.q && (t += "_{\\smash[t]{" + a.q + "}}")) : "oxidation" === e.dType ? (a.d && (t += "{\\vphantom{X}}", t += "^{" + a.d + "}"), a.q && (t += "{\\vphantom{X}}", t += "_{\\smash[t]{" + a.q + "}}")) : (a.q && (t += "{\\vphantom{X}}", t += "_{\\smash[t]{" + a.q + "}}"), a.d && (t += "{\\vphantom{X}}", t += "^{" + a.d + "}"));
                    break;
                case "rm":
                case "roman numeral":
                    t = "\\mathrm{" + e.p1 + "}";
                    break;
                case "text":
                    e.p1.match(/[\^_]/) ? (e.p1 = e.p1.replace(" ", "~").replace("-", "\\text{-}"), t = "\\mathrm{" + e.p1 + "}") : t = "\\text{" + e.p1 + "}";
                    break;
                case "state of aggregation":
                    t = "\\mskip2mu " + Gt._goInner(e.p1);
                    break;
                case "state of aggregation subscript":
                    t = "\\mskip1mu " + Gt._goInner(e.p1);
                    break;
                case "bond":
                    if (!(t = Gt._getBond(e.kind_))) throw ["MhchemErrorBond", "mhchem Error. Unknown bond type (" + e.kind_ + ")"];
                    break;
                case "frac":
                    var i = "\\frac{" + e.p1 + "}{" + e.p2 + "}";
                    t = "\\mathchoice{\\textstyle" + i + "}{" + i + "}{" + i + "}{" + i + "}";
                    break;
                case "pu-frac":
                    var o = "\\frac{" + Gt._goInner(e.p1) + "}{" + Gt._goInner(e.p2) + "}";
                    t = "\\mathchoice{\\textstyle" + o + "}{" + o + "}{" + o + "}{" + o + "}";
                    break;
                case "tex-math":
                case "1st-level escape":
                    t = e.p1 + " ";
                    break;
                case "frac-ce":
                    t = "\\frac{" + Gt._goInner(e.p1) + "}{" + Gt._goInner(e.p2) + "}";
                    break;
                case "overset":
                    t = "\\overset{" + Gt._goInner(e.p1) + "}{" + Gt._goInner(e.p2) + "}";
                    break;
                case "underset":
                    t = "\\underset{" + Gt._goInner(e.p1) + "}{" + Gt._goInner(e.p2) + "}";
                    break;
                case "underbrace":
                    t = "\\underbrace{" + Gt._goInner(e.p1) + "}_{" + Gt._goInner(e.p2) + "}";
                    break;
                case "color":
                    t = "{\\color{" + e.color1 + "}{" + Gt._goInner(e.color2) + "}}";
                    break;
                case "color0":
                    t = "\\color{" + e.color + "}";
                    break;
                case "arrow":
                    var r = {
                            rd: Gt._goInner(e.rd),
                            rq: Gt._goInner(e.rq)
                        },
                        n = "\\x" + Gt._getArrow(e.r);
                    r.rq && (n += "[{" + r.rq + "}]"), t = n += r.rd ? "{" + r.rd + "}" : "{}";
                    break;
                case "operator":
                    t = Gt._getOperator(e.kind_);
                    break;
                case "space":
                    t = " ";
                    break;
                case "entitySkip":
                case "pu-space-1":
                    t = "~";
                    break;
                case "pu-space-2":
                    t = "\\mkern3mu ";
                    break;
                case "1000 separator":
                    t = "\\mkern2mu ";
                    break;
                case "commaDecimal":
                    t = "{,}";
                    break;
                case "comma enumeration L":
                    t = "{" + e.p1 + "}\\mkern6mu ";
                    break;
                case "comma enumeration M":
                    t = "{" + e.p1 + "}\\mkern3mu ";
                    break;
                case "comma enumeration S":
                    t = "{" + e.p1 + "}\\mkern1mu ";
                    break;
                case "hyphen":
                    t = "\\text{-}";
                    break;
                case "addition compound":
                    t = "\\,{\\cdot}\\,";
                    break;
                case "electron dot":
                    t = "\\mkern1mu \\bullet\\mkern1mu ";
                    break;
                case "KV x":
                    t = "{\\times}";
                    break;
                case "prime":
                    t = "\\prime ";
                    break;
                case "cdot":
                    t = "\\cdot ";
                    break;
                case "tight cdot":
                    t = "\\mkern1mu{\\cdot}\\mkern1mu ";
                    break;
                case "times":
                    t = "\\times ";
                    break;
                case "circa":
                    t = "{\\sim}";
                    break;
                case "^":
                    t = "uparrow";
                    break;
                case "v":
                    t = "downarrow";
                    break;
                case "ellipsis":
                    t = "\\ldots ";
                    break;
                case "/":
                    t = "/";
                    break;
                case " / ":
                    t = "\\,/\\,";
                    break;
                default:
                    throw ["MhchemBugT", "mhchem bug T. Please report."]
            }
            return t
        },
        _getArrow: function(e) {
            switch (e) {
                case "->":
                case "→":
                case "⟶":
                    return "rightarrow";
                case "<-":
                    return "leftarrow";
                case "<->":
                    return "leftrightarrow";
                case "<--\x3e":
                    return "rightleftarrows";
                case "<=>":
                case "⇌":
                    return "rightleftharpoons";
                case "<=>>":
                    return "rightequilibrium";
                case "<<=>":
                    return "leftequilibrium";
                default:
                    throw ["MhchemBugT", "mhchem bug T. Please report."]
            }
        },
        _getBond: function(e) {
            switch (e) {
                case "-":
                case "1":
                    return "{-}";
                case "=":
                case "2":
                    return "{=}";
                case "#":
                case "3":
                    return "{\\equiv}";
                case "~":
                    return "{\\tripledash}";
                case "~-":
                    return "{\\mathrlap{\\raisebox{-.1em}{$-$}}\\raisebox{.1em}{$\\tripledash$}}";
                case "~=":
                case "~--":
                    return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
                case "-~-":
                    return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$-$}}\\tripledash}";
                case "...":
                    return "{{\\cdot}{\\cdot}{\\cdot}}";
                case "....":
                    return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
                case "->":
                    return "{\\rightarrow}";
                case "<-":
                    return "{\\leftarrow}";
                case "<":
                    return "{<}";
                case ">":
                    return "{>}";
                default:
                    throw ["MhchemBugT", "mhchem bug T. Please report."]
            }
        },
        _getOperator: function(e) {
            switch (e) {
                case "+":
                    return " {}+{} ";
                case "-":
                    return " {}-{} ";
                case "=":
                    return " {}={} ";
                case "<":
                    return " {}<{} ";
                case ">":
                    return " {}>{} ";
                case "<<":
                    return " {}\\ll{} ";
                case ">>":
                    return " {}\\gg{} ";
                case "\\pm":
                    return " {}\\pm{} ";
                case "\\approx":
                case "$\\approx$":
                    return " {}\\approx{} ";
                case "v":
                case "(v)":
                    return " \\downarrow{} ";
                case "^":
                case "(^)":
                    return " \\uparrow{} ";
                default:
                    throw ["MhchemBugT", "mhchem bug T. Please report."]
            }
        }
    };
    class Zt extends lt {
        static fromJson(e, t) {
            return new Zt(e.command, e.delim, t, e)
        }
        toJson() {
            return {
                ...super.toJson(),
                delim: this.value,
                size: this.size
            }
        }
        render(e) {
            const t = new Ne(null);
            return t.delim = this.value, t
        }
        serialize(e) {
            return 1 === this.value.length ? this.command + this.value : `${this.command}{${this.value}}`
        }
        constructor(e, t, a, i) {
            super("delim", a, {
                command: e,
                style: null == i ? void 0 : i.style
            }), this.value = t, this.size = null == i ? void 0 : i.size
        }
    }
    class Yt extends lt {
        static fromJson(e, t) {
            return new Yt(e.command, e.delim, t, e)
        }
        toJson() {
            return {
                ...super.toJson(),
                delim: this.value,
                size: this.size,
                delimClass: this.delimClass
            }
        }
        render(e) {
            let t = function(e, t, a, i) {
                var o;
                return void 0 === e || "." === e ? Lt(a, null !== (o = i.type) && void 0 !== o ? o : "minner", i.classes) : ("<" === e || "\\lt" === e || "⟨" === e ? e = "\\langle" : ">" !== e && "\\gt" !== e && "⟩" !== e || (e = "\\rangle"), bt.has(e) || vt.has(e) ? ft(e, t, !1, a, i) : gt.has(e) ? yt(e, kt[t], !1, a, i) : null)
            }(this.value, this.size, e, {
                classes: this.delimClass
            });
            return t ? (t = this.bind(e, t), this.caret && (t.caret = this.caret), t) : null
        }
        serialize(e) {
            return 1 === this.value.length ? this.command + this.value : `${this.command}{${this.value}}`
        }
        constructor(e, t, a, i) {
            super("sizeddelim", a, {
                command: e,
                style: i.style
            }), this.value = t, this.delimClass = i.delimClass, this.size = i.size
        }
    }
    class Qt extends lt {
        static fromJson(e, t) {
            return new Qt(e.command, e.body, e.notation, t, e)
        }
        toJson() {
            const e = {};
            return this.notation.downdiagonalstrike && (e.downdiagonalstrike = !0), this.notation.updiagonalstrike && (e.downdiagonalstrike = !0), this.notation.verticalstrike && (e.downdiagonalstrike = !0), this.notation.horizontalstrike && (e.downdiagonalstrike = !0), this.notation.updiagonalarrow && (e.downdiagonalstrike = !0), this.notation.right && (e.downdiagonalstrike = !0), this.notation.bottom && (e.downdiagonalstrike = !0), this.notation.left && (e.downdiagonalstrike = !0), this.notation.top && (e.downdiagonalstrike = !0), this.notation.circle && (e.downdiagonalstrike = !0), this.notation.roundedbox && (e.downdiagonalstrike = !0), this.notation.madruwb && (e.downdiagonalstrike = !0), this.notation.actuarial && (e.downdiagonalstrike = !0), this.notation.box && (e.downdiagonalstrike = !0), {
                ...super.toJson(),
                notation: e,
                shadow: this.shadow,
                strokeWidth: this.strokeWidth,
                strokeStyle: this.strokeStyle,
                svgStrokeStyle: this.svgStrokeStyle,
                strokeColor: this.strokeColor,
                borderStyle: this.borderStyle,
                padding: this.padding
            }
        }
        serialize(e) {
            var t;
            let a = null !== (t = this.command) && void 0 !== t ? t : "";
            if ("\\enclose" === this.command) {
                a += "{" + Object.keys(this.notation).join(" ") + "}";
                let e = "",
                    t = "";
                this.backgroundcolor && "transparent" !== this.backgroundcolor && (e += t + 'mathbackground="' + this.backgroundcolor + '"', t = ","), this.shadow && "auto" !== this.shadow && (e += t + 'shadow="' + this.shadow + '"', t = ","), this.strokeWidth || "solid" !== this.strokeStyle ? (e += t + this.borderStyle, t = ",") : this.strokeColor && "currentColor" !== this.strokeColor && (e += t + 'mathcolor="' + this.strokeColor + '"', t = ","), e && (a += `[${e}]`)
            }
            return a += `{${this.bodyToLatex(e)}}`, a
        }
        render(e) {
            var t;
            const a = new Ae(e, this.style),
                i = lt.createBox(a, this.body);
            if (!i) return null;
            const o = null !== (t = Le(this.padding && "auto" !== this.padding ? Rt(this.padding, {
                    ...this.context,
                    registers: e.registers
                }) : a.getRegisterAsDimension("fboxsep"))) && void 0 !== t ? t : 0,
                r = function(e) {
                    if (!e) return "1px";
                    const t = e.match(/([0-9][a-zA-Z\%]+)/);
                    return null === t ? "1px" : t[1]
                }(this.borderStyle),
                n = new Ne(null, {
                    classes: "ML__notation"
                });
            n.setStyle("position", "absolute"), n.setStyle("z-index", "-1"), n.setStyle("box-sizing", "border-box"), n.setStyle("top", `calc(-${r} / 2 - ${o}em)`), n.setStyle("left", `calc(-${r} / 2 - ${o}em)`), n.setStyle("height", `calc(100% + ${2*o}em + 2 * ${r})`), n.height = i.height + o, n.depth = i.depth + o, n.setStyle("width", `calc(100% + ${2*o}em + 2 * ${r})`), this.backgroundcolor && n.setStyle("background-color", this.backgroundcolor), this.notation.box && n.setStyle("border", this.borderStyle), this.notation.actuarial && (n.setStyle("border-top", this.borderStyle), n.setStyle("border-right", this.borderStyle)), this.notation.madruwb && (n.setStyle("border-bottom", this.borderStyle), n.setStyle("border-right", this.borderStyle)), this.notation.roundedbox && (n.setStyle("border-radius", "8px"), n.setStyle("border", this.borderStyle)), this.notation.circle && (n.setStyle("border-radius", "50%"), n.setStyle("border", this.borderStyle)), this.notation.top && n.setStyle("border-top", this.borderStyle), this.notation.left && n.setStyle("border-left", this.borderStyle), this.notation.right && n.setStyle("border-right", this.borderStyle), this.notation.bottom && n.setStyle("border-bottom", this.borderStyle);
            let s = "";
            if (this.notation.horizontalstrike && (s += '<line x1="3%"  y1="50%" x2="97%" y2="50%"', s += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, s += ' stroke-linecap="round"', this.svgStrokeStyle && (s += ` stroke-dasharray="${this.svgStrokeStyle}"`), s += "/>"), this.notation.verticalstrike && (s += '<line x1="50%"  y1="3%" x2="50%" y2="97%"', s += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, s += ' stroke-linecap="round"', this.svgStrokeStyle && (s += ` stroke-dasharray="${this.svgStrokeStyle}"`), s += "/>"), this.notation.updiagonalstrike && (s += '<line x1="3%"  y1="97%" x2="97%" y2="3%"', s += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, s += ' stroke-linecap="round"', this.svgStrokeStyle && (s += ` stroke-dasharray="${this.svgStrokeStyle}"`), s += "/>"), this.notation.downdiagonalstrike && (s += '<line x1="3%"  y1="3%" x2="97%" y2="97%"', s += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, s += ' stroke-linecap="round"', this.svgStrokeStyle && (s += ` stroke-dasharray="${this.svgStrokeStyle}"`), s += "/>"), s) {
                let e;
                "none" !== this.shadow && (e = "auto" === this.shadow ? "filter: drop-shadow(0 0 .5px rgba(255, 255, 255, .7)) drop-shadow(1px 1px 2px #333)" : "filter: drop-shadow(" + this.shadow + ")"),
                    function(e, t, a) {
                        e.svgOverlay = t, e.svgStyle = a
                    }(n, s, e)
            }
            const l = new Ne([n, i]);
            return l.setStyle("position", "relative"), l.setStyle("display", "inline"), l.height = i.height + o, l.depth = i.depth + o, l.left = o, l.right = o, this.caret && (l.caret = this.caret), l.wrap(a)
        }
        constructor(e, t, a, i, o) {
            super("enclose", i, {
                command: e,
                style: o.style
            }), this.body = t, this.backgroundcolor = o.backgroundcolor, a.updiagonalarrow && (a.updiagonalstrike = !1), a.box && (a.left = !1, a.right = !1, a.bottom = !1, a.top = !1), this.notation = a, this.shadow = o.shadow, this.strokeWidth = o.strokeWidth, this.strokeStyle = o.strokeStyle, this.svgStrokeStyle = o.svgStrokeStyle, this.strokeColor = o.strokeColor, this.borderStyle = o.borderStyle, this.padding = o.padding, this.captureSelection = !0
        }
    }
    class ea extends lt {
        static fromJson(e, t) {
            return new ea(e.command, e.above, e.below, t, e)
        }
        toJson() {
            const e = {};
            return this.continuousFraction && (e.continuousFraction = !0), this.numerPrefix && (e.numerPrefix = this.numerPrefix), this.denomPrefix && (e.denomPrefix = this.denomPrefix), this.leftDelim && (e.leftDelim = this.leftDelim), this.rightDelim && (e.rightDelim = this.rightDelim), this.hasBarLine || (e.hasBarLine = !1), this.mathstyleName && (e.mathstyleName = this.mathstyleName), {
                ...super.toJson(),
                ...e
            }
        }
        serialize(e) {
            return this.command + `{${this.aboveToLatex(e)}}` + `{${this.belowToLatex(e)}}`
        }
        get children() {
            if (this._children) return this._children;
            const e = [];
            if ("numerator-denominator" === this.context.fractionNavigationOrder) {
                for (const t of this.above) e.push(...t.children), e.push(t);
                for (const t of this.below) e.push(...t.children), e.push(t)
            } else {
                for (const t of this.below) e.push(...t.children), e.push(t);
                for (const t of this.above) e.push(...t.children), e.push(t)
            }
            return this._children = e, e
        }
        render(e) {
            var t, a;
            const i = new Ae(e, this.style, this.mathstyleName),
                o = i.metrics,
                r = new Ae(i, this.style, this.continuousFraction ? "" : "numerator"),
                n = this.numerPrefix ? new Ne([new Ne(this.numerPrefix), lt.createBox(r, this.above)], {
                    isTight: r.isTight,
                    newList: !0
                }) : null !== (t = lt.createBox(r, this.above, {
                    newList: !0
                })) && void 0 !== t ? t : new Ne(null, {
                    newList: !0
                }),
                s = new Ae(i, this.style, this.continuousFraction ? "" : "denominator"),
                l = this.denomPrefix ? new Ne([new Ne(this.denomPrefix), lt.createBox(s, this.below, {
                    newList: !0
                })]) : null !== (a = lt.createBox(s, this.below, {
                    newList: !0
                })) && void 0 !== a ? a : new Ne(null, {
                    newList: !0
                }),
                d = this.hasBarLine ? o.defaultRuleThickness : 0;
            let c, u, p = 0;
            i.isDisplayStyle ? (c = o.num1, p = d > 0 ? 3 * d : 7 * d, u = o.denom1) : (d > 0 ? (c = o.num2, p = d) : (c = o.num3, p = 3 * d), u = o.denom2);
            const h = [];
            this.isSelected && h.push("ML__selected");
            const m = n.depth,
                f = l.height;
            let y;
            if (d <= 0) {
                const e = c - m - (f - u);
                e < p && (c += (p - e) / 2, u += (p - e) / 2), y = new We({
                    individualShift: [{
                        box: n,
                        shift: -c,
                        classes: [...h, "ML__center"]
                    }, {
                        box: l,
                        shift: u,
                        classes: [...h, "ML__center"]
                    }]
                }).wrap(i)
            } else {
                const e = .25 + d / 2,
                    t = .25 - d / 2;
                c < p + m + e && (c = p + m + e), u < p + f - t && (u = p + f - t);
                const a = new Ne(null, {
                    classes: "ML__frac-line",
                    mode: this.mode,
                    style: this.style
                });
                a.height = d / 2, a.depth = d / 2, y = new We({
                    individualShift: [{
                        box: l,
                        shift: u,
                        classes: [...h, "ML__center"]
                    }, {
                        box: a,
                        shift: d / 2 - t,
                        classes: h
                    }, {
                        box: n,
                        shift: -c,
                        classes: [...h, "ML__center"]
                    }]
                }).wrap(i)
            }
            const b = i.isDisplayStyle ? o.delim1 : o.delim2,
                g = this.isSelected ? " ML__selected" : "",
                v = this.leftDelim ? this.bind(e, St("mopen", this.leftDelim, b, !0, e, {
                    style: this.style,
                    mode: this.mode,
                    classes: g
                })) : Lt(i, "mopen");
            let k = null;
            k = this.continuousFraction ? new Ne(null, {
                type: "mclose"
            }) : this.rightDelim ? this.bind(e, St("mclose", this.rightDelim, b, !0, e, {
                style: this.style,
                mode: this.mode,
                classes: g
            })) : Lt(i, "mclose");
            const x = this.bind(e, new Ne([v, y, k], {
                isTight: i.isTight,
                type: "mord",
                classes: "mfrac"
            }));
            return x ? (this.caret && (x.caret = this.caret), this.attachSupsub(e, {
                base: x
            })) : null
        }
        constructor(e, t, a, i, o) {
            var r, n;
            super("genfrac", i, {
                style: o.style,
                command: e,
                serialize: o.serialize,
                displayContainsHighlight: !0
            }), this.above = t, this.below = a, this.hasBarLine = null === (r = null == o ? void 0 : o.hasBarLine) || void 0 === r || r, this.continuousFraction = null !== (n = null == o ? void 0 : o.continuousFraction) && void 0 !== n && n, this.numerPrefix = null == o ? void 0 : o.numerPrefix, this.denomPrefix = null == o ? void 0 : o.denomPrefix, this.mathstyleName = null == o ? void 0 : o.mathstyleName, this.leftDelim = null == o ? void 0 : o.leftDelim, this.rightDelim = null == o ? void 0 : o.rightDelim
        }
    }
    class ta extends lt {
        static fromJson(e, t) {
            const a = new ta(e.command, t);
            return e.isSuggestion && (a.isSuggestion = !0), e.isError && (a.isError = !0), a
        }
        toJson() {
            const e = {};
            return this.isSuggestion && (e.isSuggestion = !0), this.isError && (e.isError = !0), {
                ...super.toJson(),
                ...e
            }
        }
        get computedStyle() {
            return {}
        }
        render(e) {
            const t = new Ne(this.value, {
                classes: this.isSuggestion ? "ML__suggestion" : this.isError ? "ML__error" : "",
                type: "latex",
                maxFontSize: 1
            });
            return t ? (this.caret && (t.caret = this.caret), this.bind(e, t)) : null
        }
        constructor(e, t, a) {
            var i;
            super("latex", t, {
                value: e,
                mode: "latex"
            }), this.isSuggestion = null !== (i = null == a ? void 0 : a.isSuggestion) && void 0 !== i && i, this.isError = !1, this.verbatimLatex = e
        }
    }
    class aa extends lt {
        static fromJson(e, t) {
            return new aa("", t)
        }
        toJson() {
            return super.toJson()
        }
        render(e) {
            const t = lt.createBox(e, this.body, {
                newList: !0
            });
            return t ? (this.caret && (t.caret = this.caret), this.bind(e, t)) : null
        }
        serialize(e) {
            var t, a;
            return null !== (a = null === (t = this.body) || void 0 === t ? void 0 : t.map((e => e.value)).join("")) && void 0 !== a ? a : ""
        }
        constructor(e, t) {
            super("latexgroup", t, {
                mode: "latex"
            }), this.body = [...e].map((e => new ta(e, t))), this.skipBoundary = !1
        }
    }
    class ia extends lt {
        static fromJson(e, t) {
            return new ia(e.command, e.body, t, e)
        }
        toJson() {
            return {
                ...super.toJson(),
                position: this.position
            }
        }
        render(e) {
            const t = new Ae(e, this.style, "cramp"),
                a = lt.createBox(t, this.body);
            if (!a) return null;
            const i = t.metrics.defaultRuleThickness / t.scalingFactor,
                o = new Ne(null, {
                    classes: this.position + "-line"
                });
            let r;
            return o.height = i, o.maxFontSize = 1.125 * i * t.scalingFactor, r = "overline" === this.position ? new We({
                shift: 0,
                children: [{
                    box: a
                }, 3 * i, {
                    box: o
                }, i]
            }) : new We({
                top: a.height,
                children: [i, {
                    box: o
                }, 3 * i, {
                    box: a
                }]
            }), this.caret && (r.caret = this.caret), new Ne(r, {
                classes: this.position,
                type: "mord"
            })
        }
        constructor(e, t, a, i) {
            super("line", a, {
                command: e,
                style: i.style
            }), this.skipBoundary = !0, this.body = t, this.position = i.position
        }
    }
    class oa extends lt {
        static fromJson(e, t) {
            return new oa(e.command, e.body ? e.body : e.value, t, e)
        }
        toJson() {
            const e = super.toJson();
            return this.hasArgument && (e.hasArgument = !0), this.variant && (e.variant = this.variant), this.variantStyle && (e.variantStyle = this.variantStyle), this.subsupPlacement && (e.limits = this.subsupPlacement), this.isExtensibleSymbol && (e.isExtensibleSymbol = !0), this.value && (e.symbol = this.value), e
        }
        render(e) {
            var t;
            let a, i = 0,
                o = 0;
            if (this.isExtensibleSymbol) {
                const t = e.isDisplayStyle && "\\smallint" !== this.value;
                if (a = new Ne(this.value, {
                        fontFamily: t ? "Size2-Regular" : "Size1-Regular",
                        classes: "op-symbol " + (t ? "large-op" : "small-op"),
                        type: "mop",
                        maxFontSize: e.scalingFactor
                    }), !a) return null;
                a.right = a.italic, i = (a.height - a.depth) / 2 - .25 * e.scalingFactor, o = a.italic, a.setStyle("color", this.style.color), a.setStyle("background-color", this.style.backgroundColor)
            } else if (this.body) {
                if (a = lt.createBox(e, this.body, {
                        newList: !0
                    }), !a) return null;
                a.setStyle("color", this.style.color), a.setStyle("background-color", this.style.backgroundColor)
            } else a = new Ne(this.value, {
                type: "mop",
                mode: "math",
                maxFontSize: e.scalingFactor,
                style: {
                    color: this.style.color,
                    backgroundColor: this.style.backgroundColor,
                    letterShapeStyle: e.letterShapeStyle,
                    variant: this.variant,
                    variantStyle: this.variantStyle
                }
            });
            this.isExtensibleSymbol && a.setTop(i);
            let r = a;
            if (this.superscript || this.subscript) {
                const n = null !== (t = this.subsupPlacement) && void 0 !== t ? t : "auto";
                r = "over-under" === n || "auto" === n && e.isDisplayStyle ? this.attachLimits(e, {
                    base: a,
                    baseShift: i,
                    slant: o
                }) : this.attachSupsub(e, {
                    base: a
                })
            }
            return this.caret && (r.caret = this.caret), new Ne(this.bind(e, r), {
                type: "mop",
                classes: "op-group" + (this.isSelected ? " ML__selected" : "")
            })
        }
        serialize(e) {
            if ("​" === this.value) return this.supsubToLatex(e);
            const t = [];
            return t.push(this.command), this.hasArgument && t.push(`{${this.bodyToLatex(e)}}`), this.explicitSubsupPlacement && ("over-under" === this.subsupPlacement && t.push("\\limits"), "adjacent" === this.subsupPlacement && t.push("\\nolimits"), "auto" === this.subsupPlacement && t.push("\\displaylimits")), t.push(this.supsubToLatex(e)), at(t)
        }
        constructor(e, t, a, i) {
            var o, r, n, s;
            super(null !== (o = i.type) && void 0 !== o ? o : "mop", a, {
                command: e,
                style: i.style,
                isFunction: null == i ? void 0 : i.isFunction
            }), "string" == typeof t ? this.value = t : this.body = t, this.captureSelection = null !== (r = i.captureSelection) && void 0 !== r && r, this.hasArgument = null !== (n = i.hasArgument) && void 0 !== n && n, this.variant = null == i ? void 0 : i.variant, this.variantStyle = null == i ? void 0 : i.variantStyle, this.subsupPlacement = null == i ? void 0 : i.limits, this.isExtensibleSymbol = null !== (s = null == i ? void 0 : i.isExtensibleSymbol) && void 0 !== s && s
        }
    }
    class ra extends lt {
        static fromJson(e, t) {
            return new ra(e.command, e.body, t, e)
        }
        toJson() {
            const e = {};
            return this.align && (e.align = this.align), this.boxType && (e.boxType = this.boxType), {
                ...super.toJson(),
                ...e
            }
        }
        render(e) {
            const t = lt.createBox(e, this.body, {
                classes: "inner"
            });
            return t ? (this.caret && (t.caret = this.caret), this.bind(e, new Ne([t, new Ne(null, {
                classes: "fix"
            })], {
                classes: "left" === this.align ? "llap" : "rlap",
                type: this.boxType
            }))) : null
        }
        constructor(e, t, a, i) {
            var o, r;
            super("overlap", a, {
                command: e,
                style: null == i ? void 0 : i.style
            }), this.skipBoundary = !0, this.body = "string" == typeof t ? [new lt("mord", a, {
                value: t
            })] : t, this.align = null !== (o = null == i ? void 0 : i.align) && void 0 !== o ? o : "left", this.boxType = null !== (r = null == i ? void 0 : i.boxType) && void 0 !== r ? r : "mord"
        }
    }
    class na extends lt {
        static fromJson(e, t) {
            return new na(e.command, e.body, t, e)
        }
        toJson() {
            const e = {};
            return this.isInvisible && (e.isInvisible = !0), this.smashDepth && (e.smashDepth = !0), this.smashHeight && (e.smashHeight = !0), this.smashWidth && (e.smashWidth = !0), {
                ...super.toJson(),
                ...e
            }
        }
        render(e) {
            const t = new Ae(e, {
                isPhantom: !0
            });
            if (!this.smashDepth && !this.smashHeight && !this.smashWidth) return lt.createBox(t, this.body, {
                classes: "inner"
            });
            const a = lt.createBox(this.isInvisible ? t : e, this.body);
            if (!a) return null;
            if (this.smashWidth) {
                const t = new Ne(null, {
                    classes: "fix"
                });
                return new Ne([a, t], {
                    classes: "rlap"
                }).wrap(e)
            }
            if (!this.smashHeight && !this.smashDepth) return a;
            if (this.smashHeight && (a.height = 0), this.smashDepth && (a.depth = 0), a.children)
                for (const e of a.children) this.smashHeight && (e.height = 0), this.smashDepth && (e.depth = 0);
            return new We({
                firstBaseline: [{
                    box: a
                }]
            }, {
                type: "mord"
            }).wrap(e)
        }
        constructor(e, t, a, i) {
            var o, r, n, s;
            super("phantom", a, {
                command: e,
                style: i.style
            }), this.captureSelection = !0, this.body = t, this.isInvisible = null !== (o = i.isInvisible) && void 0 !== o && o, this.smashDepth = null !== (r = i.smashDepth) && void 0 !== r && r, this.smashHeight = null !== (n = i.smashHeight) && void 0 !== n && n, this.smashWidth = null !== (s = i.smashWidth) && void 0 !== s && s
        }
    }
    class sa extends lt {
        static fromJson(e, t) {
            return new sa(e.command, t, e)
        }
        toJson() {
            const e = {
                height: this.height,
                width: this.width
            };
            return this.shift && (e.shift = this.shift), {
                ...super.toJson(),
                ...e
            }
        }
        render(e) {
            const t = new Ae(e, this.style, "textstyle"),
                a = Le(this.shift),
                i = Le(this.width),
                o = Le(this.height),
                r = new Ne(null, {
                    classes: "rule",
                    type: "mord"
                });
            return r.setStyle("border-right-width", i, "em"), r.setStyle("border-top-width", o, "em"), r.setStyle("border-color", this.style.color), r.setStyle("vertical-align", a, "em"), this.isSelected && r.setStyle("opacity", "50%"), r.width = i, r.height = o + a, r.depth = -a, this.bind(e, r), this.caret && (r.caret = this.caret), r.wrap(t)
        }
        serialize(e) {
            var t;
            let a = null !== (t = this.command) && void 0 !== t ? t : "";
            return this.shift && (a += `[${Ce(this.shift)}]`), a += `{${Ce(this.width)}}{${Ce(this.height)}}`, a
        }
        constructor(e, t, a) {
            var i;
            super("rule", t, {
                command: e,
                style: a.style
            }), this.shift = null !== (i = a.shift) && void 0 !== i ? i : {
                dimension: 0
            }, this.height = a.height, this.width = a.width
        }
    }
    class la extends lt {
        static fromJson(e, t) {
            return new la(e.command, t, {
                ...e,
                index: e.above
            })
        }
        toJson() {
            return super.toJson()
        }
        serialize(e) {
            let t = "";
            return this.above && (t += `[${this.aboveToLatex(e)}]`), t += `{${this.bodyToLatex(e)}}`, this.command + t
        }
        render(e) {
            var t;
            const a = new Ae(e, this.style, "cramp"),
                i = null !== (t = lt.createBox(a, this.body, {
                    style: this.style,
                    newList: !0
                })) && void 0 !== t ? t : new Ne(null),
                o = a.scalingFactor,
                r = a.metrics.defaultRuleThickness / o,
                n = e.isDisplayStyle ? .431 : r,
                s = new Ne(null, {
                    classes: "ML__sqrt-line",
                    style: this.style,
                    height: r
                });
            let l = o * (r + n / 4);
            const d = Math.max(2 * o * n, i.height + i.depth) + l + r,
                c = new Ae(e, this.style),
                u = this.isSelected ? " ML__selected" : "",
                p = this.bind(c, new Ne(St("", "\\surd", d, !1, c, {
                    classes: u
                }), {
                    classes: "ML__sqrt-sign" + u,
                    style: this.style
                }));
            if (!p) return null;
            const h = p.height + p.depth - r;
            h > i.height + i.depth + l && (l = (l + h - (i.height + i.depth)) / 2), p.setTop(p.height - i.height - l);
            const m = this.bind(e, new We({
                    firstBaseline: [{
                        box: new Ne(i)
                    }, l - 2 * r, {
                        box: s
                    }, r]
                }).wrap(e)),
                f = lt.createBox(new Ae(e, this.style, "scriptscriptstyle"), this.above, {
                    style: this.style,
                    newList: !0
                });
            if (!f) {
                const t = new Ne([p, m], {
                    classes: this.containsCaret ? "ML__contains-caret" : "",
                    type: "mord"
                });
                return this.caret && (t.caret = this.caret), this.bind(e, t.wrap(e))
            }
            const y = new We({
                    shift: -.6 * (Math.max(p.height, m.height) - Math.max(p.depth, m.depth)),
                    children: [{
                        box: f
                    }]
                }),
                b = new Ne([new Ne(y, {
                    classes: "ML__sqrt-index"
                }), p, m], {
                    type: "mord",
                    classes: this.containsCaret ? "ML__contains-caret" : ""
                });
            return b.height = p.height, b.depth = p.depth, this.caret && (b.caret = this.caret), this.bind(e, b.wrap(e))
        }
        constructor(e, t, a) {
            var i;
            super("surd", t, {
                command: e,
                mode: null !== (i = a.mode) && void 0 !== i ? i : "math",
                style: a.style,
                displayContainsHighlight: !0
            }), this.body = a.body, this.above = a.index
        }
    }
    const da = {
            "p@": "1pt ",
            "z@": "0pt",
            maxdimen: "16383.99999pt",
            hfuzz: "0.1pt",
            vfuzz: "0.1pt",
            overfullrule: "5pt",
            hsize: "6.5in",
            vsize: "8.9in",
            parindent: "20pt",
            maxdepth: "4pt",
            splitmaxdepth: "\\maxdimen",
            boxmaxdepth: "\\maxdimen",
            delimitershortfall: "5pt",
            nulldelimiterspace: "1.2pt",
            scriptspace: "0.5pt",
            topskip: "10pt",
            splittopskip: "10pt",
            normalbaselineskip: "12pt",
            normallineskip: "1pt",
            normallineskiplimit: "0pt",
            jot: "3pt",
            doublerulesep: "2pt",
            arrayrulewidth: "0.4pt",
            arraycolsep: "5pt",
            fboxsep: "3pt",
            fboxrule: "0.4pt"
        },
        ca = {
            "z@skip": "0pt plust0pt minus0pt",
            hideskip: "-1000pt plust 1fill",
            "@flushglue": "0pt plust 1fill",
            parskip: "0pt plus 1pt",
            abovedisplayskip: "12pt plus 3pt minus 9pt",
            abovedisplayshortskip: "0pt plus 3pt",
            belowdisplayskip: "12pt plus 3pt minus 9pt",
            belowdisplayshortskip: "7pt plus 3pt minus 4pt",
            parfillskip: "0pt plus 1fil",
            thinmuskip: "3mu",
            medmuskip: "4mu plus 2mu minus 4mu",
            thickmuskip: "5mu plus 5mu",
            smallskipamount: "3pt plus1pt minus1pt",
            medskipamount: "6pt plus2pt minus2pt",
            bigskipamount: "12pt plus4pt minus4pt"
        },
        ua = {
            pretolerance: 100,
            tolerance: 200,
            hbadness: 1e3,
            vbadness: 1e3,
            linepenalty: 10,
            hyphenpenalty: 50,
            exhyphenpenalty: 50,
            binoppenalty: 700,
            relpenalty: 500,
            clubpenalty: 150,
            widowpenalty: 150,
            displaywidowpenalty: 50,
            brokenpenalty: 100,
            predisplaypenalty: 1e4,
            doublehyphendemerits: 1e4,
            finalhyphendemerits: 5e3,
            adjdemerits: 1e4,
            tracinglostchars: 1,
            uchyph: 1,
            delimiterfactor: 901,
            defaulthyphenchar: "\\-",
            defaultskewchar: -1,
            newlinechar: -1,
            showboxbreadth: 5,
            showboxdepth: 3,
            errorcontextlines: 5,
            interdisplaylinepenalty: 100,
            interfootnotelinepenalty: 100,
            baselineSkip: 1.2,
            arraystretch: "",
            month: (new Date).getMonth() + 1,
            day: (new Date).getDate(),
            year: (new Date).getFullYear()
        };
    let pa;

    function ha(e) {
        var t, a;
        if (pa) return pa;
        pa = {
            ...ua
        };
        for (const a of Object.keys(da)) pa[a] = null !== (t = Rt(da[a], e, pa)) && void 0 !== t ? t : 0;
        for (const t of Object.keys(ca)) pa[t] = null !== (a = Ft(ca[t], e, pa)) && void 0 !== a ? a : 0;
        return pa
    }

    function ma() {
        const e = {
            registers: {},
            smartFence: !1,
            fractionNavigationOrder: "numerator-denominator",
            placeholderSymbol: "▢",
            letterShapeStyle: c.locale.startsWith("fr") ? "french" : "tex",
            colorMap: g,
            backgroundColorMap: v,
            getDefinition: fa,
            getMacro: e => ya(e, H())
        };
        return {
            ...e,
            registers: ha(e)
        }
    }

    function fa(e, t = "math") {
        if (!e || 0 === e.length) return null;
        let a = null;
        if (e.startsWith("\\")) {
            if (a = M[e], a) return a;
            "math" === t ? a = _[e] : A[e] && (a = {
                definitionType: "symbol",
                type: "mord",
                codepoint: A[e]
            })
        } else if ("math" === t) {
            if (a = _[e], !a && 1 === e.length) {
                const t = $("math", e.codePointAt(0));
                return t.startsWith("\\") ? {
                    ...fa(t, "math"),
                    command: t
                } : null
            }
        } else A[e] ? a = {
            definitionType: "symbol",
            type: "mord",
            codepoint: A[e]
        } : "text" === t && (a = {
            definitionType: "symbol",
            type: "mord",
            codepoint: e.codePointAt(0)
        });
        return !a || "symbol" !== a.definitionType || "mord" !== a.type || 102 !== a.codepoint && 103 !== a.codepoint && 104 !== a.codepoint || (a.isFunction = !0), null != a ? a : null
    }

    function ya(e, t) {
        return e.startsWith("\\") ? t[e.slice(1)] : null
    }
    class ba extends lt {
        static fromJson(e, t) {
            return new ba(e.body, ga(e.tooltip, t), t, e)
        }
        toJson() {
            var e;
            const t = null === (e = this.tooltip.body) || void 0 === e ? void 0 : e.filter((e => "first" !== e.type)).map((e => e.toJson()));
            return {
                ...super.toJson(),
                tooltip: t
            }
        }
        render(e) {
            const t = lt.createBox(e, this.body, {
                style: this.style
            });
            if (!t) return null;
            const a = Fe(Ve(new Ne(this.tooltip.render(new Ae({
                    registers: e.registers
                }, {
                    fontSize: 5
                }, "displaystyle")), {
                    classes: "ML__tooltip-content"
                }))),
                i = new Ne([a, t], {
                    classes: "ML__tooltip-container"
                });
            return this.caret && (i.caret = this.caret), this.bind(e, i)
        }
        serialize(e) {
            return `${this.command}{${this.bodyToLatex(e)}}{${lt.serialize(this.tooltip.body,e)}}`
        }
        constructor(e, t, a, i) {
            super("tooltip", a, {
                command: null == i ? void 0 : i.command,
                mode: "math",
                serialize: null == i ? void 0 : i.serialize,
                style: null == i ? void 0 : i.style,
                displayContainsHighlight: !0
            }), this.body = e;
            const o = ma();
            this.tooltip = new lt("root", o, {
                style: {}
            }), this.tooltip.body = t, this.skipBoundary = !0, this.captureSelection = !1
        }
    }

    function ga(e, t) {
        if (i(e)) return e.map((e => ga(e, t)));
        e = {
            ...e
        };
        for (const a of rt) e[a] && (e[a] = ga(e[a], t));
        e.array && (e.array = ga(e.array, t));
        const a = e.type;
        let o;
        "accent" === a && (o = ut.fromJson(e, t)), "array" === a && (o = Vt.fromJson(e, t)), "box" === a && (o = It.fromJson(e, t)), "composition" === a && (o = Jt.fromJson(e, t)), "chem" === a && (o = Ut.fromJson(e, t)), "choice" === a && (o = va.fromJson(e, t)), "delim" === a && (o = Zt.fromJson(e, t)), "enclose" === a && (o = Qt.fromJson(e, t)), "error" === a && (o = Kt.fromJson(e, t)), "genfrac" === a && (o = ea.fromJson(e, t)), "group" === a && (o = At.fromJson(e, t)), "latex" === a && (o = ta.fromJson(e, t)), "latexgroup" === a && (o = aa.fromJson(e, t)), "leftright" === a && (o = Tt.fromJson(e, t)), "line" === a && (o = ia.fromJson(e, t)), "macro" === a && (o = qt.fromJson(e, t)), "msubsup" === a && (o = zt.fromJson(e, t)), "overlap" === a && (o = ra.fromJson(e, t)), "overunder" === a && (o = Ct.fromJson(e, t)), "placeholder" === a && (e.defaultValue && (e.defaultValue = ga(e.defaultValue, t)), o = Bt.fromJson(e, t)), "phantom" === a && (o = na.fromJson(e, t)), "rule" === a && (o = sa.fromJson(e, t)), "sizeddelim" === a && (o = Yt.fromJson(e, t)), "spacing" === a && (o = Dt.fromJson(e, t)), "surd" === a && (o = la.fromJson(e, t)), "text" === a && (o = $t.fromJson(e, t)), "tooltip" === a && (o = ba.fromJson(e, t)), "mop" === a && (o = oa.fromJson(e, t)), o || (o = lt.fromJson(e, t));
        for (const t of rt) e[t] && o.setChildren(e[t], t);
        return void 0 !== e.verbatimLatex && (o.verbatimLatex = e.verbatimLatex), e.subsupPlacement && (o.subsupPlacement = e.subsupPlacement), e.explicitSubsupPlacement && (o.explicitSubsupPlacement = !0), e.isFunction && (o.isFunction = !0), e.isExtensibleSymbol && (o.isExtensibleSymbol = !0), e.skipBoundary && (o.skipBoundary = !0), e.captureSelection && (o.captureSelection = !0), o
    }
    class va extends lt {
        static fromJson(e, t) {
            return new va([ga(e.choices[0], t), ga(e.choices[1], t), ga(e.choices[2], t), ga(e.choices[3], t)], t)
        }
        toJson() {
            const e = [];
            for (const t of this.choices) e.push(t.filter((e => "first" !== e.type)).map((e => e.toJson())));
            return {
                ...super.toJson(),
                choices: e
            }
        }
        render(e) {
            const t = lt.createBox(e, this.choices[Math.floor(e.mathstyle.id / 2)]);
            return t ? (this.caret && (t.caret = this.caret), this.bind(e, t)) : null
        }
        serialize(e) {
            return `\\mathchoice{${lt.serialize(this.choices[0],e)}}{${lt.serialize(this.choices[1],e)}}{${lt.serialize(this.choices[2],e)}}{${lt.serialize(this.choices[3],e)}}`
        }
        constructor(e, t) {
            super("choice", t), this.choices = e, this.skipBoundary = !0
        }
    }
    V("mathtip", "{:math}{:math}", {
        createAtom: (e, t, a, i) => new ba(t[0], t[1], i, {
            command: e,
            content: "math",
            style: a
        })
    }), V("texttip", "{:math}{:text}", {
        createAtom: (e, t, a, i) => new ba(t[0], t[1], i, {
            command: e,
            content: "text",
            style: a
        })
    }), V("error", "{:math}", {
        createAtom: (e, t, a, i) => new At(t[0], i, {
            mode: "math",
            command: "\\error",
            customClass: "ML__error",
            style: a,
            serialize: (e, t) => `\\error{${e.bodyToLatex(t)}}`
        })
    }), V("ensuremath", "{:math}", {
        createAtom: (e, t, a, i) => new At(t[0], i, {
            mode: "math",
            latexOpen: "\\ensuremath{",
            latexClose: "}",
            style: a
        })
    }), V("color", "{:string}", {
        applyStyle: (e, t, a) => {
            var i, o;
            const r = t[0];
            return {
                verbatimColor: t[0],
                color: null !== (o = null === (i = a.colorMap) || void 0 === i ? void 0 : i.call(a, r)) && void 0 !== o ? o : r
            }
        }
    }), V("textcolor", "{:string}{content:auto*}", {
        applyStyle: (e, t, a) => {
            var i, o;
            const r = t[0];
            return {
                verbatimColor: r,
                color: null !== (o = null === (i = a.colorMap) || void 0 === i ? void 0 : i.call(a, r)) && void 0 !== o ? o : r
            }
        }
    }), V("boxed", "{content:math}", {
        createAtom: (e, t, a, i) => new It(e, t[0], i, {
            framecolor: "black",
            style: a
        })
    }), V("colorbox", "{:string}{content:auto*}", {
        applyMode: "text",
        applyStyle: (e, t, a) => {
            var i, o;
            const r = t[0];
            return {
                verbatimBackgroundColor: t[0],
                backgroundColor: null !== (o = null === (i = a.backgroundColorMap) || void 0 === i ? void 0 : i.call(a, r)) && void 0 !== o ? o : r
            }
        }
    }), V("fcolorbox", "{frame-color:string}{background-color:string}{content:auto}", {
        applyMode: "text",
        createAtom: (e, t, a, i) => {
            var o, r, n, s;
            const l = t[0],
                d = t[1];
            return new It(e, t[2], i, {
                verbatimFramecolor: l,
                framecolor: null !== (r = null === (o = i.colorMap) || void 0 === o ? void 0 : o.call(i, l)) && void 0 !== r ? r : l,
                verbatimBackgroundcolor: t[1],
                backgroundcolor: null !== (s = null === (n = i.backgroundColorMap) || void 0 === n ? void 0 : n.call(i, d)) && void 0 !== s ? s : d,
                style: a,
                serialize: (e, t) => {
                    var a, i;
                    return `${e.command}{${null!==(a=e.verbatimFramecolor)&&void 0!==a?a:e.framecolor}{${null!==(i=e.verbatimBackgroundcolor)&&void 0!==i?i:e.backgroundcolor}}{${e.bodyToLatex(t)}}`
                }
            })
        }
    }), V("bbox", "[:bbox]{body:auto}", {
        createAtom: (e, t, a, i) => {
            if (t[0]) {
                const o = t[0];
                return new It(e, t[1], i, {
                    padding: o.padding,
                    border: o.border,
                    backgroundcolor: o.backgroundcolor,
                    style: a,
                    serialize: (t, a) => {
                        var i;
                        let o = e;
                        if (Number.isFinite(t.padding) || void 0 !== t.border || void 0 !== t.backgroundcolor) {
                            const e = [];
                            t.padding && e.push(t.padding), t.border && e.push(`border: ${t.border}`), (t.verbatimBackgroundcolor || t.backgroundcolor) && e.push(null !== (i = t.verbatimBackgroundcolor) && void 0 !== i ? i : t.backgroundcolor), o += `[${e.join(",")}]`
                        }
                        return o + `{${t.bodyToLatex(a)}}`
                    }
                })
            }
            return new It(e, t[1], i, {
                style: a
            })
        }
    }), V(["displaystyle", "textstyle", "scriptstyle", "scriptscriptstyle"], "{:rest}", {
        createAtom: (e, t, a, i) => new At(t[0], i, {
            latexOpen: `{${e} `,
            latexClose: "}",
            style: a,
            mathstyleName: e.slice(1)
        })
    }), V(["tiny", "scriptsize", "footnotesize", "small", "normalsize", "large", "Large", "LARGE", "huge", "Huge"], "", {
        applyStyle: (e, t) => ({
            fontSize: {
                "\\tiny": 1,
                "\\scriptsize": 2,
                "\\footnotesize": 3,
                "\\small": 4,
                "\\normalsize": 5,
                "\\large": 6,
                "\\Large": 7,
                "\\LARGE": 8,
                "\\huge": 9,
                "\\Huge": 10
            } [e]
        })
    }), V("fontseries", "{:string}", {
        ifMode: "text",
        applyStyle: (e, t) => ({
            fontSeries: t[0]
        })
    }), V("fontshape", "{:string}", {
        ifMode: "text",
        applyStyle: (e, t) => ({
            fontShape: t[0]
        })
    }), V("fontfamily", "{:string}", {
        ifMode: "text",
        applyStyle: (e, t) => ({
            fontFamily: t[0]
        })
    }), V("selectfont", "", {
        ifMode: "text",
        applyStyle: (e, t) => ({})
    }), V("bf", "", {
        applyStyle: (e, t) => ({
            fontSeries: "b",
            fontShape: "n",
            fontFamily: "cmr"
        })
    }), V(["boldsymbol", "bm"], "{:math*}", {
        applyMode: "math",
        createAtom: (e, t, a, i) => new At(t[0], i, {
            latexOpen: `${e}{`,
            latexClose: "}",
            style: a,
            customClass: "ML__boldsymbol"
        })
    }), V("bold", "{:math*}", {
        applyMode: "math",
        applyStyle: (e, t) => ({
            variantStyle: "bold"
        })
    }), V("bfseries", "", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontSeries: "b"
        })
    }), V("mdseries", "", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontSeries: "m"
        })
    }), V("upshape", "", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontShape: "n"
        })
    }), V("slshape", "", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontShape: "sl"
        })
    }), V("scshape", "", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontShape: "sc"
        })
    }), V("textbf", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontSeries: "b"
        })
    }), V("textmd", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontSeries: "m"
        })
    }), V("textup", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontShape: "n"
        })
    }), V("textnormal", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontShape: "n",
            fontSeries: "m"
        })
    }), V("textsl", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontShape: "sl"
        })
    }), V("textit", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontShape: "it"
        })
    }), V("textsc", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontShape: "sc"
        })
    }), V("textrm", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontFamily: "roman"
        })
    }), V("textsf", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontFamily: "sans-serif"
        })
    }), V("texttt", "{:text*}", {
        applyMode: "text",
        applyStyle: (e, t) => ({
            fontFamily: "monospace"
        })
    }), V("mathbf", "{:math*}", {
        applyMode: "math",
        applyStyle: (e, t) => ({
            variant: "normal",
            variantStyle: "bold"
        })
    }), V("mathit", "{:math*}", {
        applyMode: "math",
        applyStyle: (e, t) => ({
            variant: "main",
            variantStyle: "italic"
        })
    }), V("mathnormal", "{:math*}", {
        applyMode: "math",
        applyStyle: (e, t) => ({
            variant: "normal",
            variantStyle: "italic"
        })
    }), V("mathbfit", "{:math*}", {
        applyMode: "math",
        applyStyle: (e, t) => ({
            variant: "main",
            variantStyle: "bolditalic"
        })
    }), V("mathrm", "{:math*}", {
        applyMode: "math",
        applyStyle: (e, t) => ({
            variant: "normal",
            variantStyle: "up"
        })
    }), V("mathsf", "{:math*}", {
        applyMode: "math",
        applyStyle: (e, t) => ({
            variant: "sans-serif",
            variantStyle: "up"
        })
    }), V("mathtt", "{:math*}", {
        applyMode: "math",
        applyStyle: (e, t) => ({
            variant: "monospace",
            variantStyle: "up"
        })
    }), V("it", "", {
        applyStyle: (e, t) => ({
            fontSeries: "m",
            fontShape: "it",
            fontFamily: "cmr",
            variantStyle: "italic"
        })
    }), V("rmfamily", "", {
        applyStyle: (e, t) => ({
            fontFamily: "roman"
        })
    }), V("sffamily", "", {
        applyStyle: (e, t) => ({
            fontFamily: "sans-serif"
        })
    }), V("ttfamily", "", {
        applyStyle: (e, t) => ({
            fontFamily: "monospace"
        })
    }), V(["Bbb", "mathbb"], "{:math*}", {
        applyStyle: (e, t) => ({
            variant: "double-struck",
            variantStyle: "up"
        })
    }), V(["frak", "mathfrak"], "{:math*}", {
        applyStyle: (e, t) => ({
            variant: "fraktur",
            variantStyle: "up"
        })
    }), V("mathcal", "{:math*}", {
        applyStyle: (e, t) => ({
            variant: "calligraphic",
            variantStyle: "up"
        })
    }), V("mathscr", "{:math*}", {
        applyStyle: (e, t) => ({
            variant: "script",
            variantStyle: "up"
        })
    }), V("mbox", "{:text}", {
        ifMode: "math",
        createAtom: (e, t, a, i) => new At(t[0], i, {
            changeMode: !0,
            style: a,
            mode: "text",
            command: e,
            serialize: (e, t) => `\\mbox{${e.bodyToLatex({...t,skipModeCommand:!0})}}`
        })
    }), V("text", "{:text}", {
        ifMode: "math",
        applyMode: "text"
    }), V("class", "{name:string}{content:auto*}", {
        createAtom: (e, t, a, i) => new At(t[1], i, {
            customClass: t[0],
            style: a
        })
    }), V("cssId", "{id:string}{content:auto}", {
        createAtom: (e, t, a, i) => new At(t[1], i, {
            cssId: t[0],
            style: a
        })
    }), V("htmlData", "{data:string}{content:auto}", {
        createAtom: (e, t, a, i) => new At(t[1], i, {
            htmlData: t[0],
            style: a
        })
    }), V("htmlStyle", "{data:string}{content:auto}", {
        createAtom: (e, t, a, i) => new At(t[1], i, {
            htmlStyle: t[0],
            style: a
        })
    }), V("em", "{:auto*}", {
        createAtom: (e, t, a, i) => new At(t[0], i, {
            latexOpen: "\\em",
            latexClose: "",
            customClass: "ML__emph",
            style: a
        })
    }), V("emph", "{:auto}", {
        createAtom: (e, t, a, i) => new At(t[0], i, {
            latexOpen: "\\emph{",
            latexClose: "}",
            customClass: "ML__emph",
            style: a
        })
    });
    const ka = {
        "\\bigl": {
            mclass: "mopen",
            size: 1
        },
        "\\Bigl": {
            mclass: "mopen",
            size: 2
        },
        "\\biggl": {
            mclass: "mopen",
            size: 3
        },
        "\\Biggl": {
            mclass: "mopen",
            size: 4
        },
        "\\bigr": {
            mclass: "mclose",
            size: 1
        },
        "\\Bigr": {
            mclass: "mclose",
            size: 2
        },
        "\\biggr": {
            mclass: "mclose",
            size: 3
        },
        "\\Biggr": {
            mclass: "mclose",
            size: 4
        },
        "\\bigm": {
            mclass: "mrel",
            size: 1
        },
        "\\Bigm": {
            mclass: "mrel",
            size: 2
        },
        "\\biggm": {
            mclass: "mrel",
            size: 3
        },
        "\\Biggm": {
            mclass: "mrel",
            size: 4
        },
        "\\big": {
            mclass: "mord",
            size: 1
        },
        "\\Big": {
            mclass: "mord",
            size: 2
        },
        "\\bigg": {
            mclass: "mord",
            size: 3
        },
        "\\Bigg": {
            mclass: "mord",
            size: 4
        }
    };
    V(["bigl", "Bigl", "biggl", "Biggl", "bigr", "Bigr", "biggr", "Biggr", "bigm", "Bigm", "biggm", "Biggm", "big", "Big", "bigg", "Bigg"], "{:delim}", {
        createAtom: (e, t, a, i) => new Yt(e, t[0], i, {
            size: ka[e].size,
            delimClass: ka[e].mclass,
            style: a
        })
    }), V(["hspace", "hspace*"], "{width:glue}", {
        createAtom: (e, t, a, i) => {
            var o;
            return new Dt(e, a, i, null !== (o = t[0]) && void 0 !== o ? o : {
                glue: {
                    dimension: 0
                }
            })
        }
    }), V(["mkern", "kern"], "{width:glue}", {
        createAtom: (e, t, a, i) => {
            var o;
            return new Dt(e, a, i, null !== (o = t[0]) && void 0 !== o ? o : {
                glue: {
                    dimension: 0
                }
            })
        }
    }), V("mspace", "{width:glue}", {
        createAtom: (e, t, a, i) => {
            var o;
            return new Dt(e, a, i, null !== (o = t[0]) && void 0 !== o ? o : {
                glue: {
                    dimension: 0
                }
            })
        }
    }), V("mathop", "{:auto}", {
        createAtom: (e, t, a, i) => new oa(e, t[0], i, {
            type: "mop",
            captureSelection: !0,
            limits: "over-under",
            isFunction: !0,
            hasArgument: !0,
            style: a
        })
    }), V("mathchoice", "{:math}{:math}{:math}{:math}", {
        createAtom: (e, t, a, i) => new va(t, i)
    }), V(["mathbin", "mathrel", "mathopen", "mathclose", "mathpunct", "mathord", "mathinner"], "{:auto}", {
        createAtom: (e, t, a, i) => new oa(e, t[0], i, {
            type: {
                "\\mathbin": "mbin",
                "\\mathrel": "mrel",
                "\\mathopen": "mopen",
                "\\mathclose": "mclose",
                "\\mathpunct": "mpunct",
                "\\mathord": "mord",
                "\\mathinner": "minner"
            } [e],
            captureSelection: !0,
            hasArgument: !0,
            style: a
        })
    }), V(["operatorname", "operatorname*"], "{operator:math}", {
        createAtom: (e, t, a, i) => {
            const o = new oa(e, t[0], i, {
                isFunction: !0,
                hasArgument: !0,
                limits: "\\operatorname" === e ? "adjacent" : "over-under",
                style: a
            });
            return o.captureSelection = !0, o.body && o.body.forEach((e => {
                var t;
                "first" !== e.type && (e.type = "mord", e.value = null !== (t = {
                    "∗": "*",
                    "−": "-"
                } [e.value]) && void 0 !== t ? t : e.value, e.isFunction = !1, e.style.variant || e.style.variantStyle || (e.style.variant = "main", e.style.variantStyle = "up"))
            })), o
        }
    });
    class xa extends lt {
        serialize(e) {
            return '\\unicode"' + ("000000" + this.codepoint.toString(16)).toUpperCase().slice(-6)
        }
        constructor(e, t, a) {
            let i = Number.parseInt(e);
            Number.isFinite(i) || (i = 10067), super("mord", a, {
                value: String.fromCodePoint(i),
                style: t
            }), this.codepoint = i
        }
    }

    function wa(e) {
        if (1 === e.length) {
            const t = e[0];
            if ("mbin" === t.type) return "mbin";
            if ("mrel" === t.type) return "mrel"
        }
        return "mord"
    }
    V("unicode", "{charcode:number}", {
        createAtom: (e, t, a, i) => new xa(t[0], a, i)
    }), V("rule", "[raise:dimen]{width:dimen}{thickness:dimen}", {
        createAtom: (e, t, a, i) => new sa(e, i, {
            shift: t[0],
            width: t[1],
            height: t[2],
            style: a
        })
    }), V("overline", "{:auto}", {
        createAtom: (e, t, a, i) => new ia(e, t[0], i, {
            position: "overline",
            style: a
        })
    }), V("underline", "{:auto}", {
        createAtom: (e, t, a, i) => new ia(e, t[0], i, {
            position: "underline",
            style: a
        })
    }), V("overset", "{above:auto}{base:auto}", {
        createAtom: (e, t, a, i) => new Ct(e, i, {
            above: t[0],
            body: t[1],
            skipBoundary: !1,
            style: a,
            boxType: wa(t[1]),
            serialize: (e, t) => `${e.command}{${e.aboveToLatex(t)}}{${e.bodyToLatex(t)}}`
        })
    }), V("underset", "{below:auto}{base:auto}", {
        createAtom: (e, t, a, i) => new Ct(e, i, {
            below: t[0],
            body: t[1],
            skipBoundary: !1,
            style: a,
            boxType: wa(t[1]),
            serialize: (t, a) => `${e}{${t.belowToLatex(a)}}{${t.bodyToLatex(a)}}`
        })
    }), V("overunderset", "{above:auto}{below:auto}{base:auto}", {
        createAtom: (e, t, a, i) => new Ct(e, i, {
            above: t[0],
            below: t[1],
            body: t[2],
            skipBoundary: !1,
            style: a,
            boxType: wa(t[2]),
            serialize: (e, t) => `${e.command}{${e.aboveToLatex(t)}}{${e.bodyToLatex(t)}}`
        })
    }), V(["stackrel", "stackbin"], "[below:auto]{above:auto}{base:auto}", {
        createAtom: (e, t, a, i) => new Ct(e, i, {
            body: t[2],
            above: t[1],
            below: t[0],
            skipBoundary: !1,
            style: a,
            boxType: "\\stackrel" === e ? "mrel" : "mbin",
            serialize: (e, t) => `${e.command}{${e.aboveToLatex(t)}}{${e.bodyToLatex(t)}}`
        })
    }), V("smash", "[:string]{:auto}", {
        createAtom: (e, t, a, i) => t[0] ? new na(e, t[1], i, {
            smashHeight: t[0].includes("t"),
            smashDepth: t[0].includes("b"),
            style: a
        }) : new na(e, t[1], i, {
            smashHeight: !0,
            smashDepth: !0,
            style: a
        })
    }), V(["vphantom"], "{:auto*}", {
        createAtom: (e, t, a, i) => new na(e, t[1], i, {
            isInvisible: !0,
            smashWidth: !0,
            style: a
        })
    }), V(["hphantom"], "{:auto*}", {
        createAtom: (e, t, a, i) => new na(e, t[1], i, {
            isInvisible: !0,
            smashHeight: !0,
            smashDepth: !0,
            style: a
        })
    }), V(["phantom"], "{:auto*}", {
        createAtom: (e, t, a, i) => new na(e, t[1], i, {
            isInvisible: !0,
            style: a
        })
    }), V("not", "{:math}", {
        createAtom: (e, t, a, i) => {
            if (t.length < 1 || null === t[0]) return new lt("mrel", i, {
                command: e,
                style: a,
                value: ""
            });
            const o = t[0];
            return new At([new ra(e, "", i, {
                align: "right",
                style: a,
                boxType: "mrel"
            }), ...o], i, {
                boxType: "mrel",
                captureSelection: !0,
                command: "\\not",
                serialize: (e, t) => {
                    const a = lt.serialize(o, t);
                    return 1 !== a.length || /[a-zA-Z]/.test(a) ? `\\not{${a}}` : "\\not" + a
                }
            })
        }
    }), V(["ne", "neq"], "", {
        createAtom: (e, t, a, i) => new At([new ra(e, "", i, {
            align: "right",
            style: a,
            boxType: "mrel"
        }), new lt("mrel", i, {
            style: a,
            value: "="
        })], i, {
            boxType: "mrel",
            captureSelection: !0,
            serialize: () => e,
            command: e
        })
    }), V("rlap", "{:auto}", {
        createAtom: (e, t, a, i) => new ra(e, t[0], i, {
            align: "right",
            style: a
        })
    }), V("llap", "{:auto}", {
        createAtom: (e, t, a, i) => new ra(e, t[0], i, {
            style: a
        })
    }), V("mathllap", "{:auto}", {
        createAtom: (e, t, a, i) => new ra(e, t[0], i, {
            style: a
        })
    }), V("mathrlap", "{:auto}", {
        createAtom: (e, t, a, i) => new ra(e, t[0], i, {
            align: "right",
            style: a
        })
    });
    const _a = {
        acute: 714,
        grave: 715,
        dot: 729,
        ddot: 168,
        mathring: 730,
        tilde: 126,
        bar: 713,
        breve: 728,
        check: 711,
        hat: 94,
        vec: 8407
    };

    function Sa(e) {
        for (const t of e)
            for (const e of t)
                if (e.length > 0) return !1;
        return !0
    }
    V(Object.keys(_a), "{body:auto}", {
        createAtom: (e, t, a, i) => new ut(e, t[0], i, {
            accentChar: _a[e.slice(1)],
            style: a
        })
    }), V(["widehat", "widecheck", "widetilde"], "{body:auto}", {
        createAtom: (e, t, a, i) => {
            const o = F(t[0]);
            return new ut(e, t[0], i, {
                style: a,
                svgAccent: e.slice(1) + (o.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][o.length])
            })
        }
    }), V(["overarc", "overparen", "wideparen"], "{body:auto}", {
        createAtom: (e, t, a, i) => new ut(e, t[0], i, {
            style: a,
            svgAccent: "overarc"
        })
    }), V(["underarc", "underparen"], "{body:auto}", {
        createAtom: (e, t, a, i) => new Ct(e, i, {
            body: t[0],
            style: a,
            svgBelow: "underarc"
        })
    }), V("utilde", "{body:auto}", {
        createAtom: (e, t, a, i) => {
            const o = F(t[0]),
                r = "widetilde" + (o.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][o.length]);
            return new Ct(e, i, {
                body: t[0],
                svgBelow: r,
                style: a,
                boxType: wa(t[0])
            })
        }
    }), V("^", "{:string}", {
        createAtom: (e, t, a, i) => {
            var o;
            return new lt("mord", i, {
                command: e,
                isFunction: !1,
                limits: "adjacent",
                style: a,
                value: t[0] && null !== (o = {
                    a: "â",
                    e: "ê",
                    i: "î",
                    o: "ô",
                    u: "û",
                    A: "Â",
                    E: "Ê",
                    I: "Î",
                    O: "Ô",
                    U: "Û"
                } [t[0]]) && void 0 !== o ? o : "^"
            })
        }
    }), V("`", "{:string}", {
        createAtom: (e, t, a, i) => {
            var o;
            return new lt("mord", i, {
                command: e,
                isFunction: !1,
                limits: "adjacent",
                style: a,
                value: t[0] && null !== (o = {
                    a: "à",
                    e: "è",
                    i: "ì",
                    o: "ò",
                    u: "ù",
                    A: "À",
                    E: "È",
                    I: "Ì",
                    O: "Ò",
                    U: "Ù"
                } [t[0]]) && void 0 !== o ? o : "`"
            })
        }
    }), V("'", "{:string}", {
        createAtom: (e, t, a, i) => {
            var o;
            return new lt("mord", i, {
                command: e,
                isFunction: !1,
                limits: "adjacent",
                style: a,
                value: t[0] && null !== (o = {
                    a: "á",
                    e: "é",
                    i: "í",
                    o: "ó",
                    u: "ú",
                    A: "Á",
                    E: "É",
                    I: "Í",
                    O: "Ó",
                    U: "Ú"
                } [t[0]]) && void 0 !== o ? o : "^"
            })
        }
    }), V("~", "{:string}", {
        createAtom: (e, t, a, i) => {
            var o;
            return new lt("mord", i, {
                command: e,
                isFunction: !1,
                limits: "adjacent",
                style: a,
                value: t[0] && null !== (o = {
                    n: "ñ",
                    N: "Ñ",
                    a: "ã",
                    o: "õ",
                    A: "Ã",
                    O: "Õ"
                } [t[0]]) && void 0 !== o ? o : "´"
            })
        }
    }), V("c", "{:string}", {
        createAtom: (e, t, a, i) => {
            var o;
            return new lt("mord", i, {
                command: e,
                isFunction: !1,
                limits: "adjacent",
                style: a,
                value: t[0] && null !== (o = {
                    c: "ç",
                    C: "Ç"
                } [t[0]]) && void 0 !== o ? o : ""
            })
        }
    }), V("enclose", "{notation:string}[style:string]{body:auto}", {
        createAtom: (e, t, a, i) => {
            var o;
            const r = {
                strokeColor: "currentColor",
                strokeWidth: "",
                strokeStyle: "solid",
                backgroundcolor: "transparent",
                padding: "auto",
                shadow: "auto",
                svgStrokeStyle: void 0,
                borderStyle: void 0,
                style: a
            };
            if (t[1]) {
                const e = t[1].split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
                for (const t of e) {
                    const e = t.match(/\s*(\S+)\s+(\S+)\s+(.*)/);
                    if (e) r.strokeWidth = e[1], r.strokeStyle = e[2], r.strokeColor = e[3];
                    else {
                        const e = t.match(/\s*([a-z]*)\s*=\s*"(.*)"/);
                        e && ("mathbackground" === e[1] ? r.backgroundcolor = e[2] : "mathcolor" === e[1] ? r.strokeColor = e[2] : "padding" === e[1] ? r.padding = e[2] : "shadow" === e[1] && (r.shadow = e[2]))
                    }
                }
                "dashed" === r.strokeStyle ? r.svgStrokeStyle = "5,5" : "dotted" === r.strokeStyle && (r.svgStrokeStyle = "1,5")
            }
            r.borderStyle = `${r.strokeWidth} ${r.strokeStyle} ${r.strokeColor}`;
            const n = {};
            return (null !== (o = t[0]) && void 0 !== o ? o : "").split(/[, ]/).filter((e => e.length > 0)).forEach((e => {
                n[e.toLowerCase()] = !0
            })), new Qt(e, t[2], n, i, r)
        }
    }), V("cancel", "{body:auto}", {
        createAtom: (e, t, a, i) => new Qt(e, t[0], {
            updiagonalstrike: !0
        }, i, {
            strokeColor: "currentColor",
            strokeWidth: "",
            strokeStyle: "solid",
            borderStyle: "1px solid currentColor",
            backgroundcolor: "transparent",
            padding: "auto",
            shadow: "auto",
            style: a
        })
    }), V("bcancel", "{body:auto}", {
        createAtom: (e, t, a, i) => new Qt(e, t[0], {
            downdiagonalstrike: !0
        }, i, {
            strokeColor: "currentColor",
            strokeWidth: "",
            strokeStyle: "solid",
            borderStyle: "1px solid currentColor",
            backgroundcolor: "transparent",
            padding: "auto",
            shadow: "auto",
            style: a
        })
    }), V("xcancel", "{body:auto}", {
        createAtom: (e, t, a, i) => new Qt(e, t[0], {
            updiagonalstrike: !0,
            downdiagonalstrike: !0
        }, i, {
            strokeColor: "currentColor",
            strokeWidth: "",
            strokeStyle: "solid",
            borderStyle: "1px solid currentColor",
            backgroundcolor: "transparent",
            padding: "auto",
            shadow: "auto",
            style: a
        })
    }), R("math", "", ((e, t, a, i) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        mathstyleName: "textstyle"
    })))), R("displaymath", "", ((e, t, a, i) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        mathstyleName: "textstyle"
    })))), I("array", "{columns:colspec}", ((e, t, a, i, o) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        columns: o[0],
        mathstyleName: "textstyle"
    })))), I(["equation", "equation*", "subequations"], "", ((e, t, a, i) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        columns: [{
            align: "c"
        }]
    })))), I("multline", "", ((e, t, a, i) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        columns: [{
            align: "m"
        }]
    })))), I(["align", "align*", "aligned", "eqnarray"], "", ((e, t, a, i) => {
        let o = 0;
        Sa(a) && (a = [
            [
                [new lt("first", e), new Bt(e)],
                [new lt("first", e), new Bt(e)]
            ]
        ]);
        for (const e of a) o = Math.max(o, e.length);
        const r = [{
            gap: 0
        }, {
            align: "r"
        }, {
            gap: .25
        }, {
            align: "l"
        }];
        let n = 2;
        for (; n < o;) r.push({
            gap: 1
        }), r.push({
            align: "r"
        }), r.push({
            gap: .25
        }), r.push({
            align: "l"
        }), n += 2;
        return r.push({
            gap: 0
        }), new Vt(e, t, a, i, {
            arraycolsep: 0,
            columns: r,
            colSeparationType: "align",
            jot: .3,
            minColumns: 2
        })
    })), I("split", "", ((e, t, a, i) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)],
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        columns: [{
            align: "r"
        }, {
            align: "l"
        }],
        minColumns: 2
    })))), I(["gather", "gathered"], "", ((e, t, a, i) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        columns: [{
            gap: .25
        }, {
            align: "c"
        }, {
            gap: 0
        }],
        colSeparationType: "gather"
    })))), I(["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"], "[columns:colspec]", ((e, t, a, i, o) => {
        var r;
        Sa(a) && (a = [
            [
                [new lt("first", e), new Bt(e)]
            ]
        ]);
        let n = ".",
            s = ".";
        switch (t) {
            case "pmatrix":
            case "pmatrix*":
                n = "(", s = ")";
                break;
            case "bmatrix":
            case "bmatrix*":
                n = "[", s = "]";
                break;
            case "Bmatrix":
            case "Bmatrix*":
                n = "\\lbrace", s = "\\rbrace";
                break;
            case "vmatrix":
            case "vmatrix*":
                n = "\\vert", s = "\\vert";
                break;
            case "Vmatrix":
            case "Vmatrix*":
                n = "\\Vert", s = "\\Vert";
                break;
            case "matrix":
            case "matrix*":
                n = ".", s = "."
        }
        return new Vt(e, t, a, i, {
            mathstyleName: "textstyle",
            leftDelim: n,
            rightDelim: s,
            columns: null !== (r = o[0]) && void 0 !== r ? r : [{
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }]
        })
    })), I(["smallmatrix", "smallmatrix*"], "[columns:colspec]", ((e, t, a, i, o) => {
        var r;
        return Sa(a) && (a = [
            [
                [new lt("first", e), new Bt(e)]
            ]
        ]), new Vt(e, t, a, i, {
            mathstyleName: "scriptstyle",
            columns: null !== (r = o[0]) && void 0 !== r ? r : [{
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }, {
                align: "c"
            }],
            colSeparationType: "small",
            arraystretch: .5
        })
    })), I(["cases", "dcases"], "", ((e, t, a, i) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        mathstyleName: "dcases" === t ? "displaystyle" : "textstyle",
        arraystretch: 1.2,
        leftDelim: "\\lbrace",
        rightDelim: ".",
        columns: [{
            align: "l"
        }, {
            gap: 1
        }, {
            align: "l"
        }]
    })))), I("rcases", "", ((e, t, a, i) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        arraystretch: 1.2,
        leftDelim: ".",
        rightDelim: "\\rbrace",
        columns: [{
            align: "l"
        }, {
            gap: 1
        }, {
            align: "l"
        }]
    })))), R("center", "", ((e, t, a, i) => (Sa(a) && (a = [
        [
            [new lt("first", e), new Bt(e)]
        ]
    ]), new Vt(e, t, a, i, {
        columns: [{
            align: "c"
        }]
    })))), V(["overrightarrow", "overleftarrow", "Overrightarrow", "overleftharpoon", "overrightharpoon", "overleftrightarrow", "overlinesegment", "overgroup"], "{:auto}", {
        createAtom: (e, t, a, i) => new Ct(e, i, {
            body: t[0],
            skipBoundary: !1,
            supsubPlacement: "over-under",
            paddedBody: !0,
            boxType: "mrel",
            style: a,
            svgAbove: e.slice(1)
        })
    }), V("overbrace", "{:auto}", {
        createAtom: (e, t, a, i) => new Ct(e, i, {
            body: t[0],
            skipBoundary: !1,
            supsubPlacement: "over-under",
            paddedBody: !0,
            boxType: "mord",
            style: a,
            svgAbove: e.slice(1)
        })
    }), V(["underrightarrow", "underleftarrow", "underleftrightarrow", "underlinesegment", "undergroup"], "{:auto}", {
        createAtom: (e, t, a, i) => new Ct(e, i, {
            body: t[0],
            skipBoundary: !1,
            supsubPlacement: "over-under",
            paddedBody: !0,
            boxType: "mrel",
            style: a,
            svgBelow: e.slice(1)
        })
    }), V(["underbrace"], "{:auto}", {
        createAtom: (e, t, a, i) => new Ct(e, i, {
            body: t[0],
            skipBoundary: !1,
            supsubPlacement: "over-under",
            paddedBody: !0,
            boxType: "mord",
            style: a,
            svgBelow: e.slice(1)
        })
    }), V(["xrightarrow", "xleftarrow", "xRightarrow", "xLeftarrow", "xleftharpoonup", "xleftharpoondown", "xrightharpoonup", "xrightharpoondown", "xlongequal", "xtwoheadleftarrow", "xtwoheadrightarrow", "xleftrightarrow", "xLeftrightarrow", "xrightleftharpoons", "xleftrightharpoons", "xhookleftarrow", "xhookrightarrow", "xmapsto", "xtofrom", "xrightleftarrows", "xrightequilibrium", "xleftequilibrium"], "[:auto]{:auto}", {
        createAtom: (e, t, a, i) => {
            var o, r;
            return new Ct(e, i, {
                style: a,
                svgBody: e.slice(1),
                above: 0 === (null === (o = t[1]) || void 0 === o ? void 0 : o.length) ? void 0 : t[1],
                below: null !== (r = t[0]) && void 0 !== r ? r : null,
                skipBoundary: !1,
                supsubPlacement: "over-under",
                paddedBody: !0,
                paddedLabels: !0,
                boxType: "mrel",
                serialize: (t, a) => e + (t.hasEmptyBranch("below") ? "" : `[${t.belowToLatex(a)}]`) + `{${t.aboveToLatex(a)}}${t.supsubToLatex(a)}`
            })
        }
    }), V(["arccos", "arcsin", "arctan", "arctg", "arcctg", "arg", "ch", "cos", "cosh", "cot", "cotg", "coth", "ctg", "cth", "csc", "cosec", "dim", "exp", "hom", "inf", "ker", "lb", "lg", "ln", "log", "Pr", "sec", "sh", "sin", "sinh", "sup", "tan", "tanh", "tg", "th", "arcsec", "arccsc", "arsinh", "arcosh", "artanh", "arcsech", "arccsch"], "", {
        isFunction: !0,
        createAtom: (e, t, a, i) => new oa(e, e.slice(1), i, {
            limits: "adjacent",
            isFunction: !0,
            variant: "main",
            variantStyle: "up",
            style: a
        })
    }), V(["liminf", "limsup"], "", {
        createAtom: (e, t, a, i) => new oa(e, {
            "\\liminf": "lim inf",
            "\\limsup": "lim sup"
        } [e], i, {
            limits: "over-under",
            variant: "main",
            style: a
        })
    }), V(["lim", "mod"], "", {
        createAtom: (e, t, a, i) => new oa(e, e.slice(1), i, {
            limits: "over-under",
            variant: "main",
            style: a
        })
    }), V(["det", "max", "min"], "", {
        isFunction: !0,
        createAtom: (e, t, a, i) => new oa(e, e.slice(1), i, {
            limits: "over-under",
            isFunction: !0,
            variant: "main",
            style: a
        })
    }), V(["ang"], "{:math}", {
        isFunction: !0,
        createAtom: (e, t, a, i) => new At([...t[0], new lt("mord", i, {
            value: "°",
            style: a
        })], i, {
            mode: "math",
            latexOpen: "\\ang{",
            latexClose: "}",
            style: a
        })
    }), V("sqrt", "[index:auto]{radicand:auto}", {
        createAtom: (e, t, a, i) => new la(e, i, {
            body: t[1],
            index: t[0],
            style: a
        })
    }), V(["frac", "dfrac", "tfrac", "cfrac", "binom", "dbinom", "tbinom"], "{numerator}{denominator}", {
        createAtom: (e, t, a, i) => {
            const o = {
                style: a
            };
            switch (e) {
                case "\\dfrac":
                case "\\frac":
                case "\\tfrac":
                    o.hasBarLine = !0;
                    break;
                case "\\atopfrac":
                    o.hasBarLine = !1;
                    break;
                case "\\dbinom":
                case "\\binom":
                case "\\tbinom":
                    o.hasBarLine = !1, o.leftDelim = "(", o.rightDelim = ")"
            }
            switch (e) {
                case "\\dfrac":
                case "\\dbinom":
                    o.mathstyleName = "displaystyle";
                    break;
                case "\\tfrac":
                case "\\tbinom":
                    o.mathstyleName = "textstyle";
                    break;
                case "\\cfrac":
                    o.hasBarLine = !0, o.continuousFraction = !0
            }
            return new ea(e, t[0], t[1], i, o)
        }
    }), V(["brace", "brack"], "", {
        infix: !0,
        createAtom: (e, t, a, i) => new ea(e, t[0], t[1], i, {
            hasBarLine: !1,
            leftDelim: "\\brace" === e ? "\\lbrace" : "\\lbrack",
            rightDelim: "\\brace" === e ? "\\rbrace" : "\\rbrack",
            style: a,
            serialize: (e, t) => at([e.aboveToLatex(t), e.command, e.belowToLatex(t)])
        })
    }), V(["over", "atop", "choose"], "", {
        infix: !0,
        createAtom: (e, t, a, i) => {
            let o, r;
            return "\\choose" === e && (o = "(", r = ")"), new ea(e, t[0], t[1], i, {
                hasBarLine: "\\over" === e,
                leftDelim: o,
                rightDelim: r,
                style: a,
                serialize: (e, t) => at([e.aboveToLatex(t), e.command, e.belowToLatex(t)])
            })
        }
    }), V(["overwithdelims", "atopwithdelims"], "{numer:auto}{denom:auto}{left-delim:delim}{right-delim:delim}", {
        infix: !0,
        createAtom: (e, t, a, i) => new ea(e, t[0], t[1], i, {
            leftDelim: t[2],
            rightDelim: t[3],
            hasBarLine: !1,
            style: a,
            serialize: (e, t) => `${e.aboveToLatex(t)} ${e.command}${e.leftDelim}${e.rightDelim}${e.belowToLatex(t)}`
        })
    }), V("pdiff", "{numerator}{denominator}", {
        createAtom: (e, t, a, i) => new ea(e, t[0], t[1], i, {
            hasBarLine: !0,
            numerPrefix: "∂",
            denomPrefix: "∂",
            style: a
        })
    }), V(["sum", "prod", "bigcup", "bigcap", "coprod", "bigvee", "bigwedge", "biguplus", "bigotimes", "bigoplus", "bigodot", "bigsqcup", "smallint", "intop"], "", {
        createAtom: (e, t, a, i) => new oa(e, {
            coprod: "∐",
            bigvee: "⋁",
            bigwedge: "⋀",
            biguplus: "⨄",
            bigcap: "⋂",
            bigcup: "⋃",
            intop: "∫",
            prod: "∏",
            sum: "∑",
            bigotimes: "⨂",
            bigoplus: "⨁",
            bigodot: "⨀",
            bigsqcup: "⨆",
            smallint: "∫"
        } [e.slice(1)], i, {
            isExtensibleSymbol: !0,
            limits: "auto",
            variant: "main",
            style: a
        })
    });
    const Ma = {
        int: "∫",
        iint: "∬",
        iiint: "∭",
        oint: "∮",
        oiint: "∯",
        oiiint: "∰",
        intclockwise: "∱",
        varointclockwise: "∲",
        ointctrclockwise: "∳",
        intctrclockwise: "⨑",
        sqcup: "⊔",
        sqcap: "⊓",
        uplus: "⊎",
        wr: "≀",
        amalg: "⨿",
        Cap: "⋒",
        Cup: "⋓",
        doublecap: "⋒",
        doublecup: "⋓"
    };

    function La(e, t) {
        return e[0] === t[0] && e[1] === t[1] ? "equal" : "different"
    }

    function Ca(e) {
        let t = 1 / 0,
            a = -1 / 0;
        for (const i of e.ranges) t = Math.min(t, i[0], i[1]), a = Math.max(a, i[0], i[1]);
        return [t, a]
    }

    function Aa(e, t, a) {
        return a ? function(e, t) {
            if (!t) return "";
            if ("string" == typeof t) return t;
            if (!e || void 0 === t.after) return t.value;
            let a = !1,
                i = !1,
                o = !1,
                r = !1,
                n = !1,
                s = !1,
                l = !1,
                d = !1,
                c = !1,
                u = !1,
                p = !1,
                h = !1,
                m = !1,
                f = !1,
                y = !1,
                b = e[0],
                g = 0;
            for (; b && /msubsup|placeholder/.test(b.type);) g += 1, b = e[g];
            return a = !b || "first" === b.type, b && (f = "text" === b.mode, i = !f && "mord" === b.type && T.test(b.value), o = !f && "mord" === b.type && /\d+$/.test(b.value), r = !f && b.isFunction, n = "genfrac" === b.type, s = "surd" === b.type, l = "mbin" === b.type, d = "mrel" === b.type, c = "mop" === b.type, u = "mpunct" === b.type || "minner" === b.type, p = "array" === b.type, h = "mopen" === b.type, m = "mclose" === b.type || "leftright" === b.type, y = "space" === b.type), t.after.includes("nothing") && a || t.after.includes("letter") && i || t.after.includes("digit") && o || t.after.includes("function") && r || t.after.includes("frac") && n || t.after.includes("surd") && s || t.after.includes("binop") && l || t.after.includes("relop") && d || t.after.includes("operator") && c || t.after.includes("punct") && u || t.after.includes("array") && p || t.after.includes("openfence") && h || t.after.includes("closefence") && m || t.after.includes("text") && f || t.after.includes("space") && y ? t.value : ""
        }(e, a[t]) : ""
    }
    V(Object.keys(Ma), "", {
        createAtom: (e, t, a, i) => new oa(e, Ma[e.slice(1)], i, {
            limits: "adjacent",
            isExtensibleSymbol: !0,
            style: a,
            variant: {
                "⋒": "ams",
                "⋓": "ams"
            } [Ma[e.slice(1)]]
        })
    }), V(["Re", "Im"], "", {
        createAtom: (e, t, a, i) => new oa(e, {
            "\\Re": "ℜ",
            "\\Im": "ℑ"
        } [e], i, {
            limits: "adjacent",
            style: a,
            isFunction: !0,
            variant: "fraktur"
        })
    }), V("middle", "{:delim}", {
        createAtom: (e, t, a, i) => new Zt(e, t[0], i, {
            size: 1,
            style: a
        })
    }), K("0123456789/@.?!"), q(65, 90), q(97, 122), K([
        ["\\forall", 8704],
        ["\\exists", 8707],
        ["\\nexists", 8708, "mord", "ams"],
        ["\\mid", 8739, "mrel"],
        ["\\top", 8868],
        ["\\bot", 8869]
    ]), K([
        ["\\sharp", 9839],
        ["\\flat", 9837],
        ["\\natural", 9838],
        ["\\#", 35],
        ["\\&", 38],
        ["\\clubsuit", 9827],
        ["\\heartsuit", 9825],
        ["\\spadesuit", 9824],
        ["\\diamondsuit", 9826],
        ["\\parallelogram", 9649]
    ]), K([
        ["\\backslash", 92],
        ["\\nabla", 8711],
        ["\\partial", 8706],
        ["\\ell", 8467],
        ["\\hbar", 8463],
        ["\\Q", 81, "mord", "double-struck"],
        ["\\C", 67, "mord", "double-struck"],
        ["\\P", 80, "mord", "double-struck"],
        ["\\pounds", 163],
        ["\\euro", 8364]
    ]), K([
        ["\\rightarrow", 8594],
        ["\\to", 8594],
        ["\\leftarrow", 8592],
        ["\\gets", 8592],
        ["\\Rightarrow", 8658],
        ["\\Leftarrow", 8656],
        ["\\longrightarrow", 10230],
        ["\\longleftarrow", 10229],
        ["\\Longrightarrow", 10233],
        ["\\implies", 10233],
        ["\\Longleftarrow", 10232],
        ["\\impliedby", 10232],
        ["\\longleftrightarrow", 10231],
        ["\\biconditional", 10231],
        ["\\Longleftrightarrow", 10234],
        ["\\mapsto", 8614],
        ["\\longmapsto", 10236],
        ["\\uparrow", 8593],
        ["\\downarrow", 8595],
        ["\\Uparrow", 8657],
        ["\\Downarrow", 8659],
        ["\\updownarrow", 8597],
        ["\\Updownarrow", 8661],
        ["\\hookrightarrow", 8618],
        ["\\hookleftarrow", 8617],
        ["\\rightharpoonup", 8640],
        ["\\leftharpoonup", 8636],
        ["\\rightharpoondown", 8641],
        ["\\leftharpoondown", 8637],
        ["\\searrow", 8600],
        ["\\nearrow", 8599],
        ["\\swarrow", 8601],
        ["\\nwarrow", 8598],
        ["\\originalof", 8886],
        ["\\laplace", 8886],
        ["\\imageof", 8887],
        ["\\Laplace", 8887]
    ], "mrel"), K([
        ["\\lbrace", 123, "mopen"],
        ["\\rbrace", 125, "mclose"],
        ["\\lparen", 40, "mopen"],
        ["\\rparen", 41, "mclose"],
        ["\\langle", 10216, "mopen"],
        ["\\rangle", 10217, "mclose"],
        ["\\lfloor", 8970, "mopen"],
        ["\\rfloor", 8971, "mclose"],
        ["\\lceil", 8968, "mopen"],
        ["\\rceil", 8969, "mclose"],
        ["\\vert", 8739],
        ["\\lvert", 8739, "mopen"],
        ["\\rvert", 8739, "mclose"],
        ["\\|", 8741],
        ["\\Vert", 8741],
        ["\\mVert", 8741],
        ["\\lVert", 8741, "mopen"],
        ["\\rVert", 8741, "mclose"],
        ["\\lbrack", 91, "mopen"],
        ["\\rbrack", 93, "mclose"],
        ["\\{", 123, "mopen"],
        ["\\}", 125, "mclose"],
        ["(", 40, "mopen"],
        [")", 41, "mclose"],
        ["[", 91, "mopen"],
        ["]", 93, "mclose"],
        ["\\ulcorner", 9484, "mopen", "ams"],
        ["\\urcorner", 9488, "mclose", "ams"],
        ["\\llcorner", 9492, "mopen", "ams"],
        ["\\lrcorner", 9496, "mclose", "ams"],
        ["\\lgroup", 10222, "mopen"],
        ["\\rgroup", 10223, "mclose"],
        ["\\lmoustache", 9136, "mopen"],
        ["\\rmoustache", 9137, "mclose"]
    ]), K([
        ["\\dashrightarrow", 8674],
        ["\\dashleftarrow", 8672],
        ["\\Rrightarrow", 8667],
        ["\\Lleftarrow", 8666],
        ["\\leftrightarrows", 8646],
        ["\\rightleftarrows", 8644],
        ["\\curvearrowright", 8631],
        ["\\curvearrowleft", 8630],
        ["\\rightrightarrows", 8649],
        ["\\leftleftarrows", 8647],
        ["\\upuparrows", 8648],
        ["\\downdownarrows", 8650],
        ["\\vartriangle", 9651],
        ["\\triangleq", 8796],
        ["\\vartriangleleft", 8882],
        ["\\trianglelefteq", 8884],
        ["\\ntriangleleft", 8938],
        ["\\ntrianglelefteq", 8940],
        ["\\vartriangleright", 8883],
        ["\\trianglerighteq", 8885],
        ["\\ntriangleright", 8939],
        ["\\ntrianglerighteq", 8941],
        ["\\blacktriangleleft", 9664],
        ["\\blacktriangleright", 9654],
        ["\\leftarrowtail", 8610],
        ["\\rightarrowtail", 8611],
        ["\\looparrowright", 8620],
        ["\\looparrowleft", 8619],
        ["\\twoheadleftarrow", 8606],
        ["\\twoheadrightarrow", 8608],
        ["\\rightleftharpoons", 8652],
        ["\\leftrightharpoons", 8651],
        ["\\Rsh", 8625],
        ["\\Lsh", 8624],
        ["\\circlearrowright", 8635],
        ["\\circlearrowleft", 8634],
        ["\\restriction", 8638],
        ["\\upharpoonright", 8638],
        ["\\upharpoonleft", 8639],
        ["\\downharpoonright", 8642],
        ["\\downharpoonleft", 8643],
        ["\\rightsquigarrow", 8669],
        ["\\leadsto", 8669],
        ["\\leftrightsquigarrow", 8621],
        ["\\multimap", 8888],
        ["\\nrightarrow", 8603],
        ["\\nleftarrow", 8602],
        ["\\nRightarrow", 8655],
        ["\\nLeftarrow", 8653],
        ["\\nleftrightarrow", 8622],
        ["\\nLeftrightarrow", 8654],
        ["\\shortparallel", 8741],
        ["\\nless", 8814],
        ["\\nleqslant", 57360],
        ["\\lneq", 10887],
        ["\\lneqq", 8808],
        ["\\nleqq", 57361],
        ["\\lvertneqq", 57356],
        ["\\lnsim", 8934],
        ["\\lnapprox", 10889],
        ["\\nprec", 8832],
        ["\\npreceq", 8928],
        ["\\precnsim", 8936],
        ["\\precnapprox", 10937],
        ["\\nsim", 8769],
        ["\\nshortmid", 57350],
        ["\\nmid", 8740],
        ["\\nvdash", 8876],
        ["\\nvDash", 8877],
        ["\\ngtr", 8815],
        ["\\ngeqslant", 57359],
        ["\\ngeqq", 57358],
        ["\\gneq", 10888],
        ["\\gneqq", 8809],
        ["\\gvertneqq", 57357],
        ["\\gnsim", 8935],
        ["\\gnapprox", 10890],
        ["\\nsucc", 8833],
        ["\\nsucceq", 8929],
        ["\\succnsim", 8937],
        ["\\succnapprox", 10938],
        ["\\ncong", 8774],
        ["\\nshortparallel", 57351],
        ["\\nparallel", 8742],
        ["\\nVDash", 8879],
        ["\\nsupseteqq", 57368],
        ["\\supsetneq", 8843],
        ["\\varsupsetneq", 57371],
        ["\\supsetneqq", 10956],
        ["\\varsupsetneqq", 57369],
        ["\\nVdash", 8878],
        ["\\precneqq", 10933],
        ["\\succneqq", 10934],
        ["\\nsubseteqq", 57366],
        ["\\leqslant", 10877],
        ["\\geqslant", 10878],
        ["\\gtrsim", 8819],
        ["\\approxeq", 8778],
        ["\\thickapprox", 8776],
        ["\\lessapprox", 10885],
        ["\\gtrapprox", 10886],
        ["\\precapprox", 10935],
        ["\\succapprox", 10936],
        ["\\thicksim", 8764],
        ["\\succsim", 8831],
        ["\\precsim", 8830],
        ["\\backsim", 8765],
        ["\\eqsim", 8770],
        ["\\backsimeq", 8909],
        ["\\lesssim", 8818],
        ["\\nleq", 8816],
        ["\\ngeq", 8817],
        ["\\smallsmile", 8995],
        ["\\smallfrown", 8994],
        ["\\leqq", 8806],
        ["\\eqslantless", 10901],
        ["\\lll", 8920],
        ["\\lessgtr", 8822],
        ["\\lesseqgtr", 8922],
        ["\\lesseqqgtr", 10891],
        ["\\risingdotseq", 8787],
        ["\\fallingdotseq", 8786],
        ["\\subseteqq", 10949],
        ["\\Subset", 8912],
        ["\\sqsubset", 8847],
        ["\\preccurlyeq", 8828],
        ["\\curlyeqprec", 8926],
        ["\\vDash", 8872],
        ["\\Vvdash", 8874],
        ["\\bumpeq", 8783],
        ["\\Bumpeq", 8782],
        ["\\geqq", 8807],
        ["\\eqslantgtr", 10902],
        ["\\ggg", 8921],
        ["\\gtrless", 8823],
        ["\\gtreqless", 8923],
        ["\\gtreqqless", 10892],
        ["\\supseteqq", 10950],
        ["\\Supset", 8913],
        ["\\sqsupset", 8848],
        ["\\succcurlyeq", 8829],
        ["\\curlyeqsucc", 8927],
        ["\\Vdash", 8873],
        ["\\shortmid", 8739],
        ["\\between", 8812],
        ["\\pitchfork", 8916],
        ["\\varpropto", 8733],
        ["\\backepsilon", 8717],
        ["\\llless", 8920],
        ["\\gggtr", 8921],
        ["\\doteqdot", 8785],
        ["\\Doteq", 8785],
        ["\\eqcirc", 8790],
        ["\\circeq", 8791],
        ["\\therefore", 8756],
        ["\\because", 8757]
    ], "mrel", "ams"), K([
        ["+", 43],
        ["-", 8722],
        ["−", 8722],
        ["\\pm", 177],
        ["\\mp", 8723],
        ["*", 8727],
        ["\\times", 215],
        ["\\div", 247],
        ["\\divides", 8739],
        ["\\cdot", 8901],
        ["\\cap", 8745],
        ["\\cup", 8746],
        ["\\setminus", 8726],
        ["\\land", 8743],
        ["\\wedge", 8743],
        ["\\lor", 8744],
        ["\\vee", 8744],
        ["\\circ", 8728],
        ["\\bigcirc", 9711],
        ["\\bullet", 8729],
        ["\\oplus", 8853],
        ["\\ominus", 8854],
        ["\\otimes", 8855],
        ["\\odot", 8857],
        ["\\oslash", 8856],
        ["\\bigtriangleup", 9651],
        ["\\bigtriangledown", 9661],
        ["\\triangleleft", 9667],
        ["\\triangleright", 9657],
        ["\\And", 38],
        ["\\dagger", 8224],
        ["\\dag", 8224],
        ["\\ddag", 8225],
        ["\\ddagger", 8225],
        ["\\ast", 8727],
        ["\\star", 8902],
        ["\\bigstar", 9733],
        ["\\diamond", 8900]
    ], "mbin"), K([
        ["\\lhd", 8882],
        ["\\rhd", 8883],
        ["\\lessdot", 8918],
        ["\\gtrdot", 8919],
        ["\\ltimes", 8905],
        ["\\rtimes", 8906],
        ["\\leftthreetimes", 8907],
        ["\\rightthreetimes", 8908],
        ["\\intercal", 8890],
        ["\\dotplus", 8724],
        ["\\doublebarwedge", 10846],
        ["\\divideontimes", 8903],
        ["\\centerdot", 8901],
        ["\\smallsetminus", 8726],
        ["\\barwedge", 8892],
        ["\\veebar", 8891],
        ["\\nor", 8891],
        ["\\curlywedge", 8911],
        ["\\curlyvee", 8910],
        ["\\boxminus", 8863],
        ["\\boxplus", 8862],
        ["\\boxtimes", 8864],
        ["\\boxdot", 8865],
        ["\\circleddash", 8861],
        ["\\circledast", 8859],
        ["\\circledcirc", 8858],
        ["\\unlhd", 8884],
        ["\\unrhd", 8885]
    ], "mbin", "ams"), K([
        ["\\surd", 8730],
        ["\\infty", 8734],
        ["\\prime", 8242],
        ["\\doubleprime", 8243],
        ["\\angle", 8736],
        ["`", 8216],
        ["\\$", 36],
        ["\\%", 37],
        ["\\_", 95],
        ["\\alpha", 945],
        ["\\beta", 946],
        ["\\gamma", 947],
        ["\\delta", 948],
        ["\\epsilon", 1013],
        ["\\varepsilon", 949],
        ["\\zeta", 950],
        ["\\eta", 951],
        ["\\theta", 952],
        ["\\vartheta", 977],
        ["\\iota", 953],
        ["\\kappa", 954],
        ["\\varkappa", 1008, "mord", "ams"],
        ["\\lambda", 955],
        ["\\mu", 956],
        ["\\nu", 957],
        ["\\xi", 958],
        ["\\omicron", 111],
        ["\\pi", 960],
        ["\\varpi", 982],
        ["\\rho", 961],
        ["\\varrho", 1009],
        ["\\sigma", 963],
        ["\\varsigma", 962],
        ["\\tau", 964],
        ["\\phi", 981],
        ["\\varphi", 966],
        ["\\upsilon", 965],
        ["\\chi", 967],
        ["\\psi", 968],
        ["\\omega", 969],
        ["\\Gamma", 915],
        ["\\Delta", 916],
        ["\\Theta", 920],
        ["\\Lambda", 923],
        ["\\Xi", 926],
        ["\\Pi", 928],
        ["\\Sigma", 931],
        ["\\Upsilon", 933],
        ["\\Phi", 934],
        ["\\Psi", 936],
        ["\\Omega", 937],
        ["\\digamma", 989, "mord", "ams"],
        ["\\emptyset", 8709]
    ]), K([
        ["=", 61],
        ["<", 60],
        ["\\lt", 60],
        [">", 62],
        ["\\gt", 62],
        ["\\le", 8804],
        ["\\leq", 8804],
        ["\\ge", 8805],
        ["\\geq", 8805],
        ["\\ll", 8810],
        ["\\gg", 8811],
        ["\\coloneq", 8788],
        ["\\measeq", 8797],
        ["\\eqdef", 8798],
        ["\\questeq", 8799],
        [":", 58],
        ["\\cong", 8773],
        ["\\equiv", 8801],
        ["\\prec", 8826],
        ["\\preceq", 10927],
        ["\\succ", 8827],
        ["\\succeq", 10928],
        ["\\perp", 8869],
        ["\\propto", 8733],
        ["\\Colon", 8759],
        ["\\smile", 8995],
        ["\\frown", 8994],
        ["\\sim", 8764],
        ["\\doteq", 8784],
        ["\\bowtie", 8904],
        ["\\Join", 8904],
        ["\\asymp", 8781],
        ["\\sqsubseteq", 8849],
        ["\\sqsupseteq", 8850],
        ["\\approx", 8776],
        ["\\~", 126],
        ["\\leftrightarrow", 8596],
        ["\\Leftrightarrow", 8660],
        ["\\models", 8872],
        ["\\vdash", 8866],
        ["\\dashv", 8867],
        ["\\roundimplies", 10608],
        ["\\in", 8712],
        ["\\notin", 8713],
        ["\\ni", 8715],
        ["\\owns", 8715],
        ["\\subset", 8834],
        ["\\supset", 8835],
        ["\\subseteq", 8838],
        ["\\supseteq", 8839],
        ["\\differencedelta", 8710],
        ["\\mvert", 8739],
        ["\\parallel", 8741],
        ["\\simeq", 8771]
    ], "mrel"), K([
        ["\\lnot", 172],
        ["\\neg", 172],
        ["\\triangle", 9651],
        ["\\subsetneq", 8842],
        ["\\varsubsetneq", 57370],
        ["\\subsetneqq", 10955],
        ["\\varsubsetneqq", 57367],
        ["\\nsubset", 8836],
        ["\\nsupset", 8837],
        ["\\nsubseteq", 8840],
        ["\\nsupseteq", 8841]
    ], "mrel", "ams"), K([
        ["\\wp", 8472],
        ["\\aleph", 8501]
    ]), K([
        ["\\blacktriangle", 9650],
        ["\\hslash", 8463],
        ["\\Finv", 8498],
        ["\\Game", 8513],
        ["\\eth", 240],
        ["\\mho", 8487],
        ["\\Bbbk", 107],
        ["\\yen", 165],
        ["\\square", 9633],
        ["\\Box", 9633],
        ["\\blacksquare", 9632],
        ["\\circledS", 9416],
        ["\\circledR", 174],
        ["\\triangledown", 9661],
        ["\\blacktriangledown", 9660],
        ["\\checkmark", 10003],
        ["\\diagup", 9585],
        ["\\measuredangle", 8737],
        ["\\sphericalangle", 8738],
        ["\\backprime", 8245],
        ["\\backdoubleprime", 8246],
        ["\\Diamond", 9674],
        ["\\lozenge", 9674],
        ["\\blacklozenge", 10731],
        ["\\varnothing", 8709],
        ["\\complement", 8705],
        ["\\maltese", 10016],
        ["\\beth", 8502],
        ["\\daleth", 8504],
        ["\\gimel", 8503]
    ], "mord", "ams"), K([
        ["\\ ", 160],
        ["~", 160],
        ["\\space", 160]
    ], "space"), V(["!", ",", ":", ";", "enskip", "enspace", "quad", "qquad"], "", {
        createAtom: (e, t, a, i) => new Dt(e, a, i)
    }), K([
        ["\\colon", 58],
        ["\\cdotp", 8901],
        ["\\vdots", 8942, "mord"],
        ["\\ldotp", 46],
        [",", 44],
        [";", 59]
    ], "mpunct"), K([
        ["\\cdots", 8943],
        ["\\ddots", 8945],
        ["\\ldots", 8230],
        ["\\mathellipsis", 8230]
    ], "minner"), K([
        ["\\/", 47],
        ["|", 8739, "mord"],
        ["\\imath", 305],
        ["\\jmath", 567],
        ["\\degree", 176],
        ["'", 8242],
        ['"', 8221]
    ]);
    const Da = {
        "&": "\\&",
        "%": "\\%",
        "''": "^{\\doubleprime}",
        alpha: "\\alpha",
        delta: "\\delta",
        Delta: "\\Delta",
        pi: "\\pi",
        Pi: "\\Pi",
        theta: "\\theta",
        Theta: "\\Theta",
        ii: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\imaginaryI"
        },
        jj: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\imaginaryJ"
        },
        ee: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\exponentialE"
        },
        nabla: "\\nabla",
        grad: "\\nabla",
        del: "\\partial",
        deg: {
            after: "digit+space",
            value: "\\degree"
        },
        infty: "\\infty",
        "∞": "\\infty",
        oo: {
            after: "nothing+digit+frac+surd+binop+relop+punct+array+openfence+closefence+space",
            value: "\\infty"
        },
        "∑": "\\sum",
        sum: "\\sum_{#?}^{#?}",
        int: "\\int_{#?}^{#?}",
        prod: "\\prod_{#?}^{#?}",
        sqrt: "\\sqrt{#?}",
        "∆": "\\differentialD",
        "∂": "\\differentialD",
        arcsin: "\\arcsin",
        arccos: "\\arccos",
        arctan: "\\arctan",
        arcsec: "\\arcsec",
        arccsc: "\\arccsc",
        arsinh: "\\arsinh",
        arcosh: "\\arcosh",
        artanh: "\\artanh",
        arcsech: "\\arcsech",
        arccsch: "\\arccsch",
        arg: "\\arg",
        ch: "\\ch",
        cosec: "\\cosec",
        cosh: "\\cosh",
        cot: "\\cot",
        cotg: "\\cotg",
        coth: "\\coth",
        csc: "\\csc",
        ctg: "\\ctg",
        cth: "\\cth",
        sec: "\\sec",
        sinh: "\\sinh",
        sh: "\\sh",
        tanh: "\\tanh",
        tg: "\\tg",
        th: "\\th",
        sin: "\\sin",
        cos: "\\cos",
        tan: "\\tan",
        lg: "\\lg",
        lb: "\\lb",
        log: "\\log",
        ln: "\\ln",
        exp: "\\exp",
        lim: "\\lim_{#?}",
        dx: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\differentialD x"
        },
        dy: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\differentialD y"
        },
        dt: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\differentialD t"
        },
        AA: "\\forall",
        EE: "\\exists",
        "!EE": "\\nexists",
        "&&": "\\land",
        xin: {
            after: "nothing+text+relop+punct+openfence+space",
            value: "x \\in"
        },
        in: {
            after: "nothing+letter+closefence",
            value: "\\in"
        },
        "!in": "\\notin",
        NN: "\\mathbb{N}",
        ZZ: "\\Z",
        QQ: "\\Q",
        RR: "\\R",
        CC: "\\C",
        xx: "\\times",
        "+-": "\\pm",
        "≠": "\\ne",
        "!=": "\\ne",
        "≥": "\\ge",
        ">=": "\\ge",
        "≤": "\\le",
        "<=": "\\le",
        "<<": "\\ll",
        ">>": "\\gg",
        "~~": "\\approx",
        "≈": "\\approx",
        "?=": "\\questeq",
        "÷": "\\div",
        "¬": "\\neg",
        ":=": "\\coloneq",
        "::": "\\Colon",
        "(:": "\\langle",
        ":)": "\\rangle",
        beta: "\\beta",
        chi: "\\chi",
        epsilon: "\\epsilon",
        varepsilon: "\\varepsilon",
        eta: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\eta"
        },
        gamma: "\\gamma",
        Gamma: "\\Gamma",
        iota: "\\iota",
        kappa: "\\kappa",
        lambda: "\\lambda",
        Lambda: "\\Lambda",
        mu: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\mu"
        },
        nu: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\nu"
        },
        "µ": "\\mu",
        phi: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\phi"
        },
        Phi: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\Phi"
        },
        varphi: "\\varphi",
        psi: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\psi"
        },
        Psi: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\Psi"
        },
        rho: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\rho"
        },
        sigma: "\\sigma",
        Sigma: "\\Sigma",
        tau: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\tau"
        },
        vartheta: "\\vartheta",
        upsilon: "\\upsilon",
        xi: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space",
            value: "\\xi"
        },
        Xi: {
            after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
            value: "\\Xi"
        },
        zeta: "\\zeta",
        omega: "\\omega",
        Omega: "\\Omega",
        "Ω": "\\omega",
        forall: "\\forall",
        exists: "\\exists",
        "!exists": "\\nexists",
        ":.": "\\therefore",
        liminf: "\\liminf_{#?}",
        limsup: "\\limsup_{#?}",
        argmin: "\\operatorname*{arg~min}_{#?}",
        argmax: "\\operatorname*{arg~max}_{#?}",
        det: "\\det",
        mod: "\\mod",
        max: "\\max",
        min: "\\min",
        erf: "\\operatorname{erf}",
        erfc: "\\operatorname{erfc}",
        bessel: "\\operatorname{bessel}",
        mean: "\\operatorname{mean}",
        median: "\\operatorname{median}",
        fft: "\\operatorname{fft}",
        lcm: "\\operatorname{lcm}",
        gcd: "\\operatorname{gcd}",
        randomReal: "\\operatorname{randomReal}",
        randomInteger: "\\operatorname{randomInteger}",
        Re: "\\operatorname{Re}",
        Im: "\\operatorname{Im}",
        mm: {
            after: "nothing+digit+operator",
            value: "\\operatorname{mm}"
        },
        cm: {
            after: "nothing+digit+operator",
            value: "\\operatorname{cm}"
        },
        km: {
            after: "nothing+digit+operator",
            value: "\\operatorname{km}"
        },
        kg: {
            after: "nothing+digit+operator",
            value: "\\operatorname{kg}"
        },
        "...": "\\ldots",
        "+...": "+\\cdots",
        "-...": "-\\cdots",
        "->...": "\\to\\cdots",
        "->": "\\to",
        "|->": "\\mapsto",
        "--\x3e": "\\longrightarrow",
        "<--": "\\longleftarrow",
        "=>": "\\Rightarrow",
        "==>": "\\Longrightarrow",
        "<=>": "\\Leftrightarrow",
        "<->": "\\leftrightarrow",
        "(.)": "\\odot",
        "(+)": "\\oplus",
        "(/)": "\\oslash",
        "(*)": "\\otimes",
        "(-)": "\\ominus",
        "||": "\\Vert",
        "{": "\\{",
        "}": "\\}",
        "*": "\\cdot"
    };

    function Ta(e, t) {
        var a;
        let i = null !== (a = null == t ? void 0 : t.format) && void 0 !== a ? a : "auto";
        return "auto" === i && ([i, e] = function(e) {
            if ((e = e.trim()).length <= 1) return ["latex", e];
            let t;
            return [t, e] = $a(e), t ? ["latex", e] : e.startsWith("`") && e.endsWith("`") ? ["ascii-math", e = e.substring(1, e.length - 1)] : e.includes("\\") ? ["latex", e] : /\$.+\$/.test(e) ? ["latex", `\\text{${e}}`] : [void 0, e]
        }(e)), "ascii-math" === i ? ["ascii-math", za(e = (e = (e = (e = (e = (e = e.replace(/\u2061/gu, "")).replace(/\u3016/gu, "{")).replace(/\u3017/gu, "}")).replace(/([^\\])sinx/g, "$1\\sin x")).replace(/([^\\])cosx/g, "$1\\cos x ")).replace(/\u2013/g, "-"), {
            inlineShortcuts: null == t ? void 0 : t.inlineShortcuts
        })] : ["latex", e]
    }

    function za(e, t) {
        var a, i, o;
        if (!e) return "";
        let r, n = !1;
        const s = null !== (a = t.inlineShortcuts) && void 0 !== a ? a : Da;
        if (n || !e.startsWith("^") && !e.startsWith("_") || (r = Ba(e.slice(1), {
                inlineShortcuts: s,
                noWrap: !0
            }), e = e[0] + "{" + r.match + "}", e += za(r.rest, t), n = !0), !n && (r = e.match(/^(sqrt|\u221A)(.*)/), r) && (r = Ba(r[2], {
                inlineShortcuts: s,
                noWrap: !0
            }), e = "\\sqrt{" + (null !== (i = r.match) && void 0 !== i ? i : "\\placeholder{}") + "}", e += za(r.rest, t), n = !0), !n && (r = e.match(/^(\\cbrt|\u221B)(.*)/), r) && (r = Ba(r[2], {
                inlineShortcuts: s,
                noWrap: !0
            }), e = "\\sqrt[3]{" + (null !== (o = r.match) && void 0 !== o ? o : "\\placeholder{}") + "}", e += za(r.rest, t), n = !0), n || (r = e.match(/^abs(.*)/), r && (r = Ba(r[1], {
                inlineShortcuts: s,
                noWrap: !0
            }), e = "\\left|" + r.match + "\\right|", e += za(r.rest, t), n = !0)), n || (r = e.match(/^["\u201d\u201c](.*?)["\u201d\u201c](.*)/), r && (e = "\\text{" + r[1] + "}", e += za(r[2], t), n = !0)), n || (r = e.match(/^([^a-zA-Z\(\{\[\_\^\\\s"]+)(.*)/), r && (e = Ka(r[1], s), e += za(r[2], t), n = !0)), !n && /^([fgh])[^a-zA-Z]/.test(e) && (r = Ba(e.slice(1), {
                inlineShortcuts: s,
                noWrap: !0
            }), e = "(" === e[1] ? e[0] + "\\left(" + r.match + "\\right)" : e[0] + r.match, e += za(r.rest, t), n = !0), n || (r = e.match(/^([a-zA-Z]+)(.*)/), r && (e = Ka(r[1], s), e += za(r[2], t), n = !0)), !n)
            if (r = Ba(e, {
                    inlineShortcuts: s,
                    noWrap: !0
                }), r.match && "/" === r.rest[0]) {
                const a = Ba(r.rest.slice(1), {
                    inlineShortcuts: s,
                    noWrap: !0
                });
                a.match && (e = "\\frac{" + r.match + "}{" + a.match + "}" + za(a.rest, t)), n = !0
            } else r.match && (e = e.startsWith("(") ? "\\left(" + r.match + "\\right)" + za(r.rest, t) : r.match + za(r.rest, t), n = !0);
        return n || (r = e.match(/^(\s+)(.*)$/), r && (e = " " + za(r[2], t), n = !0)), e
    }

    function Ba(e, t) {
        let a = "",
            i = e = e.trim(),
            o = e.charAt(0),
            r = {
                "(": ")",
                "{": "}",
                "[": "]"
            } [o];
        if (r) {
            let n = 1,
                s = 1;
            for (; s < e.length && n > 0;) e[s] === o && n++, e[s] === r && n--, s++;
            0 === n ? (t.noWrap && "(" === o ? a = za(e.substring(1, s - 1), t) : ("{" === o && "}" === r && (o = "\\{", r = "\\}"), a = "\\left" + o + za(e.substring(1, s - 1), t) + "\\right" + r), i = e.slice(Math.max(0, s))) : (a = e.substring(1, s), i = "")
        } else {
            let o = e.match(/^([a-zA-Z]+)/);
            if (o) {
                let a = Aa(null, e, t.inlineShortcuts);
                if (a) return a = a.replace("_{#?}", ""), a = a.replace("^{#?}", ""), {
                    match: a,
                    rest: e.slice(a.length)
                }
            }
            if (o = e.match(/^([a-zA-Z])/), o) return {
                match: o[1],
                rest: e.slice(1)
            };
            if (o = e.match(/^(-)?\d+(\.\d*)?/), o) return {
                match: o[0],
                rest: e.slice(o[0].length)
            };
            /^\\(left|right)/.test(e) || (o = e.match(/^(\\[a-zA-Z]+)/), o && (i = e.slice(o[1].length), a = o[1]))
        }
        return {
            match: a,
            rest: i
        }
    }

    function Ka(e, t) {
        let a = Aa(null, e, t);
        return a ? (a = a.replace("_{#?}", ""), a = a.replace("^{#?}", ""), a += " ") : a = e, a
    }
    const qa = [
        ["\\[", "\\]"],
        ["\\(", "\\)"],
        ["$$", "$$"],
        ["$", "$"],
        ["\\begin{math}", "\\end{math}"],
        ["\\begin{displaymath}", "\\end{displaymath}"],
        ["\\begin{equation}", "\\end{equation}"],
        ["\\begin{equation*}", "\\end{equation*}"]
    ];

    function $a(e) {
        const t = e.trim();
        for (const e of qa)
            if (t.startsWith(e[0]) && t.endsWith(e[1])) return [!0, t.substring(e[0].length, t.length - e[1].length)];
        return [!1, e]
    }
    const Ea = (e, t, a) => (qa.some((e => t.startsWith(e[0]) && t.endsWith(e[1]))) || (t = `$$ ${t} $$`), t);
    class Oa {
        static onPaste(e, t, a) {
            var i;
            const o = new ClipboardEvent("paste", {
                clipboardData: a.clipboardData,
                cancelable: !0
            });
            return !!(null === (i = t.host) || void 0 === i ? void 0 : i.dispatchEvent(o)) && Oa._registry[e].onPaste(t, a)
        }
        static onCopy(e, t) {
            if (!t.clipboardData) return;
            const a = e.model,
                i = a.selectionIsCollapsed ? [0, a.lastOffset] : Ca(a.selection);
            let o = a.getAtoms(i);
            if (o.every((e => "text" === e.mode || !e.mode))) t.clipboardData.setData("text/plain", o.filter((e => e instanceof $t)).map((e => e.value)).join(""));
            else if (o.every((e => "latex" === e.mode))) t.clipboardData.setData("text/plain", a.getAtoms(i, {
                includeChildren: !0
            }).map((e => {
                var t;
                return null !== (t = e.value) && void 0 !== t ? t : ""
            })).join(""));
            else {
                let r;
                r = 1 === o.length && void 0 !== o[0].verbatimLatex ? o[0].verbatimLatex : a.getValue(i, "latex-expanded"), t.clipboardData.setData("application/x-latex", r);
                try {
                    t.clipboardData.setData("text/plain", e.options.onExport(e, r, i))
                } catch {}
                1 !== o.length || "root" !== o[0].type && "group" !== o[0].type || (o = o[0].body.filter((e => "first" !== e.type)));
                try {
                    t.clipboardData.setData("application/json+mathlive", JSON.stringify(o.map((e => e.toJson()))))
                } catch {}
                const n = e.computeEngine;
                if (n) try {
                    n.jsonSerializationOptions = {
                        metadata: ["latex"]
                    };
                    const e = n.parse(r),
                        a = JSON.stringify(e.json);
                    a && t.clipboardData.setData("application/json", a)
                } catch {}
            }
            t.preventDefault()
        }
        static insert(e, t, a, i = {}) {
            return Oa._registry[e].insert(t, a, i)
        }
        onPaste(e, t) {
            return !1
        }
        insert(e, t, a) {
            return !1
        }
        constructor(e) {
            Oa._registry[e] = this
        }
    }
    Oa._registry = {};
    const Na = {
        "\\ne": "<mo>&ne;</mo>",
        "\\neq": "<mo>&neq;</mo>",
        "\\pm": "&#177;",
        "\\times": "&#215;",
        "\\colon": ":",
        "\\vert": "|",
        "\\Vert": "∥",
        "\\mid": "∣",
        "\\lbrace": "{",
        "\\rbrace": "}",
        "\\lparen": "(",
        "\\rparen": ")",
        "\\langle": "⟨",
        "\\rangle": "⟩",
        "\\lfloor": "⌊",
        "\\rfloor": "⌋",
        "\\lceil": "⌈",
        "\\rceil": "⌉",
        "\\vec": "&#x20d7;",
        "\\acute": "&#x00b4;",
        "\\grave": "&#x0060;",
        "\\dot": "&#x02d9;",
        "\\ddot": "&#x00a8;",
        "\\tilde": "&#x007e;",
        "\\bar": "&#x00af;",
        "\\breve": "&#x02d8;",
        "\\check": "&#x02c7;",
        "\\hat": "&#x005e;"
    };

    function Pa(e) {
        return e.replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
    }

    function Fa(e, t) {
        return e && t.generateID ? ` extid="${e}"` : ""
    }

    function Ra(e, t, a) {
        let i = !1;
        t = null != t ? t : e.atoms.length;
        let o = "",
            r = "";
        const n = e.atoms[e.index];
        return e.index < t && ("mord" === n.type || "macro" === n.type) && !n.isDigit() && (r = Za(n, a), e.index += 1), r.length > 0 && (i = !0, o = r, "mi" !== e.lastType && "mn" !== e.lastType && "mtext" !== e.lastType && "fence" !== e.lastType || /^<mo>(.*)<\/mo>$/.test(o) || (o = `<mo>&#8290;</mo>${o}`), r.endsWith(">f</mi>") || r.endsWith(">g</mi>") ? (o += "<mo>&#x2061;</mo>", e.lastType = "applyfunction") : e.lastType = /^<mo>(.*)<\/mo>$/.test(o) ? "mo" : "mi", Va(r, e, a) || (e.mathML += o)), i
    }

    function Ia(e) {
        return e.index < e.atoms.length && e.atoms[e.index].superscript && "msubsup" === e.atoms[e.index].type
    }

    function Va(e, t, a) {
        let i = t.atoms[t.index - 1];
        if (!i) return !1;
        if (i.superscript || i.subscript || (Ia(t) || function(e) {
                return e.index < e.atoms.length && e.atoms[e.index].subscript && "msubsup" === e.atoms[e.index].type
            }(t)) && (i = t.atoms[t.index], t.index += 1), !i) return !1;
        const o = Ua(i.superscript, a),
            r = Ua(i.subscript, a);
        if (!o && !r) return !1;
        let n = "";
        return o && r ? n = `<msubsup>${e}${r}${o}</msubsup>` : o ? n = `<msup>${e}${o}</msup>` : r && (n = `<msub>${e}${r}</msub>`), t.mathML += n, t.lastType = "", !0
    }

    function ja(e, t, a) {
        t = null != t ? t : e.atoms.length;
        const i = e.index;
        let o = "";
        for (; e.index < t && "text" === e.atoms[e.index].mode;) o += e.atoms[e.index].value ? e.atoms[e.index].value : " ", e.index += 1;
        return o.length > 0 && (e.mathML += `<mtext ${Fa(e.atoms[i].id,a)}\n      >${o}</mtext>`, e.lastType = "mtext", !0)
    }

    function Ha(e, t, a) {
        t = null != t ? t : e.atoms.length;
        const i = e.index;
        let o = "",
            r = function(e) {
                let t = -1,
                    a = e.index,
                    i = !1,
                    o = !1;
                for (; a < e.atoms.length && !i && !o;) {
                    const t = e.atoms[a];
                    i = !t.isDigit(), o = !i && void 0 !== t.superscript, a++
                }
                return o && (t = a - 1), t
            }(e);
        for (r >= 0 && r < t && (t = r); e.index < t && e.atoms[e.index].isDigit();) o += e.atoms[e.index].asDigit(), e.index += 1;
        return !(o.length <= 0 || (o = "<mn" + Fa(e.atoms[i].id, a) + ">" + o + "</mn>", r < 0 && Ia(e) && (r = e.index, e.index += 1), Va(o, e, a) || (e.mathML += o, e.lastType = "mn"), 0))
    }

    function Wa(e, t, a) {
        let i = !1;
        t = null != t ? t : e.atoms.length;
        let o = "",
            r = "";
        if (e.index < t && "mopen" === e.atoms[e.index].type) {
            let n = !1,
                s = 0;
            const l = e.index;
            let d = -1,
                c = l + 1;
            for (; c < t && !n;) "mopen" === e.atoms[c].type ? s += 1 : "mclose" === e.atoms[c].type && (s -= 1), -1 === s && (n = !0, d = c), c += 1;
            n && (o = "<mrow>", o += Xa(e.atoms[l], a), o += Ua(e.atoms, a, l + 1, d), o += Xa(e.atoms[d], a), o += "</mrow>", "mi" !== e.lastType && "mn" !== e.lastType && "mfrac" !== e.lastType && "fence" !== e.lastType || (o = `<mo>&#8290;</mo>${o}`), e.index = d + 1, Va(o, e, a) && (i = !0, e.lastType = "", o = ""), r = "fence")
        }
        return o.length > 0 && (i = !0, e.mathML += o, e.lastType = r), i
    }

    function Ja(e, t, a) {
        let i = !1;
        t = null != t ? t : e.atoms.length;
        let o = "",
            r = "";
        const n = e.atoms[e.index];
        if (e.index < t && ("mbin" === n.type || "mrel" === n.type)) o += Za(e.atoms[e.index], a), e.index += 1, r = "mo";
        else if (e.index < t && "mop" === n.type) {
            if ("over-under" === n.subsupPlacement && (n.superscript || n.subscript)) {
                const e = Xa(n, a);
                n.superscript && n.subscript ? (o += "<munderover>" + e, o += Ua(n.subscript, a), o += Ua(n.superscript, a), o += "</munderover>") : n.superscript ? (o += "<mover>" + e, o += Ua(n.superscript, a), o += "</mover>") : n.subscript && (o += "<munder>" + e, o += Ua(n.subscript, a), o += "</munder>"), r = "mo"
            } else {
                const t = e.atoms[e.index],
                    i = "\\operatorname" === t.value,
                    n = i ? '<mi class="MathML-Unit"' + Fa(t.id, a) + ">" + Ga(t.value) + "</mi>" : Xa(t, a);
                o += n, i || /^<mo>(.*)<\/mo>$/.test(n) ? r = i ? "mi" : "mo" : (o += "<mo>&#x2061;</mo>", r = "applyfunction")
            }
            "mi" !== e.lastType && "mn" !== e.lastType || /^<mo>(.*)<\/mo>$/.test(o) || (o = `<mo>&#8290;</mo>${o}`), e.index += 1
        }
        return Va(o, e, a) || o.length > 0 && (i = !0, e.mathML += o, e.lastType = r), i
    }

    function Ua(e, t, a, i) {
        const o = {
            atoms: [],
            index: null != a ? a : 0,
            mathML: "",
            lastType: ""
        };
        if ("number" == typeof e || "boolean" == typeof e) o.mathML = e.toString();
        else if ("string" == typeof e) o.mathML = e;
        else if (e instanceof lt) o.mathML = Za(e, t);
        else if (Array.isArray(e)) {
            o.atoms = e;
            let a = 0;
            for (i = i || (e ? e.length : 0); o.index < i;)
                if (ja(o, i, t) || Ha(o, i, t) || Ra(o, i, t) || Ja(o, i, t) || Wa(o, i, t)) a += 1;
                else if (o.index < i) {
                let e = Za(o.atoms[o.index], t);
                "mn" === o.lastType && e.length > 0 && "genfrac" === o.atoms[o.index].type && (e = "<mo>&#x2064;</mo>" + e), "genfrac" === o.atoms[o.index].type ? o.lastType = "mfrac" : o.lastType = "", o.index += 1, Va(e, o, t) ? a += 2 : e.length > 0 && (o.mathML += e, a += 1)
            }
            a > 1 && (o.mathML = "<mrow>" + o.mathML + "</mrow>")
        }
        return o.mathML
    }

    function Xa(e, t) {
        let a = "";
        const i = Ga(e.value);
        return i && (a = "<mo" + Fa(e.id, t) + ">" + i + "</mo>"), a
    }

    function Ga(e) {
        if (!e) return "";
        if ("string" == typeof e) return Pa(e);
        if (!Array.isArray(e) && "string" == typeof e.body) return Pa(e.body);
        let t = "";
        for (const a of e) "string" == typeof a.value && (t += a.value);
        return Pa(t)
    }

    function Za(e, t) {
        var a, i, o, r, n, s, l, d, c, u, p, h, m, f, y, b, g, v, k, x, w, _, S, M, L;
        const C = {
                widehat: "^",
                widecheck: "ˇ",
                widetilde: "~",
                utilde: "~",
                overleftarrow: "←",
                underleftarrow: "←",
                xleftarrow: "←",
                overrightarrow: "→",
                underrightarrow: "→",
                xrightarrow: "→",
                underbrace: "⏟",
                overbrace: "⏞",
                overgroup: "⏠",
                undergroup: "⏡",
                overleftrightarrow: "↔",
                underleftrightarrow: "↔",
                xleftrightarrow: "↔",
                Overrightarrow: "⇒",
                xRightarrow: "⇒",
                overleftharpoon: "↼",
                xleftharpoonup: "↼",
                overrightharpoon: "⇀",
                xrightharpoonup: "⇀",
                xLeftarrow: "⇐",
                xLeftrightarrow: "⇔",
                xhookleftarrow: "↩",
                xhookrightarrow: "↪",
                xmapsto: "↦",
                xrightharpoondown: "⇁",
                xleftharpoondown: "↽",
                xrightleftharpoons: "⇌",
                xleftrightharpoons: "⇋",
                xtwoheadleftarrow: "↞",
                xtwoheadrightarrow: "↠",
                xlongequal: "=",
                xtofrom: "⇄",
                xrightleftarrows: "⇄",
                xrightequilibrium: "⇌",
                xleftequilibrium: "⇋"
            },
            A = {
                "\\exponentialE": "&#x02147;",
                "\\imaginaryI": "&#x2148;",
                "\\differentialD": "&#x2146;",
                "\\capitalDifferentialD": "&#x2145;",
                "\\alpha": "&#x03b1;",
                "\\pi": "&#x03c0;",
                "\\infty": "&#x221e;",
                "\\forall": "&#x2200;",
                "\\nexists": "&#x2204;",
                "\\exists": "&#x2203;",
                "\\hbar": "ℏ",
                "\\cdotp": "⋅",
                "\\ldots": "…",
                "\\cdots": "⋯",
                "\\ddots": "⋱",
                "\\vdots": "⋮",
                "\\ldotp": "."
            },
            D = {
                "\\!": -3 / 18,
                "\\ ": 6 / 18,
                "\\,": 3 / 18,
                "\\:": 4 / 18,
                "\\;": 5 / 18,
                "\\enspace": .5,
                "\\quad": 1,
                "\\qquad": 2,
                "\\enskip": .5
            };
        let T, z, B, K, q, $, E = "",
            O = "",
            N = null !== (i = {
                cal: "script",
                frak: "fraktur",
                bb: "double-struck",
                scr: "script",
                cmtt: "monospace",
                cmss: "sans-serif"
            } [null !== (a = e.fontFamily) && void 0 !== a ? a : e.font]) && void 0 !== i ? i : "";
        N && (N = ` mathvariant="${N}"`);
        const {
            command: P
        } = e;
        if ("text" === e.mode) E = `<mi${Fa(e.id,t)}>${e.value}</mi>`;
        else switch (e.type) {
            case "first":
            case "line":
            case "overlap":
            case "msubsup":
            case "phantom":
            case "composition":
            case "rule":
            case "chem":
            case "error":
                break;
            case "group":
            case "root":
                E = Na[e.command] ? Na[e.command] : Ua(e.body, t);
                break;
            case "array":
                if ((e.leftDelim && "." !== e.leftDelim || e.rightDelim && "." !== e.rightDelim) && (E += "<mrow>", e.leftDelim && "." !== e.leftDelim && (E += "<mo>" + (Na[e.leftDelim] || e.leftDelim) + "</mo>")), E += "<mtable", e.colFormat) {
                    for (E += ' columnalign="', B = 0; B < e.colFormat.length; B++) e.colFormat[B].align && (E += {
                        l: "left",
                        c: "center",
                        r: "right"
                    } [e.colFormat[B].align] + " ");
                    E += '"'
                }
                for (E += ">", z = 0; z < e.array.length; z++) {
                    for (E += "<mtr>", T = 0; T < e.array[z].length; T++) E += "<mtd>" + Ua(e.array[z][T], t) + "</mtd>";
                    E += "</mtr>"
                }
                E += "</mtable>", (e.leftDelim && "." !== e.leftDelim || e.rightDelim && "." !== e.rightDelim) && (e.rightDelim && "." !== e.rightDelim && (E += "<mo>" + (Na[e.leftDelim] || e.rightDelim) + "</mo>"), E += "</mrow>");
                break;
            case "genfrac":
                (e.leftDelim || e.rightDelim) && (E += "<mrow>"), e.leftDelim && "." !== e.leftDelim && (E += "<mo" + Fa(e.id, t) + ">" + (Na[e.leftDelim] || e.leftDelim) + "</mo>"), e.hasBarLine ? (E += "<mfrac>", E += Ua(e.above, t) || "<mi>&nbsp;</mi>", E += Ua(e.below, t) || "<mi>&nbsp;</mi>", E += "</mfrac>") : (E += "<mtable" + Fa(e.id, t) + ">", E += "<mtr>" + Ua(e.above, t) + "</mtr>", E += "<mtr>" + Ua(e.below, t) + "</mtr>", E += "</mtable>"), e.rightDelim && "." !== e.rightDelim && (E += "<mo" + Fa(e.id, t) + ">" + (Na[e.rightDelim] || e.rightDelim) + "</mo>"), (e.leftDelim || e.rightDelim) && (E += "</mrow>");
                break;
            case "surd":
                e.hasEmptyBranch("above") ? (E += "<msqrt" + Fa(e.id, t) + ">", E += Ua(e.body, t), E += "</msqrt>") : (E += "<mroot" + Fa(e.id, t) + ">", E += Ua(e.body, t), E += Ua(e.above, t), E += "</mroot>");
                break;
            case "leftright":
                E = "<mrow>", e.leftDelim && "." !== e.leftDelim && (E += "<mo" + Fa(e.id, t) + ">" + (null !== (o = Na[e.leftDelim]) && void 0 !== o ? o : e.leftDelim) + "</mo>"), e.body && (E += Ua(e.body, t)), e.rightDelim && "." !== e.rightDelim && (E += "<mo" + Fa(e.id, t) + ">" + (null !== (r = Na[e.rightDelim]) && void 0 !== r ? r : e.rightDelim) + "</mo>"), E += "</mrow>";
                break;
            case "sizeddelim":
            case "delim":
                E += '<mo separator="true"' + Fa(e.id, t) + ">" + (Na[e.delim] || e.delim) + "</mo>";
                break;
            case "accent":
                E += '<mover accent="true"' + Fa(e.id, t) + ">", E += Ua(e.body, t), E += "<mo>" + (Na[P] || e.accent) + "</mo>", E += "</mover>";
                break;
            case "overunder":
                q = e.above, K = e.below, (e.svgAbove || q) && (e.svgBelow || K) ? $ = e.body : q && q.length > 0 ? ($ = e.body, (null === (s = null === (n = e.body) || void 0 === n ? void 0 : n[0]) || void 0 === s ? void 0 : s.below) ? (K = e.body[0].below, $ = e.body[0].body) : "first" === (null === (d = null === (l = e.body) || void 0 === l ? void 0 : l[0]) || void 0 === d ? void 0 : d.type) && (null === (u = null === (c = e.body) || void 0 === c ? void 0 : c[1]) || void 0 === u ? void 0 : u.below) && (K = e.body[1].below, $ = e.body[1].body)) : K && K.length > 0 && ($ = e.body, (null === (h = null === (p = e.body) || void 0 === p ? void 0 : p[0]) || void 0 === h ? void 0 : h.above) ? (q = e.body[0].above, $ = e.body[0].body) : "first" === (null === (f = null === (m = e.body) || void 0 === m ? void 0 : m[0]) || void 0 === f ? void 0 : f.type) && (null === (b = null === (y = e.body) || void 0 === y ? void 0 : y[1]) || void 0 === b ? void 0 : b.above) && (q = e.body[1].overscript, $ = e.body[1].body)), (e.svgAbove || q) && (e.svgBelow || K) ? (E += `<munderover ${N} ${Fa(e.id,t)}>`, E += null !== (g = C[e.svgBody]) && void 0 !== g ? g : Ua($, t), E += null !== (v = C[e.svgBelow]) && void 0 !== v ? v : Ua(K, t), E += null !== (k = C[e.svgAbove]) && void 0 !== k ? k : Ua(q, t), E += "</munderover>") : e.svgAbove || q ? (E += `<mover ${N} ${Fa(e.id,t)}>` + (null !== (x = C[e.svgBody]) && void 0 !== x ? x : Ua($, t)), E += null !== (w = C[e.svgAbove]) && void 0 !== w ? w : Ua(q, t), E += "</mover>") : (e.svgBelow || K) && (E += `<munder ${N} ${Fa(e.id,t)}>` + (null !== (_ = C[e.svgBody]) && void 0 !== _ ? _ : Ua($, t)), E += null !== (S = C[e.svgBelow]) && void 0 !== S ? S : Ua(K, t), E += "</munder>");
                break;
            case "placeholder":
            case "mord": {
                E = A[P] || P || ("string" == typeof e.value ? e.value : "");
                const a = P ? P.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null;
                a ? E = "&#x" + a[1] + ";" : E.length > 0 && E.startsWith("\\") && (E = "string" == typeof e.value && e.value.charCodeAt(0) > 255 ? "&#x" + ("000000" + e.value.charCodeAt(0).toString(16)).slice(-4) + ";" : "string" == typeof e.value ? e.value.charAt(0) : "");
                const i = /\d/.test(E) ? "mn" : "mi";
                E = `<${i}${N}${Fa(e.id,t)}>${Pa(E)}</${i}>`;
                break
            }
            case "mbin":
            case "mrel":
            case "minner":
                E = P && A[P] ? "<mi" + Fa(e.id, t) + ">" + A[P] + "</mi>" : P && Na[P] ? "<mo" + Fa(e.id, t) + ">" + Na[P] + "</mo>" : Xa(e, t);
                break;
            case "mpunct":
                E = '<mo separator="true"' + Fa(e.id, t) + ">" + (null !== (M = Na[P]) && void 0 !== M ? M : P) + "</mo>";
                break;
            case "mop":
                "​" !== e.body && (E = "<mo" + Fa(e.id, t) + ">", E += "\\operatorname" === P ? e.body : P || e.body, E += "</mo>");
                break;
            case "box":
                E = '<menclose notation="box"', e.backgroundcolor && (E += ' mathbackground="' + e.backgroundcolor + '"'), E += Fa(e.id, t) + ">" + Ua(e.body, t) + "</menclose>";
                break;
            case "spacing":
                E += '<mspace width="' + (null !== (L = D[P]) && void 0 !== L ? L : 0) + 'em"/>';
                break;
            case "enclose":
                E = '<menclose notation="';
                for (const t in e.notation) Object.prototype.hasOwnProperty.call(e.notation, t) && e.notation[t] && (E += O + t, O = " ");
                E += Fa(e.id, t) + '">' + Ua(e.body, t) + "</menclose>";
                break;
            case "space":
                E += "&nbsp;";
                break;
            case "mopen":
            case "mclose":
                E += Xa(e, t);
                break;
            case "macro": {
                const a = e.command + Ga(e.macroArgs);
                a && (E += `<mo ${Fa(e.id,t)}>${a}</mo>`)
            }
            break;
            case "latexgroup":
            case "tooltip":
                E += Ua(e.body, t);
                break;
            case "latex":
                E += "<mtext" + Fa(e.id, t) + ">" + e.value + "</mtext>"
        }
        return E
    }
    const Ya = {
        "\\alpha": "alpha ",
        "\\mu": "mew ",
        "\\sigma": "sigma ",
        "\\pi": "pie ",
        "\\imaginaryI": "eye ",
        "\\sum": "Summation ",
        "\\prod": "Product ",
        a: '<phoneme alphabet="ipa" ph="eɪ">a</phoneme>',
        A: 'capital <phoneme alphabet="ipa" ph="eɪ">A</phoneme>',
        "+": "plus ",
        "-": "minus ",
        ";": '<break time="150ms"/> semi-colon <break time="150ms"/>',
        ",": '<break time="150ms"/> comma  <break time="150ms"/>',
        "|": '<break time="150ms"/>Vertical bar<break time="150ms"/>',
        "(": '<break time="150ms"/>Open paren. <break time="150ms"/>',
        ")": '<break time="150ms"/> Close paren. <break time="150ms"/>',
        "=": "equals ",
        "<": "is less than ",
        "\\lt": "is less than ",
        "<=": "is less than or equal to ",
        "\\le": "is less than or equal to ",
        "\\gt": "is greater than ",
        ">": "is greater than ",
        "\\ge": "is greater than or equal to ",
        "\\geq": "is greater than or equal to ",
        "\\leq": "is less than or equal to ",
        "!": "factorial ",
        "\\sin": "sine ",
        "\\cos": "cosine ",
        "​": "",
        "−": "minus ",
        ":": '<break time="150ms"/> such that <break time="200ms"/> ',
        "\\colon": '<break time="150ms"/> such that <break time="200ms"/> ',
        "\\hbar": "etch bar ",
        "\\iff": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
        "\\Longleftrightarrow": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
        "\\land": "and ",
        "\\lor": "or ",
        "\\neg": "not ",
        "\\div": "divided by ",
        "\\forall": "for all ",
        "\\exists": "there exists ",
        "\\nexists": "there does not exists ",
        "\\in": "element of ",
        "\\N": 'the set <break time="150ms"/><say-as interpret-as="character">n</say-as>',
        "\\C": 'the set <break time="150ms"/><say-as interpret-as="character">c</say-as>',
        "\\Z": 'the set <break time="150ms"/><say-as interpret-as="character">z</say-as>',
        "\\Q": 'the set <break time="150ms"/><say-as interpret-as="character">q</say-as>',
        "\\infty": "infinity ",
        "\\nabla": "nabla ",
        "\\partial": "partial derivative of ",
        "\\cdot": "times ",
        "\\cdots": "dot dot dot ",
        "\\Rightarrow": "implies ",
        "\\lparen": '<break time="150ms"/>open paren<break time="150ms"/>',
        "\\rparen": '<break time="150ms"/>close paren<break time="150ms"/>',
        "\\lbrace": '<break time="150ms"/>open brace<break time="150ms"/>',
        "\\{": '<break time="150ms"/>open brace<break time="150ms"/>',
        "\\rbrace": '<break time="150ms"/>close brace<break time="150ms"/>',
        "\\}": '<break time="150ms"/>close brace<break time="150ms"/>',
        "\\langle": '<break time="150ms"/>left angle bracket<break time="150ms"/>',
        "\\rangle": '<break time="150ms"/>right angle bracket<break time="150ms"/>',
        "\\lfloor": '<break time="150ms"/>open floor<break time="150ms"/>',
        "\\rfloor": '<break time="150ms"/>close floor<break time="150ms"/>',
        "\\lceil": '<break time="150ms"/>open ceiling<break time="150ms"/>',
        "\\rceil": '<break time="150ms"/>close ceiling<break time="150ms"/>',
        "\\vert": '<break time="150ms"/>vertical bar<break time="150ms"/>',
        "\\mvert": '<break time="150ms"/>divides<break time="150ms"/>',
        "\\lvert": '<break time="150ms"/>left vertical bar<break time="150ms"/>',
        "\\rvert": '<break time="150ms"/>right vertical bar<break time="150ms"/>',
        "\\lbrack": '<break time="150ms"/> open square bracket <break time="150ms"/>',
        "\\rbrack": '<break time="150ms"/> close square bracket <break time="150ms"/>',
        mm: "millimeters",
        cm: "centimeters",
        km: "kilometers",
        kg: "kilograms"
    };

    function Qa(e) {
        let t = 0;
        if (i(e))
            for (const a of e) "first" !== a.type && (t += 1);
        return 1 === t
    }

    function ei(e) {
        let t = "";
        if (i(e))
            for (const a of e) "first" !== a.type && "string" == typeof a.value && (t += a.value);
        return t
    }

    function ti(e, t, a) {
        var o, r, n, s;

        function l(e) {
            return "<emphasis>" + e + "</emphasis>"
        }
        if (!t) return "";
        let d = "";
        if (i(t)) {
            let i = !1,
                r = !1;
            for (let n = 0; n < t.length; n++) "text" !== t[n].mode && (r = !1), n < t.length - 2 && "mopen" === t[n].type && "mclose" === t[n + 2].type && "mord" === t[n + 1].type ? (d += " of ", d += l(ti(e, t[n + 1], a)), n += 2) : "text" === t[n].mode ? r ? d += null !== (o = t[n].value) && void 0 !== o ? o : " " : (r = !0, d += ti("text", t[n], a)) : t[n].isDigit() ? i ? d += t[n].asDigit() : (i = !0, d += ti(e, t[n], a)) : (i = !1, d += ti(e, t[n], a))
        } else if ("text" === t.mode) t.id && "math" === e && (d += '<mark name="' + t.id.toString() + '"/>'), d += t.value;
        else {
            t.id && "math" === e && (d += '<mark name="' + t.id.toString() + '"/>');
            let o = "",
                p = "",
                h = "",
                m = !1;
            switch (t.type) {
                case "group":
                case "root":
                    d += ti("math", t.body, a);
                    break;
                case "genfrac":
                    if (o = ti("math", t.above, a), p = ti("math", t.below, a), Qa(t.above) && Qa(t.below)) {
                        const e = {
                            "1/2": " half ",
                            "1/3": " one third ",
                            "2/3": " two third",
                            "1/4": " one quarter ",
                            "3/4": " three quarter ",
                            "1/5": " one fifth ",
                            "2/5": " two fifths ",
                            "3/5": " three fifths ",
                            "4/5": " four fifths ",
                            "1/6": " one sixth ",
                            "5/6": " five sixths ",
                            "1/8": " one eight ",
                            "3/8": " three eights ",
                            "5/8": " five eights ",
                            "7/8": " seven eights ",
                            "1/9": " one ninth ",
                            "2/9": " two ninths ",
                            "4/9": " four ninths ",
                            "5/9": " five ninths ",
                            "7/9": " seven ninths ",
                            "8/9": " eight ninths "
                        } [ei(t.above) + "/" + ei(t.below)];
                        e ? d = e : d += o + " over " + p
                    } else d += ' the fraction <break time="150ms"/>' + o + ', over <break time="150ms"/>' + p + '.<break time="150ms"/> End fraction.<break time="150ms"/>';
                    break;
                case "surd":
                    if (h = ti("math", t.body, a), t.hasEmptyBranch("above")) d += Qa(t.body) ? " the square root of " + h + " , " : ' the square root of <break time="200ms"/>' + h + '. <break time="200ms"/> End square root';
                    else {
                        let e = ti("math", t.above, a);
                        e = e.trim();
                        const i = e.replace(/<mark([^/]*)\/>/g, "");
                        d += "3" === i ? ' the cube root of <break time="200ms"/>' + h + '. <break time="200ms"/> End cube root' : "n" === i ? ' the nth root of <break time="200ms"/>' + h + '. <break time="200ms"/> End root' : ' the root with index: <break time="200ms"/>' + e + ', of <break time="200ms"/>' + h + '. <break time="200ms"/> End root'
                    }
                    break;
                case "leftright": {
                    const e = t;
                    d += null !== (r = e.leftDelim ? Ya[e.leftDelim] : void 0) && void 0 !== r ? r : e.leftDelim, d += ti("math", t.body, a), d += null !== (n = e.rightDelim ? Ya[e.rightDelim] : void 0) && void 0 !== n ? n : e.rightDelim
                }
                break;
                case "rule":
                case "overunder":
                case "overlap":
                    break;
                case "placeholder":
                    d += "placeholder ";
                    break;
                case "delim":
                case "sizeddelim":
                case "mord":
                case "minner":
                case "mbin":
                case "mrel":
                case "mpunct":
                case "mopen":
                case "mclose": {
                    const {
                        command: i
                    } = t;
                    if ("\\mathbin" === i || "\\mathrel" === i || "\\mathopen" === i || "\\mathclose" === i || "\\mathpunct" === i || "\\mathord" === i || "\\mathinner" === i) {
                        d = ti(e, t.body, a);
                        break
                    }
                    let o = t.isDigit() ? t.asDigit() : t.value,
                        r = t.command;
                    if ("delim" !== t.type && "sizeddelim" !== t.type || (r = t.value, o = r), "text" === e) d += o;
                    else {
                        if ("mbin" === t.type && (d += '<break time="150ms"/>'), o) {
                            const e = Ya[o] || (r ? Ya[r.trim()] : "");
                            if (e) d += " " + e;
                            else {
                                const e = r ? function(e) {
                                    let t = "";
                                    return e.startsWith("\\") && (t = " " + e.replace("\\", "") + " "), t
                                }(r.trim()) : "";
                                d += e || (u = o, a.textToSpeechMarkup ? /[a-z]/.test(u) ? ` <say-as interpret-as="character">${u}</say-as>` : /[A-Z]/.test(u) ? `capital <say-as interpret-as="character">${u.toLowerCase()}</say-as>` : u : /[a-z]/.test(u) ? " '" + u.toUpperCase() + "'" : /[A-Z]/.test(u) ? " 'capital " + u.toUpperCase() + "'" : u)
                            }
                        } else d += ti("math", t.body, a);
                        "mbin" === t.type && (d += '<break time="150ms"/>')
                    }
                    break
                }
                case "mop":
                    if ("​" !== t.value) {
                        const e = t.command;
                        if ("\\sum" === e)
                            if (t.hasEmptyBranch("superscript") || t.hasEmptyBranch("subscript"))
                                if (t.hasEmptyBranch("subscript")) d += " the summation of";
                                else {
                                    let e = ti("math", t.subscript, a);
                                    e = e.trim(), d += ' the summation from <break time="200ms"/>' + e + '<break time="200ms"/> of <break time="150ms"/>', m = !0
                                }
                        else {
                            let e = ti("math", t.superscript, a);
                            e = e.trim();
                            let i = ti("math", t.subscript, a);
                            i = i.trim(), d += ' the summation from <break time="200ms"/>' + i + '<break time="200ms"/> to  <break time="200ms"/>' + e + '<break time="200ms"/> of <break time="150ms"/>', m = !0
                        } else if ("\\prod" === e)
                            if (t.hasEmptyBranch("superscript") || t.hasEmptyBranch("subscript"))
                                if (t.hasEmptyBranch("subscript")) d += " the product  of ";
                                else {
                                    let e = ti("math", t.subscript, a);
                                    e = e.trim(), d += ' the product from <break time="200ms"/>' + e + '<break time="200ms"/> of <break time="150ms"/>', m = !0
                                }
                        else {
                            let e = ti("math", t.superscript, a);
                            e = e.trim();
                            let i = ti("math", t.subscript, a);
                            i = i.trim(), d += ' the product from <break time="200ms"/>' + i + '<break time="200ms"/> to <break time="200ms"/>' + e + '<break time="200ms"/> of <break time="150ms"/>', m = !0
                        } else if ("\\int" === e)
                            if (t.hasEmptyBranch("superscript") || t.hasEmptyBranch("subscript")) d += ' the integral of <break time="200ms"/> ';
                            else {
                                let e = ti("math", t.superscript, a);
                                e = e.trim();
                                let i = ti("math", t.subscript, a);
                                i = i.trim(), d += ' the integral from <break time="200ms"/>' + l(i) + '<break time="200ms"/> to <break time="200ms"/>' + l(e) + ' <break time="200ms"/> of ', m = !0
                            }
                        else "string" == typeof t.value ? d += (null !== (s = Ya[t.value]) && void 0 !== s ? s : t.command ? Ya[t.command] : void 0) || " " + t.value : t.command && ("\\mathop" === t.command ? d += ti("math", t.body, a) : "\\operatorname" === t.command ? d += (c = t.body) ? c.map((e => e.value)).join("") : "" : d += t.command.startsWith("\\") ? " " + t.command.slice(1) : " " + t.command)
                    }
                    break;
                case "enclose":
                    h = ti("math", t.body, a), d += " crossed out " + h + ". End crossed out."
            }
            if (!m && !t.hasEmptyBranch("superscript")) {
                let o = ti(e, t.superscript, a);
                o = o.trim();
                const r = o.replace(/<[^>]*>/g, "");
                if (Qa(t.superscript)) {
                    if ("math" === e) {
                        const e = function(e) {
                            if (i(e))
                                for (const t of e)
                                    if ("first" !== t.type && t.id) return t.id.toString();
                            return ""
                        }(t.superscript);
                        e && (d += '<mark name="' + e + '"/>')
                    }
                    "′" === r ? d += " prime " : "2" === r ? d += " squared " : "3" === r ? d += " cubed " : Number.isNaN(Number.parseInt(r)) ? d += " to the " + o + "; " : d += ' to the <say-as interpret-as="ordinal">' + r + "</say-as> power; "
                } else Number.isNaN(Number.parseInt(r)) ? d += " raised to the " + o + "; " : d += ' raised to the <say-as interpret-as="ordinal">' + r + "</say-as> power; "
            }
            if (!m && !t.hasEmptyBranch("subscript")) {
                let e = ti("math", t.subscript, a);
                e = e.trim(), d += Qa(t.subscript) ? " sub " + e : " subscript " + e + ". End subscript. "
            }
        }
        var c, u;
        return d
    }

    function ai(e, t) {
        var a;
        const i = {
            ...t,
            textToSpeechRulesOptions: {
                ...t.textToSpeechRulesOptions
            }
        };
        if ("sre" === i.textToSpeechRules && "sre" in globalThis) {
            const t = Ua(e, i);
            return t ? (i.textToSpeechMarkup && (i.textToSpeechRulesOptions = null !== (a = i.textToSpeechRulesOptions) && void 0 !== a ? a : {}, i.textToSpeechRulesOptions.markup = i.textToSpeechMarkup, "ssml" === i.textToSpeechRulesOptions.markup && (i.textToSpeechRulesOptions.markup = "ssml_step"), i.textToSpeechRulesOptions.rate = i.speechEngineRate), i.textToSpeechRulesOptions && globalThis.sre.System.getInstance().setupEngine(i.textToSpeechRulesOptions), globalThis.sre.System.getInstance().toSpeech(t)) : ""
        }
        let o = ti("math", e, i);
        if ("ssml" === i.textToSpeechMarkup) {
            let e = "";
            i.speechEngineRate && (e = '<prosody rate="' + i.speechEngineRate + '">'), o = '<?xml version="1.0"?><speak version="1.1" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US"><amazon:auto-breaths>' + e + "<p><s>" + o + "</s></p>" + (e ? "</prosody>" : "") + "</amazon:auto-breaths></speak>"
        } else o = "mac" === i.textToSpeechMarkup && "macos" === l() ? o.replace(/<mark([^/]*)\/>/g, "").replace(/<emphasis>/g, "[[emph+]]").replace(/<\/emphasis>/g, "").replace(/<break time="(\d*)ms"\/>/g, "[[slc $1]]").replace(/<say-as[^>]*>/g, "").replace(/<\/say-as>/g, "") : o.replace(/<[^>]*>/g, "").replace(/\s{2,}/g, " ");
        return o
    }

    function ii(e, t, a, i) {
        const o = t.split(" ");
        for (const t of o) {
            const o = t.match(/(.*):(.*)/);
            if (o) {
                const t = null != i ? i : {};
                "active" === o[2] ? t.passive = !1 : t[o[2]] = !0, e.addEventListener(o[1], a, t)
            } else e.addEventListener(t, a, i)
        }
    }

    function oi(e, t, a, i) {
        const o = t.split(" ");
        for (const t of o) {
            const o = t.match(/(.*):(.*)/);
            if (o) {
                const t = null != i ? i : {};
                "active" === o[2] ? t.passive = !1 : t[o[2]] = !0, e.removeEventListener(o[1], a, t)
            } else e.removeEventListener(t, a, i)
        }
    }

    function ri(e) {
        var t;
        r();
        let a = document.getElementById(e);
        return a ? a.dataset.refcount = Number(Number.parseInt(null !== (t = a.getAttribute("data-refcount")) && void 0 !== t ? t : "0") + 1).toString() : (a = document.createElement("div"), a.setAttribute("aria-hidden", "true"), a.dataset.refcount = "1", a.id = e, document.body.append(a)), a
    }

    function ni(e) {
        var t;
        if (!e) return;
        const a = Number.parseInt(null !== (t = e.getAttribute("data-refcount")) && void 0 !== t ? t : "0");
        a <= 1 ? e.remove() : e.dataset.refcount = Number(a - 1).toString()
    }

    function si(e) {
        var t;
        return (null === (t = e.element) || void 0 === t ? void 0 : t.mathfield) === e
    }

    function li(e) {
        const t = function(e) {
            var t, a;
            return null !== (a = null !== (t = e.querySelector(".ML__caret")) && void 0 !== t ? t : e.querySelector(".ML__text-caret")) && void 0 !== a ? a : e.querySelector(".ML__latex-caret")
        }(e);
        if (!t) return null;
        const a = t.getBoundingClientRect();
        return {
            x: a.right,
            y: a.bottom,
            height: a.height
        }
    }

    function di(e) {
        var t;
        if (!e.parent) return "root";
        let a = null !== (t = e.parent.id) && void 0 !== t ? t : "";
        return a += "string" == typeof e.treeBranch ? "-" + e.treeBranch : `-${e.treeBranch[0]}/${e.treeBranch[0]}`, a
    }

    function ci(e, t) {
        if (!t) return null;
        const a = e.field.getBoundingClientRect(),
            i = t.right - t.left,
            o = t.bottom - t.top,
            r = Math.ceil(t.left - a.left + e.field.scrollLeft),
            n = Math.ceil(t.top - a.top);
        return {
            left: r,
            right: r + i,
            top: n,
            bottom: n + o
        }
    }

    function ui(e) {
        const t = e.getBoundingClientRect(),
            a = parseInt(getComputedStyle(e).marginRight),
            i = {
                top: t.top - 1,
                bottom: t.bottom,
                left: t.left,
                right: t.right - 1 + a
            };
        if (0 === e.children.length || "SVG" === e.tagName.toUpperCase()) return i;
        for (const t of e.children)
            if (1 === t.nodeType && "atomId" in t.dataset && !t.classList.contains("pstrut")) {
                const e = ui(t);
                i.left = Math.min(i.left, e.left), i.right = Math.max(i.right, e.right), i.top = Math.min(i.top, e.top), i.bottom = Math.max(i.bottom, e.bottom)
            } return i
    }

    function pi(e, t) {
        var a, i;
        if (!t.id) return null;
        let o = null !== (i = null === (a = e.atomBoundsCache) || void 0 === a ? void 0 : a.get(t.id)) && void 0 !== i ? i : null;
        if (null !== o) return o;
        const r = e.field.querySelector(`[data-atom-id="${t.id}"]`);
        return o = r ? ui(r) : null, e.atomBoundsCache && (o ? e.atomBoundsCache.set(t.id, o) : e.atomBoundsCache.delete(t.id)), null != o ? o : null
    }

    function hi(e, t) {
        return e.model.selection.ranges.reduce(((a, i) => a.concat(... function(e, t, a) {
            const i = new Map;
            for (const o of e.model.getAtoms(t, {
                    includeChildren: !0
                })) {
                if ((null == a ? void 0 : a.excludeAtomsWithBackground) && o.style.backgroundColor) break;
                const t = ci(e, pi(e, o));
                if (t) {
                    const e = di(o);
                    if (i.has(e)) {
                        const a = i.get(e);
                        i.set(e, {
                            left: Math.min(a.left, t.left),
                            right: Math.max(a.right, t.right),
                            top: Math.min(a.top, t.top),
                            bottom: Math.max(a.bottom, t.bottom)
                        })
                    } else i.set(e, t)
                }
            }
            return [...i.values()]
        }(e, i, t))), [])
    }

    function mi(e, t) {
        return "*" === e || "none" === t || ("same-origin" === t ? !globalThis.origin || e === globalThis.origin : "function" == typeof t && t(e))
    }

    function fi(e) {
        let t = 0,
            a = 0;
        const i = e.offsetWidth,
            o = e.offsetHeight;
        for (; e instanceof HTMLElement;) t += e.offsetTop, a += e.offsetLeft, e = e.offsetParent;
        return new DOMRect(a, t, i, o)
    }
    const yi = {
            main: ["Main-Regular", "ML__cmr"],
            "main-italic": ["Main-Italic", "ML__cmr ML__it"],
            "main-bold": ["Main-Bold", "ML__cmr ML__bold"],
            "main-bolditalic": ["Main-BoldItalic", "ML__cmr ML__bold ML__it"],
            normal: ["Main-Regular", "ML__cmr"],
            "normal-bold": ["Main-Bold", "ML__mathbf"],
            "normal-italic": ["Math-Italic", "ML__mathit"],
            "normal-bolditalic": ["Math-BoldItalic", "ML__mathbfit"],
            ams: ["AMS-Regular", "ML__ams"],
            "ams-bold": ["AMS-Regular", "ML__ams"],
            "ams-italic": ["AMS-Regular", "ML__ams"],
            "ams-bolditalic": ["AMS-Regular", "ML__ams"],
            "sans-serif": ["SansSerif-Regular", "ML__sans"],
            "sans-serif-bold": ["SansSerif-Regular", "ML__sans ML__bold"],
            "sans-serif-italic": ["SansSerif-Regular", "ML__sans"],
            "sans-serif-bolditalic": ["SansSerif-Regular", "ML__sans"],
            calligraphic: ["Caligraphic-Regular", "ML__cal"],
            "calligraphic-bold": ["Caligraphic-Regular", "ML__cal ML__bold"],
            "calligraphic-italic": ["Caligraphic-Regular", "ML__cal ML__it"],
            "calligraphic-bolditalic": ["Caligraphic-Regular", "ML__cal ML__bold ML__it"],
            script: ["Script-Regular", "ML__script"],
            "script-bold": ["Script-Regular", "ML__script ML__bold"],
            "script-italic": ["Script-Regular", "ML__script ML__it"],
            "script-bolditalic": ["Script-Regular", "ML__script ML__bold ML__it"],
            fraktur: ["Fraktur-Regular", "ML__frak"],
            "fraktur-bold": ["Fraktur-Regular", "ML__frak"],
            "fraktur-italic": ["Fraktur-Regular", "ML__frak"],
            "fraktur-bolditalic": ["Fraktur-Regular", "ML__frak"],
            monospace: ["Typewriter-Regular", "ML__tt"],
            "monospace-bold": ["Typewriter-Regular", "ML__tt ML__bold"],
            "monospace-italic": ["Typewriter-Regular", "ML__tt ML__it"],
            "monospace-bolditalic": ["Typewriter-Regular", "ML__tt ML__bold ML__it"],
            "double-struck": ["AMS-Regular", "ML__bb"],
            "double-struck-bold": ["AMS-Regular", "ML__bb"],
            "double-struck-italic": ["AMS-Regular", "ML__bb"],
            "double-struck-bolditalic": ["AMS-Regular", "ML__bb"]
        },
        bi = {
            "double-struck": /^[A-Z ]$/,
            script: /^[A-Z ]$/,
            calligraphic: /^[\dA-Z ]$/,
            fraktur: /^[\dA-Za-z ]$|^[!"#$%&'()*+,\-./:;=?[]^\u2019\u2018]$/,
            monospace: /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/,
            "sans-serif": /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/
        },
        gi = /^[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5]$/,
        vi = [/^[a-z]$/, /^[A-Z]$/, gi, /^[\u0393|\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A6\u03A8\u03A9]$/],
        ki = {
            iso: ["it", "it", "it", "it"],
            tex: ["it", "it", "it", "up"],
            french: ["it", "up", "up", "up"],
            upright: ["up", "up", "up", "up"]
        };

    function xi(e) {
        if (!e) return "";
        const {
            style: t
        } = e;
        if (void 0 === t.variant) return "";
        let a = t.variant;
        return t.variantStyle && "up" !== t.variantStyle && (a += "-" + t.variantStyle), a
    }

    function wi(e) {
        return [at(e.map((e => e[0]))), e.map((e => e[1])).some((e => !0 === e))]
    }
    new class extends Be {
        createAtom(e, t, a) {
            var i, o, r, n, s;
            const l = t.getDefinition(e, "math");
            if (null === l) return new lt("mord", t, {
                mode: "math",
                command: e,
                value: e,
                style: a
            });
            if ("symbol" === l.definitionType) {
                const n = new lt(null !== (i = l.type) && void 0 !== i ? i : "mord", t, {
                    mode: "math",
                    command: null !== (o = l.command) && void 0 !== o ? o : e,
                    value: String.fromCodePoint(l.codepoint),
                    style: a
                });
                return null !== (r = l.isFunction) && void 0 !== r && r && (n.isFunction = !0), e.startsWith("\\") && (n.verbatimLatex = e), n
            }
            const d = new lt("mord", t, {
                mode: "math",
                command: null !== (n = l.command) && void 0 !== n ? n : e,
                value: e,
                style: a
            });
            return null !== (s = l.isFunction) && void 0 !== s && s && (d.isFunction = !0), e.startsWith("\\") && (d.verbatimLatex = e), d
        }
        serialize(e, t) {
            const {
                parent: a
            } = e[0], i = null == a ? void 0 : a.computedStyle.fontSize;
            return at(Ke(e, "fontSize").map((e => {
                const o = function(e, t) {
                        const {
                            parent: a
                        } = e[0], i = null == a ? void 0 : a.computedStyle.backgroundColor;
                        return at(Ke(e, "backgroundColor").map((e => {
                            var o, r;
                            let n = function(e, t) {
                                const {
                                    parent: a
                                } = e[0], i = null == a ? void 0 : a.computedStyle.color;
                                return at(Ke(e, "color").map((e => {
                                    var o, r;
                                    const n = function(e, t) {
                                            var a;
                                            const {
                                                parent: i
                                            } = e[0], o = xi(i), r = null !== (a = null == i ? void 0 : i.mode) && void 0 !== a ? a : "math";
                                            return at(Ke(e, "variant").map((e => {
                                                const a = xi(e[0]);
                                                if (e.every((e => {
                                                        const t = e.context.getDefinition(e.command, r);
                                                        return !(!t || "function" === t.definitionType || !t.variant) && xi(e) === a
                                                    }))) return at(e.map((e => lt.serialize(e, t))));
                                                let i = "";
                                                return a && a !== o && (i = {
                                                    calligraphic: "\\mathcal{",
                                                    fraktur: "\\mathfrak{",
                                                    "double-struck": "\\mathbb{",
                                                    script: "\\mathscr{",
                                                    monospace: "\\mathtt{",
                                                    "sans-serif": "\\mathsf{",
                                                    normal: "\\mathrm{",
                                                    "normal-italic": "\\mathnormal{",
                                                    "normal-bold": "\\mathbf{",
                                                    "normal-bolditalic": "\\mathbfit{",
                                                    ams: "",
                                                    "ams-italic": "\\mathit{",
                                                    "ams-bold": "\\mathbf{",
                                                    "ams-bolditalic": "\\mathbfit{",
                                                    main: "",
                                                    "main-italic": "\\mathit{",
                                                    "main-bold": "\\mathbf{",
                                                    "main-bolditalic": "\\mathbfit{"
                                                } [a]), i ? i + at(e.map((e => lt.serialize(e, t)))) + "}" : at(e.map((e => lt.serialize(e, t))))
                                            })))
                                        }(e, t),
                                        s = e[0].computedStyle;
                                    return null !== (o = t.skipStyles) && void 0 !== o && o || !s.color || a && i === s.color ? n : "\\textcolor{" + (null !== (r = s.verbatimColor) && void 0 !== r ? r : s.color) + "}{" + n + "}"
                                })))
                            }(e, t);
                            const s = e[0].computedStyle;
                            return null !== (o = t.skipStyles) && void 0 !== o && o || !n.trim() || !s.backgroundColor || a && i === s.backgroundColor || !(e.length > 0) && e[0] instanceof It || (n = `\\ensuremath{${n}}`, n = `\\colorbox{${null!==(r=s.verbatimBackgroundColor)&&void 0!==r?r:s.backgroundColor}}{${n}}`), n
                        })))
                    }(e, t),
                    r = e[0].computedStyle.fontSize;
                return !r || a && i === r ? o : "\\" + ["", "tiny", "scriptsize", "footnotesize", "small", "normalsize", "large", "Large", "LARGE", "huge", "Huge"][r] + " " + o
            })))
        }
        applyStyle(e, t) {
            if (void 0 === t.variant) return "";
            const a = "auto" !== t.letterShapeStyle && t.letterShapeStyle ? t.letterShapeStyle : "tex";
            let {
                variant: i
            } = t, {
                variantStyle: o
            } = t;
            "normal" === i && !o && /[\u00A3\u0131\u0237]/.test(e.value) && (i = "main", o = "italic"), "normal" !== i || o || 1 !== e.value.length || vi.forEach(((t, i) => {
                t.test(e.value) && "it" === ki[a][i] && (o = "italic")
            })), "up" === o && (o = void 0);
            const r = o ? i + "-" + o : i,
                [n, s] = yi[r];
            return bi[i] && !bi[i].test(e.value) ? (e.value = function(e, t, a) {
                if (!/[A-Za-z\d]/.test(e)) return e;
                if (!t && !a) return e;
                const i = e.codePointAt(0);
                if (void 0 === i) return e;
                for (const e of O)
                    if ((!t || e.variant === t) && (!a || e.style === a) && i >= e.offset && i < e.offset + e.len) {
                        const t = e.start + i - e.offset;
                        return String.fromCodePoint(E[t] || t)
                    } return e
            }(e.value, i, o), null) : (gi.test(e.value) && (e.classes += " lcGreek"), s && (e.classes += " " + s), n)
        }
        constructor() {
            super("math")
        }
    };
    const _i = {
        roman: "",
        "sans-serif": "ML__sans",
        monospace: "ML__tt"
    };

    function Si(e) {
        let t = 0;
        for (let a = 0; a < e.length; a++) t = Math.imul(31, t) + e.charCodeAt(a) | 0;
        return Math.abs(t)
    }

    function Mi(e, t, a) {
        var i, o;
        if (r(), !t) return null;
        let n = null !== (i = null == e ? void 0 : e.getRootNode()) && void 0 !== i ? i : null === document || void 0 === document ? void 0 : document.head;
        if (!n) return null;
        n === document && (n = document.head);
        const s = n.querySelector(`style[data-id="${a}"]`);
        if (s) {
            const e = Number.parseFloat(null !== (o = s.getAttribute("data-refcount")) && void 0 !== o ? o : "0");
            s.dataset.refcount = Number(e + 1).toString()
        } else {
            const e = document.createElement("style");
            e.dataset.id = a, e.dataset.refcount = "1", e.append(document.createTextNode(t)), n.appendChild(e)
        }
        return {
            release: () => {
                var e;
                const t = document.head.querySelector(`style[data-id="${a}"]`);
                if (t) {
                    const a = Number.parseFloat(null !== (e = t.getAttribute("data-refcount")) && void 0 !== e ? e : "0");
                    1 === a ? t.remove() : t.dataset.refcount = Number(a - 1).toString()
                }
            }
        }
    }

    function Li(e) {
        const t = e.split("+"),
            a = {
                shift: !1,
                alt: !1,
                cmd: !1,
                win: !1,
                meta: !1,
                ctrl: !1,
                key: t.pop()
            };
        return t.includes("shift") && (a.shift = !0), t.includes("alt") && (a.alt = !0), t.includes("ctrl") && (a.ctrl = !0), t.includes("cmd") && (a.cmd = !0), t.includes("win") && (a.win = !0), t.includes("meta") && (a.meta = !0), a
    }

    function Ci(e) {
        let t = "";
        return e.shift && (t += "shift+"), e.alt && (t += "alt+"), e.ctrl && (t += "ctrl+"), e.cmd && (t += "cmd+"), e.win && (t += "win+"), e.meta && (t += "meta+"), t + e.key
    }
    new class extends Be {
        createAtom(e, t, a) {
            const i = t.getDefinition(e, "text");
            return i && "symbol" === i.definitionType ? new $t(e, String.fromCodePoint(i.codepoint), null != a ? a : {}, t) : null
        }
        serialize(e, t) {
            var a;
            let [i, o] = function(e, t) {
                return wi(Ke(e, "backgroundColor").map((e => {
                    var a, i;
                    const [o, r] = function(e, t) {
                        var a;
                        if (!e || 0 === e.length) return ["", !1];
                        const i = null === (a = e[0].parent) || void 0 === a ? void 0 : a.style.color;
                        return wi(Ke(e, "color").map((e => {
                            var a, o;
                            const [r, n] = function(e, t) {
                                return function(e, t) {
                                    return wi(Ke(e, "fontFamily").map((e => {
                                        var a, i;
                                        const [o, r] = function(e, t) {
                                            return wi(Ke(e, "fontSize").map((e => {
                                                var a, i;
                                                const [o, r] = function(e, t) {
                                                    return wi(Ke(e, "fontSeries").map((e => {
                                                        const [a, i] = function(e, t) {
                                                            return wi(Ke(e, "fontShape").map((e => {
                                                                const [a, i] = function(e, t) {
                                                                    return [at(e.map((e => lt.serialize(e, t)))), !0]
                                                                }(e, t), {
                                                                    fontShape: o
                                                                } = e[0].style;
                                                                return "it" === o ? ["\\textit{" + a + "}", !1] : "sl" === o ? ["\\textsl{" + a + "}", !1] : "sc" === o ? ["\\textsc{" + a + "}", !1] : "n" === o ? ["\\textup{" + a + "}", !1] : o ? [`{\\fontshape{${e[0].style.fontShape}}${a}`, !1] : [a, i]
                                                            })))
                                                        }(e, t), {
                                                            fontSeries: o
                                                        } = e[0].style;
                                                        return "b" === o ? [`\\textbf{${a}}`, !1] : "l" === o ? [`\\textlf{${a}}`, !1] : "m" === o ? [`\\textmd{${a}}`, !1] : o ? [`\\fontseries{${o}}${a}`, !1] : [a, i]
                                                    })))
                                                }(e, t), n = null !== (i = ["", "tiny", "scriptsize", "footnotesize", "small", "normalsize", "large", "Large", "LARGE", "huge", "Huge"][null !== (a = e[0].style.fontSize) && void 0 !== a ? a : ""]) && void 0 !== i ? i : "";
                                                return n ? [`{\\${n} ${o}}`, r] : [o, r]
                                            })))
                                        }(e, t), n = null !== (i = {
                                            roman: "textrm",
                                            monospace: "texttt",
                                            "sans-serif": "textsf"
                                        } [null !== (a = e[0].style.fontFamily) && void 0 !== a ? a : ""]) && void 0 !== i ? i : "";
                                        return n ? [`\\${n}{${o}}`, !1] : e[0].style.fontFamily ? [`\\fontfamily{${e[0].style.fontFamily}}${o}`, r] : [o, r]
                                    })))
                                }(e, t)
                            }(e, t);
                            return null !== (a = t.skipStyles) && void 0 !== a && a || !e[0].style.color || "none" === e[0].style.color || i === e[0].style.color ? [r, n] : [`\\textcolor{${null!==(o=e[0].style.verbatimColor)&&void 0!==o?o:e[0].style.color}}{${r}}`, !1]
                        })))
                    }(e, t), n = e[0].computedStyle;
                    return null !== (a = t.skipStyles) && void 0 !== a && a || !n.backgroundColor || "none" === n.backgroundColor ? [o, r] : [`\\colorbox{${null!==(i=n.verbatimBackgroundColor)&&void 0!==i?i:n.backgroundColor}}{${o}}`, !1]
                })))
            }(e, t);
            return !0 === (null !== (a = t.skipModeCommand) && void 0 !== a && a) && (o = !1), o && (i = `\\text{${i}}`), i
        }
        applyStyle(e, t) {
            var a, i, o, r, n, s;
            const {
                fontFamily: l
            } = t;
            if (_i[l] ? e.classes += void 0 !== (a = " " + _i[l]) ? a : "" : l && e.setStyle("font-family", l), t.fontShape && (e.classes += " ", e.classes += null !== (i = {
                    it: "ML__it",
                    sl: "ML__shape_sl",
                    sc: "ML__shape_sc",
                    ol: "ML__shape_ol"
                } [t.fontShape]) && void 0 !== i ? i : ""), t.fontSeries) {
                const a = t.fontSeries.match(/(.?[lbm])?(.?[cx])?/);
                a && (e.classes += " ", e.classes += null !== (r = {
                    ul: "ML__series_ul",
                    el: "ML__series_el",
                    l: "ML__series_l",
                    sl: "ML__series_sl",
                    m: "",
                    sb: "ML__series_sb",
                    b: "ML__bold",
                    eb: "ML__series_eb",
                    ub: "ML__series_ub"
                } [null !== (o = a[1]) && void 0 !== o ? o : ""]) && void 0 !== r ? r : "", e.classes += " ", e.classes += null !== (s = {
                    uc: "ML__series_uc",
                    ec: "ML__series_ec",
                    c: "ML__series_c",
                    sc: "ML__series_sc",
                    n: "",
                    sx: "ML__series_sx",
                    x: "ML__series_x",
                    ex: "ML__series_ex",
                    ux: "ML__series_ux"
                } [null !== (n = a[2]) && void 0 !== n ? n : ""]) && void 0 !== s ? s : "")
            }
            return "Main-Regular"
        }
        constructor() {
            super("text")
        }
    }, new class extends Be {
        createAtom(e, t, a) {
            return new ta(e, t)
        }
        serialize(e, t) {
            return e.filter((e => e instanceof ta && !e.isSuggestion)).map((e => e.value)).join("")
        }
        applyStyle() {
            return null
        }
        constructor() {
            super("latex")
        }
    };
    const Ai = "apple" === zi() ? {
            id: "apple.en-intl",
            displayName: "English (international)",
            virtualLayout: "qwerty",
            platform: "apple",
            locale: "en",
            score: 0,
            mapping: {
                KeyA: ["a", "A", "å", "Å"],
                KeyB: ["b", "B", "∫", "ı"],
                KeyC: ["c", "C", "ç", "Ç"],
                KeyD: ["d", "D", "∂", "Î"],
                KeyE: ["e", "E", "´", "´"],
                KeyF: ["f", "F", "ƒ", "Ï"],
                KeyG: ["g", "G", "©", "˝"],
                KeyH: ["h", "H", "˙", "Ó"],
                KeyI: ["i", "I", "ˆ", "ˆ"],
                KeyJ: ["j", "J", "∆", "Ô"],
                KeyK: ["k", "K", "˚", ""],
                KeyL: ["l", "L", "¬", "Ò"],
                KeyM: ["m", "M", "µ", "Â"],
                KeyN: ["n", "N", "˜", "˜"],
                KeyO: ["o", "O", "ø", "Ø"],
                KeyP: ["p", "P", "π", "∏"],
                KeyQ: ["q", "Q", "œ", "Œ"],
                KeyR: ["r", "R", "®", "‰"],
                KeyS: ["s", "S", "ß", "Í"],
                KeyT: ["t", "T", "†", "ˇ"],
                KeyU: ["u", "U", "¨", "¨"],
                KeyV: ["v", "V", "√", "◊"],
                KeyW: ["w", "W", "∑", "„"],
                KeyX: ["x", "X", "≈", "˛"],
                KeyY: ["y", "Y", "¥", "Á"],
                KeyZ: ["z", "Z", "Ω", "¸"],
                Digit1: ["1", "!", "¡", "⁄"],
                Digit2: ["2", "@", "™", "€"],
                Digit3: ["3", "#", "£", "‹"],
                Digit4: ["4", "$", "¢", "›"],
                Digit5: ["5", "%", "∞", "ﬁ"],
                Digit6: ["6", "^", "§", "ﬂ"],
                Digit7: ["7", "&", "¶", "‡"],
                Digit8: ["8", "*", "•", "°"],
                Digit9: ["9", "(", "ª", "·"],
                Digit0: ["0", ")", "º", "‚"],
                Space: [" ", " ", " ", " "],
                Minus: ["-", "_", "–", "—"],
                Equal: ["=", "+", "≠", "±"],
                BracketLeft: ["[", "{", "“", "”"],
                BracketRight: ["]", "}", "‘", "’"],
                Backslash: ["\\", "|", "«", "»"],
                Semicolon: [";", ":", "…", "Ú"],
                Quote: ["'", '"', "æ", "Æ"],
                Backquote: ["`", "˜", "`", "`"],
                Comma: [",", "<", "≤", "¯"],
                Period: [".", ">", "≥", "˘"],
                Slash: ["/", "?", "÷", "¿"],
                NumpadDivide: ["/", "/", "/", "/"],
                NumpadMultiply: ["*", "*", "*", "*"],
                NumpadSubtract: ["-", "-", "-", "-"],
                NumpadAdd: ["+", "+", "+", "+"],
                Numpad1: ["1", "1", "1", "1"],
                Numpad2: ["2", "2", "2", "2"],
                Numpad3: ["3", "3", "3", "3"],
                Numpad4: ["4", "4", "4", "4"],
                Numpad5: ["5", "5", "5", "5"],
                Numpad6: ["6", "6", "6", "6"],
                Numpad7: ["7", "7", "7", "7"],
                Numpad8: ["8", "8", "8", "8"],
                Numpad9: ["9", "9", "9", "9"],
                Numpad0: ["0", "0", "0", "0"],
                NumpadDecimal: [".", ".", ".", "."],
                IntlBackslash: ["§", "±", "§", "±"],
                NumpadEqual: ["=", "=", "=", "="],
                AudioVolumeUp: ["", "=", "", "="]
            }
        } : "windows" === zi() ? {
            id: "windows.en-intl",
            displayName: "English (international)",
            platform: "windows",
            virtualLayout: "qwerty",
            locale: "en",
            score: 0,
            mapping: {
                KeyA: ["a", "A", "á", "Á"],
                KeyB: ["b", "B", "", ""],
                KeyC: ["c", "C", "©", "¢"],
                KeyD: ["d", "D", "ð", "Ð"],
                KeyE: ["e", "E", "é", "É"],
                KeyF: ["f", "F", "", ""],
                KeyG: ["g", "G", "", ""],
                KeyH: ["h", "H", "", ""],
                KeyI: ["i", "I", "í", "Í"],
                KeyJ: ["j", "J", "", ""],
                KeyK: ["k", "K", "", ""],
                KeyL: ["l", "L", "ø", "Ø"],
                KeyM: ["m", "M", "µ", ""],
                KeyN: ["n", "N", "ñ", "Ñ"],
                KeyO: ["o", "O", "ó", "Ó"],
                KeyP: ["p", "P", "ö", "Ö"],
                KeyQ: ["q", "Q", "ä", "Ä"],
                KeyR: ["r", "R", "®", ""],
                KeyS: ["s", "S", "ß", "§"],
                KeyT: ["t", "T", "þ", "Þ"],
                KeyU: ["u", "U", "ú", "Ú"],
                KeyV: ["v", "V", "", ""],
                KeyW: ["w", "W", "å", "Å"],
                KeyX: ["x", "X", "", ""],
                KeyY: ["y", "Y", "ü", "Ü"],
                KeyZ: ["z", "Z", "æ", "Æ"],
                Digit1: ["1", "!", "¡", "¹"],
                Digit2: ["2", "@", "²", ""],
                Digit3: ["3", "#", "³", ""],
                Digit4: ["4", "$", "¤", "£"],
                Digit5: ["5", "%", "€", ""],
                Digit6: ["6", "^", "¼", ""],
                Digit7: ["7", "&", "½", ""],
                Digit8: ["8", "*", "¾", ""],
                Digit9: ["9", "(", "‘", ""],
                Digit0: ["0", ")", "’", ""],
                Space: [" ", " ", "", ""],
                Minus: ["-", "_", "¥", ""],
                Equal: ["=", "+", "×", "÷"],
                BracketLeft: ["[", "{", "«", ""],
                BracketRight: ["]", "}", "»", ""],
                Backslash: ["\\", "|", "¬", "¦"],
                Semicolon: [";", ":", "¶", "°"],
                Quote: ["'", '"', "´", "¨"],
                Backquote: ["`", "~", "", ""],
                Comma: [",", "<", "ç", "Ç"],
                Period: [".", ">", "", ""],
                Slash: ["/", "?", "¿", ""],
                NumpadDivide: ["/", "/", "", ""],
                NumpadMultiply: ["*", "*", "", ""],
                NumpadSubtract: ["-", "-", "", ""],
                NumpadAdd: ["+", "+", "", ""],
                IntlBackslash: ["\\", "|", "", ""]
            }
        } : {
            id: "linux.en",
            displayName: "English",
            platform: "linux",
            virtualLayout: "qwerty",
            locale: "en",
            score: 0,
            mapping: {
                KeyA: ["a", "A", "a", "A"],
                KeyB: ["b", "B", "b", "B"],
                KeyC: ["c", "C", "c", "C"],
                KeyD: ["d", "D", "d", "D"],
                KeyE: ["e", "E", "e", "E"],
                KeyF: ["f", "F", "f", "F"],
                KeyG: ["g", "G", "g", "G"],
                KeyH: ["h", "H", "h", "H"],
                KeyI: ["i", "I", "i", "I"],
                KeyJ: ["j", "J", "j", "J"],
                KeyK: ["k", "K", "k", "K"],
                KeyL: ["l", "L", "l", "L"],
                KeyM: ["m", "M", "m", "M"],
                KeyN: ["n", "N", "n", "N"],
                KeyO: ["o", "O", "o", "O"],
                KeyP: ["p", "P", "p", "P"],
                KeyQ: ["q", "Q", "q", "Q"],
                KeyR: ["r", "R", "r", "R"],
                KeyS: ["s", "S", "s", "S"],
                KeyT: ["t", "T", "t", "T"],
                KeyU: ["u", "U", "u", "U"],
                KeyV: ["v", "V", "v", "V"],
                KeyW: ["w", "W", "w", "W"],
                KeyX: ["x", "X", "x", "X"],
                KeyY: ["y", "Y", "y", "Y"],
                KeyZ: ["z", "Z", "z", "Z"],
                Digit1: ["1", "!", "1", "!"],
                Digit2: ["2", "@", "2", "@"],
                Digit3: ["3", "#", "3", "#"],
                Digit4: ["4", "$", "4", "$"],
                Digit5: ["5", "%", "5", "%"],
                Digit6: ["6", "^", "6", "^"],
                Digit7: ["7", "&", "7", "&"],
                Digit8: ["8", "*", "8", "*"],
                Digit9: ["9", "(", "9", "("],
                Digit0: ["0", ")", "0", ")"],
                Space: [" ", " ", " ", " "],
                Minus: ["-", "_", "-", "_"],
                Equal: ["=", "+", "=", "+"],
                BracketLeft: ["[", "{", "[", "{"],
                BracketRight: ["]", "}", "]", "}"],
                Backslash: ["\\", "|", "\\", "|"],
                Semicolon: [";", ":", ";", ":"],
                Quote: ["'", '"', "'", '"'],
                Backquote: ["`", "~", "`", "~"],
                Comma: [",", "<", ",", "<"],
                Period: [".", ">", ".", ">"],
                Slash: ["/", "?", "/", "?"],
                NumpadDivide: ["/", "/", "/", "/"],
                NumpadMultiply: ["*", "*", "*", "*"],
                NumpadSubtract: ["-", "-", "-", "-"],
                NumpadAdd: ["+", "+", "+", "+"],
                Numpad1: ["1", "1", "1", "1"],
                Numpad2: ["2", "2", "2", "2"],
                Numpad3: ["3", "3", "3", "3"],
                Numpad4: ["4", "4", "4", "4"],
                Numpad5: ["5", "5", "5", "5"],
                Numpad6: ["6", "6", "6", "6"],
                Numpad7: ["7", "7", "7", "7"],
                Numpad8: ["8", "8", "8", "8"],
                Numpad9: ["9", "9", "9", "9"],
                Numpad0: ["0", "0", "0", "0"],
                NumpadDecimal: ["", ".", "", "."],
                IntlBackslash: ["<", ">", "|", "¦"],
                NumpadEqual: ["=", "=", "=", "="],
                NumpadComma: [".", ".", ".", "."],
                NumpadParenLeft: ["(", "(", "(", "("],
                NumpadParenRight: [")", ")", ")", ")"]
            }
        },
        Di = {
            enter: "[Enter]",
            escape: "[Escape]",
            backspace: "[Backspace]",
            tab: "[Tab]",
            space: "[Space]",
            pausebreak: "[Pause]",
            insert: "[Insert]",
            home: "[Home]",
            pageup: "[PageUp]",
            delete: "[Delete]",
            end: "[End]",
            pagedown: "[PageDown]",
            right: "[ArrowRight]",
            left: "[ArrowLeft]",
            down: "[ArrowDown]",
            up: "[ArrowUp]",
            numpad0: "[Numpad0]",
            numpad1: "[Numpad1]",
            numpad2: "[Numpad2]",
            numpad3: "[Numpad3]",
            numpad4: "[Numpad4]",
            numpad5: "[Numpad5]",
            numpad6: "[Numpad6]",
            numpad7: "[Numpad7]",
            numpad8: "[Numpad8]",
            numpad9: "[Numpad9]",
            numpad_divide: "[NumpadDivide]",
            numpad_multiply: "[NumpadMultiply]",
            numpad_subtract: "[NumpadSubtract]",
            numpad_add: "[NumpadAdd]",
            numpad_decimal: "[NumpadDecimal]",
            numpad_separator: "[NumpadComma]",
            capslock: "[Capslock]",
            f1: "[F1]",
            f2: "[F2]",
            f3: "[F3]",
            f4: "[F4]",
            f5: "[F5]",
            f6: "[F6]",
            f7: "[F7]",
            f8: "[F8]",
            f9: "[F9]",
            f10: "[F10]",
            f11: "[F11]",
            f12: "[F12]",
            f13: "[F13]",
            f14: "[F14]",
            f15: "[F15]",
            f16: "[F16]",
            f17: "[F17]",
            f18: "[F18]",
            f19: "[F19]"
        },
        Ti = [];

    function zi() {
        switch (l()) {
            case "macos":
            case "ios":
                return "apple";
            case "windows":
                return "windows"
        }
        return "linux"
    }

    function Bi(e) {
        e.platform && e.platform !== zi() || Ti.push(e)
    }

    function Ki() {
        return Ti[0]
    }
    Bi(Ai), Bi({
        id: "apple.french",
        locale: "fr",
        displayName: "French",
        platform: "apple",
        virtualLayout: "azerty",
        score: 0,
        mapping: {
            KeyA: ["q", "Q", "‡", "Ω"],
            KeyB: ["b", "B", "ß", "∫"],
            KeyC: ["c", "C", "©", "¢"],
            KeyD: ["d", "D", "∂", "∆"],
            KeyE: ["e", "E", "ê", "Ê"],
            KeyF: ["f", "F", "ƒ", "·"],
            KeyG: ["g", "G", "ﬁ", "ﬂ"],
            KeyH: ["h", "H", "Ì", "Î"],
            KeyI: ["i", "I", "î", "ï"],
            KeyJ: ["j", "J", "Ï", "Í"],
            KeyK: ["k", "K", "È", "Ë"],
            KeyL: ["l", "L", "¬", "|"],
            KeyM: [",", "?", "∞", "¿"],
            KeyN: ["n", "N", "~", "ı"],
            KeyO: ["o", "O", "œ", "Œ"],
            KeyP: ["p", "P", "π", "∏"],
            KeyQ: ["a", "A", "æ", "Æ"],
            KeyR: ["r", "R", "®", "‚"],
            KeyS: ["s", "S", "Ò", "∑"],
            KeyT: ["t", "T", "†", "™"],
            KeyU: ["u", "U", "º", "ª"],
            KeyV: ["v", "V", "◊", "√"],
            KeyW: ["z", "Z", "Â", "Å"],
            KeyX: ["x", "X", "≈", "⁄"],
            KeyY: ["y", "Y", "Ú", "Ÿ"],
            KeyZ: ["w", "W", "‹", "›"],
            Digit1: ["&", "1", "", "´"],
            Digit2: ["é", "2", "ë", "„"],
            Digit3: ['"', "3", "“", "”"],
            Digit4: ["'", "4", "‘", "’"],
            Digit5: ["(", "5", "{", "["],
            Digit6: ["§", "6", "¶", "å"],
            Digit7: ["è", "7", "«", "»"],
            Digit8: ["!", "8", "¡", "Û"],
            Digit9: ["ç", "9", "Ç", "Á"],
            Digit0: ["à", "0", "ø", "Ø"],
            Space: [" ", " ", " ", " "],
            Minus: [")", "°", "}", "]"],
            Equal: ["-", "_", "—", "–"],
            BracketLeft: ["^", "¨", "ô", "Ô"],
            BracketRight: ["$", "*", "€", "¥"],
            Backslash: ["`", "£", "@", "#"],
            Semicolon: ["m", "M", "µ", "Ó"],
            Quote: ["ù", "%", "Ù", "‰"],
            Backquote: ["<", ">", "≤", "≥"],
            Comma: [";", ".", "…", "•"],
            Period: [":", "/", "÷", "\\"],
            Slash: ["=", "+", "≠", "±"],
            NumpadDivide: ["/", "/", "/", "/"],
            NumpadMultiply: ["*", "*", "*", "*"],
            NumpadSubtract: ["-", "-", "-", "-"],
            NumpadAdd: ["+", "+", "+", "+"],
            NumpadDecimal: [",", ".", ",", "."],
            IntlBackslash: ["@", "#", "•", "Ÿ"],
            NumpadEqual: ["=", "=", "=", "="]
        }
    }), Bi({
        id: "apple.spanish",
        locale: "es",
        displayName: "Spanish ISO",
        platform: "apple",
        virtualLayout: "qwerty",
        score: 0,
        mapping: {
            KeyA: ["a", "A", "å", "Å"],
            KeyB: ["b", "B", "ß", ""],
            KeyC: ["c", "C", "©", " "],
            KeyD: ["d", "D", "∂", "∆"],
            KeyE: ["e", "E", "€", "€"],
            KeyF: ["f", "F", "ƒ", "ﬁ"],
            KeyG: ["g", "G", "", "ﬂ"],
            KeyH: ["h", "H", "™", " "],
            KeyI: ["i", "I", " ", " "],
            KeyJ: ["j", "J", "¶", "¯"],
            KeyK: ["k", "K", "§", "ˇ"],
            KeyL: ["l", "L", " ", "˘"],
            KeyM: ["m", "M", "µ", "˚"],
            KeyN: ["n", "N", " ", "˙"],
            KeyO: ["o", "O", "ø", "Ø"],
            KeyP: ["p", "P", "π", "∏"],
            KeyQ: ["q", "Q", "œ", "Œ"],
            KeyR: ["r", "R", "®", " "],
            KeyS: ["s", "S", "∫", " "],
            KeyT: ["t", "T", "†", "‡"],
            KeyU: ["u", "U", " ", " "],
            KeyV: ["v", "V", "√", "◊"],
            KeyW: ["w", "W", "æ", "Æ"],
            KeyX: ["x", "X", "∑", "›"],
            KeyY: ["y", "Y", "¥", " "],
            KeyZ: ["z", "Z", "Ω", "‹"],
            Digit1: ["1", "!", "|", "ı"],
            Digit2: ["2", '"', "@", "˝"],
            Digit3: ["3", "·", "#", "•"],
            Digit4: ["4", "$", "¢", "£"],
            Digit5: ["5", "%", "∞", "‰"],
            Digit6: ["6", "&", "¬", " "],
            Digit7: ["7", "/", "÷", "⁄"],
            Digit8: ["8", "(", "“", "‘"],
            Digit9: ["9", ")", "”", "’"],
            Digit0: ["0", "=", "≠", "≈"],
            Space: [" ", " ", " ", " "],
            Minus: ["'", "?", "´", "¸"],
            Equal: ["¡", "¿", "‚", "˛"],
            BracketLeft: ["`", "^", "[", "ˆ"],
            BracketRight: ["+", "*", "]", "±"],
            Backslash: ["ç", "Ç", "}", "»"],
            Semicolon: ["ñ", "Ñ", "~", "˜"],
            Quote: ["´", "¨", "{", "«"],
            Backquote: ["<", ">", "≤", "≥"],
            Comma: [",", ";", "„", ""],
            Period: [".", ":", "…", "…"],
            Slash: ["-", "_", "–", "—"],
            NumpadDivide: ["/", "/", "/", "/"],
            NumpadMultiply: ["*", "*", "*", "*"],
            NumpadSubtract: ["-", "-", "-", "-"],
            NumpadAdd: ["+", "+", "+", "+"],
            Numpad1: ["1", "1", "1", "1"],
            Numpad2: ["2", "2", "2", "2"],
            Numpad3: ["3", "3", "3", "3"],
            Numpad4: ["4", "4", "4", "4"],
            Numpad5: ["5", "5", "5", "5"],
            Numpad6: ["6", "6", "6", "6"],
            Numpad7: ["7", "7", "7", "7"],
            Numpad8: ["8", "8", "8", "8"],
            Numpad9: ["9", "9", "9", "9"],
            Numpad0: ["0", "0", "0", "0"],
            NumpadDecimal: [",", ",", ",", ","],
            IntlBackslash: ["º", "ª", "\\", "°"]
        }
    }), Bi({
        id: "windows.spanish",
        locale: "es",
        displayName: "Spanish",
        platform: "windows",
        virtualLayout: "qwerty",
        score: 0,
        mapping: {
            KeyA: ["a", "A", "", ""],
            KeyB: ["b", "B", "", ""],
            KeyC: ["c", "C", "", ""],
            KeyD: ["d", "D", "", ""],
            KeyE: ["e", "E", "€", ""],
            KeyF: ["f", "F", "", ""],
            KeyG: ["g", "G", "", ""],
            KeyH: ["h", "H", "", ""],
            KeyI: ["i", "I", "", ""],
            KeyJ: ["j", "J", "", ""],
            KeyK: ["k", "K", "", ""],
            KeyL: ["l", "L", "", ""],
            KeyM: ["m", "M", "", ""],
            KeyN: ["n", "N", "", ""],
            KeyO: ["o", "O", "", ""],
            KeyP: ["p", "P", "", ""],
            KeyQ: ["q", "Q", "", ""],
            KeyR: ["r", "R", "", ""],
            KeyS: ["s", "S", "", ""],
            KeyT: ["t", "T", "", ""],
            KeyU: ["u", "U", "", ""],
            KeyV: ["v", "V", "", ""],
            KeyW: ["w", "W", "", ""],
            KeyX: ["x", "X", "", ""],
            KeyY: ["y", "Y", "", ""],
            KeyZ: ["z", "Z", "", ""],
            Digit1: ["1", "!", "|", ""],
            Digit2: ["2", '"', "@", ""],
            Digit3: ["3", "·", "#", ""],
            Digit4: ["4", "$", "~", ""],
            Digit5: ["5", "%", "€", ""],
            Digit6: ["6", "&", "¬", ""],
            Digit7: ["7", "/", "", ""],
            Digit8: ["8", "(", "", ""],
            Digit9: ["9", ")", "", ""],
            Digit0: ["0", "=", "", ""],
            Space: [" ", " ", "", ""],
            Minus: ["'", "?", "", ""],
            Equal: ["¡", "¿", "", ""],
            BracketLeft: ["`", "^", "[", ""],
            BracketRight: ["+", "*", "]", ""],
            Backslash: ["ç", "Ç", "}", ""],
            Semicolon: ["ñ", "Ñ", "", ""],
            Quote: ["´", "¨", "{", ""],
            Backquote: ["º", "ª", "\\", ""],
            Comma: [",", ";", "", ""],
            Period: [".", ":", "", ""],
            Slash: ["-", "_", "", ""],
            NumpadDivide: ["/", "/", "", ""],
            NumpadMultiply: ["*", "*", "", ""],
            NumpadSubtract: ["-", "-", "", ""],
            NumpadAdd: ["+", "+", "", ""],
            IntlBackslash: ["<", ">", "", ""]
        }
    }), Bi({
        id: "linux.spanish",
        locale: "es",
        displayName: "Spanish",
        platform: "linux",
        virtualLayout: "qwerty",
        score: 0,
        mapping: {
            KeyA: ["a", "A", "æ", "Æ"],
            KeyB: ["b", "B", "”", "’"],
            KeyC: ["c", "C", "¢", "©"],
            KeyD: ["d", "D", "ð", "Ð"],
            KeyE: ["e", "E", "€", "¢"],
            KeyF: ["f", "F", "đ", "ª"],
            KeyG: ["g", "G", "ŋ", "Ŋ"],
            KeyH: ["h", "H", "ħ", "Ħ"],
            KeyI: ["i", "I", "→", "ı"],
            KeyJ: ["j", "J", "̉", "̛"],
            KeyK: ["k", "K", "ĸ", "&"],
            KeyL: ["l", "L", "ł", "Ł"],
            KeyM: ["m", "M", "µ", "º"],
            KeyN: ["n", "N", "n", "N"],
            KeyO: ["o", "O", "ø", "Ø"],
            KeyP: ["p", "P", "þ", "Þ"],
            KeyQ: ["q", "Q", "@", "Ω"],
            KeyR: ["r", "R", "¶", "®"],
            KeyS: ["s", "S", "ß", "§"],
            KeyT: ["t", "T", "ŧ", "Ŧ"],
            KeyU: ["u", "U", "↓", "↑"],
            KeyV: ["v", "V", "“", "‘"],
            KeyW: ["w", "W", "ł", "Ł"],
            KeyX: ["x", "X", "»", ">"],
            KeyY: ["y", "Y", "←", "¥"],
            KeyZ: ["z", "Z", "«", "<"],
            Digit1: ["1", "!", "|", "¡"],
            Digit2: ["2", '"', "@", "⅛"],
            Digit3: ["3", "·", "#", "£"],
            Digit4: ["4", "$", "~", "$"],
            Digit5: ["5", "%", "½", "⅜"],
            Digit6: ["6", "&", "¬", "⅝"],
            Digit7: ["7", "/", "{", "⅞"],
            Digit8: ["8", "(", "[", "™"],
            Digit9: ["9", ")", "]", "±"],
            Digit0: ["0", "=", "}", "°"],
            Enter: ["\r", "\r", "\r", "\r"],
            Escape: ["", "", "", ""],
            Backspace: ["\b", "\b", "\b", "\b"],
            Tab: ["\t", "", "\t", ""],
            Space: [" ", " ", " ", " "],
            Minus: ["'", "?", "\\", "¿"],
            Equal: ["¡", "¿", "̃", "~"],
            BracketLeft: ["̀", "̂", "[", "̊"],
            BracketRight: ["+", "*", "]", "̄"],
            Backslash: ["ç", "Ç", "}", "̆"],
            Semicolon: ["ñ", "Ñ", "~", "̋"],
            Quote: ["́", "̈", "{", "{"],
            Backquote: ["º", "ª", "\\", "\\"],
            Comma: [",", ";", "─", "×"],
            Period: [".", ":", "·", "÷"],
            Slash: ["-", "_", "̣", "̇"],
            NumpadDivide: ["/", "/", "/", "/"],
            NumpadMultiply: ["*", "*", "*", "*"],
            NumpadSubtract: ["-", "-", "-", "-"],
            NumpadAdd: ["+", "+", "+", "+"],
            NumpadEnter: ["\r", "\r", "\r", "\r"],
            Numpad1: ["", "1", "", "1"],
            Numpad2: ["", "2", "", "2"],
            Numpad3: ["", "3", "", "3"],
            Numpad4: ["", "4", "", "4"],
            Numpad5: ["", "5", "", "5"],
            Numpad6: ["", "6", "", "6"],
            Numpad7: ["", "7", "", "7"],
            Numpad8: ["", "8", "", "8"],
            Numpad9: ["", "9", "", "9"],
            Numpad0: ["", "0", "", "0"],
            NumpadDecimal: ["", ".", "", "."],
            IntlBackslash: ["<", ">", "|", "¦"],
            NumpadEqual: ["=", "=", "=", "="],
            NumpadComma: [".", ".", ".", "."],
            NumpadParenLeft: ["(", "(", "(", "("],
            NumpadParenRight: [")", ")", ")", ")"]
        }
    }), Bi({
        id: "linux.french",
        locale: "fr",
        displayName: "French",
        virtualLayout: "azerty",
        platform: "linux",
        score: 0,
        mapping: {
            KeyA: ["q", "Q", "@", "Ω"],
            KeyB: ["b", "B", "”", "’"],
            KeyC: ["c", "C", "¢", "©"],
            KeyD: ["d", "D", "ð", "Ð"],
            KeyE: ["e", "E", "€", "¢"],
            KeyF: ["f", "F", "đ", "ª"],
            KeyG: ["g", "G", "ŋ", "Ŋ"],
            KeyH: ["h", "H", "ħ", "Ħ"],
            KeyI: ["i", "I", "→", "ı"],
            KeyJ: ["j", "J", "̉", "̛"],
            KeyK: ["k", "K", "ĸ", "&"],
            KeyL: ["l", "L", "ł", "Ł"],
            KeyM: [",", "?", "́", "̋"],
            KeyN: ["n", "N", "n", "N"],
            KeyO: ["o", "O", "ø", "Ø"],
            KeyP: ["p", "P", "þ", "Þ"],
            KeyQ: ["a", "A", "æ", "Æ"],
            KeyR: ["r", "R", "¶", "®"],
            KeyS: ["s", "S", "ß", "§"],
            KeyT: ["t", "T", "ŧ", "Ŧ"],
            KeyU: ["u", "U", "↓", "↑"],
            KeyV: ["v", "V", "“", "‘"],
            KeyW: ["z", "Z", "«", "<"],
            KeyX: ["x", "X", "»", ">"],
            KeyY: ["y", "Y", "←", "¥"],
            KeyZ: ["w", "W", "ł", "Ł"],
            Digit1: ["&", "1", "¹", "¡"],
            Digit2: ["é", "2", "~", "⅛"],
            Digit3: ['"', "3", "#", "£"],
            Digit4: ["'", "4", "{", "$"],
            Digit5: ["(", "5", "[", "⅜"],
            Digit6: ["-", "6", "|", "⅝"],
            Digit7: ["è", "7", "`", "⅞"],
            Digit8: ["_", "8", "\\", "™"],
            Digit9: ["ç", "9", "^", "±"],
            Digit0: ["à", "0", "@", "°"],
            Enter: ["\r", "\r", "\r", "\r"],
            Escape: ["", "", "", ""],
            Backspace: ["\b", "\b", "\b", "\b"],
            Tab: ["\t", "", "\t", ""],
            Space: [" ", " ", " ", " "],
            Minus: [")", "°", "]", "¿"],
            Equal: ["=", "+", "}", "̨"],
            BracketLeft: ["̂", "̈", "̈", "̊"],
            BracketRight: ["$", "£", "¤", "̄"],
            Backslash: ["*", "µ", "̀", "̆"],
            Semicolon: ["m", "M", "µ", "º"],
            Quote: ["ù", "%", "̂", "̌"],
            Backquote: ["²", "~", "¬", "¬"],
            Comma: [";", ".", "─", "×"],
            Period: [":", "/", "·", "÷"],
            Slash: ["!", "§", "̣", "̇"],
            NumpadMultiply: ["*", "*", "*", "*"],
            NumpadSubtract: ["-", "-", "-", "-"],
            NumpadAdd: ["+", "+", "+", "+"],
            NumpadDecimal: ["", ".", "", "."],
            IntlBackslash: ["<", ">", "|", "¦"]
        }
    }), Bi({
        id: "windows.french",
        locale: "fr",
        displayName: "French",
        virtualLayout: "azerty",
        platform: "windows",
        score: 0,
        mapping: {
            KeyA: ["q", "Q", "", ""],
            KeyB: ["b", "B", "", ""],
            KeyC: ["c", "C", "", ""],
            KeyD: ["d", "D", "", ""],
            KeyE: ["e", "E", "€", ""],
            KeyF: ["f", "F", "", ""],
            KeyG: ["g", "G", "", ""],
            KeyH: ["h", "H", "", ""],
            KeyI: ["i", "I", "", ""],
            KeyJ: ["j", "J", "", ""],
            KeyK: ["k", "K", "", ""],
            KeyL: ["l", "L", "", ""],
            KeyM: [",", "?", "", ""],
            KeyN: ["n", "N", "", ""],
            KeyO: ["o", "O", "", ""],
            KeyP: ["p", "P", "", ""],
            KeyQ: ["a", "A", "", ""],
            KeyR: ["r", "R", "", ""],
            KeyS: ["s", "S", "", ""],
            KeyT: ["t", "T", "", ""],
            KeyU: ["u", "U", "", ""],
            KeyV: ["v", "V", "", ""],
            KeyW: ["z", "Z", "", ""],
            KeyX: ["x", "X", "", ""],
            KeyY: ["y", "Y", "", ""],
            KeyZ: ["w", "W", "", ""],
            Digit1: ["&", "1", "", ""],
            Digit2: ["é", "2", "~", ""],
            Digit3: ['"', "3", "#", ""],
            Digit4: ["'", "4", "{", ""],
            Digit5: ["(", "5", "[", ""],
            Digit6: ["-", "6", "|", ""],
            Digit7: ["è", "7", "`", ""],
            Digit8: ["_", "8", "\\", ""],
            Digit9: ["ç", "9", "^", ""],
            Digit0: ["à", "0", "@", ""],
            Space: [" ", " ", "", ""],
            Minus: [")", "°", "]", ""],
            Equal: ["=", "+", "}", ""],
            BracketLeft: ["^", "¨", "", ""],
            BracketRight: ["$", "£", "¤", ""],
            Backslash: ["*", "µ", "", ""],
            Semicolon: ["m", "M", "", ""],
            Quote: ["ù", "%", "", ""],
            Backquote: ["²", "", "", ""],
            Comma: [";", ".", "", ""],
            Period: [":", "/", "", ""],
            Slash: ["!", "§", "", ""],
            NumpadDivide: ["/", "/", "", ""],
            NumpadMultiply: ["*", "*", "", ""],
            NumpadSubtract: ["-", "-", "", ""],
            NumpadAdd: ["+", "+", "", ""],
            IntlBackslash: ["<", ">", "", ""]
        }
    }), Bi({
        id: "windows.german",
        locale: "de",
        displayName: "German",
        platform: "windows",
        virtualLayout: "qwertz",
        score: 0,
        mapping: {
            KeyA: ["a", "A", "", ""],
            KeyB: ["b", "B", "", ""],
            KeyC: ["c", "C", "", ""],
            KeyD: ["d", "D", "", ""],
            KeyE: ["e", "E", "€", ""],
            KeyF: ["f", "F", "", ""],
            KeyG: ["g", "G", "", ""],
            KeyH: ["h", "H", "", ""],
            KeyI: ["i", "I", "", ""],
            KeyJ: ["j", "J", "", ""],
            KeyK: ["k", "K", "", ""],
            KeyL: ["l", "L", "", ""],
            KeyM: ["m", "M", "µ", ""],
            KeyN: ["n", "N", "", ""],
            KeyO: ["o", "O", "", ""],
            KeyP: ["p", "P", "", ""],
            KeyQ: ["q", "Q", "@", ""],
            KeyR: ["r", "R", "", ""],
            KeyS: ["s", "S", "", ""],
            KeyT: ["t", "T", "", ""],
            KeyU: ["u", "U", "", ""],
            KeyV: ["v", "V", "", ""],
            KeyW: ["w", "W", "", ""],
            KeyX: ["x", "X", "", ""],
            KeyY: ["z", "Z", "", ""],
            KeyZ: ["y", "Y", "", ""],
            Digit1: ["1", "!", "", ""],
            Digit2: ["2", '"', "²", ""],
            Digit3: ["3", "§", "³", ""],
            Digit4: ["4", "$", "", ""],
            Digit5: ["5", "%", "", ""],
            Digit6: ["6", "&", "", ""],
            Digit7: ["7", "/", "{", ""],
            Digit8: ["8", "(", "[", ""],
            Digit9: ["9", ")", "]", ""],
            Digit0: ["0", "=", "}", ""],
            Space: [" ", " ", "", ""],
            Minus: ["ß", "?", "\\", "ẞ"],
            Equal: ["´", "`", "", ""],
            BracketLeft: ["ü", "Ü", "", ""],
            BracketRight: ["+", "*", "~", ""],
            Backslash: ["#", "'", "", ""],
            Semicolon: ["ö", "Ö", "", ""],
            Quote: ["ä", "Ä", "", ""],
            Backquote: ["^", "°", "", ""],
            Comma: [",", ";", "", ""],
            Period: [".", ":", "", ""],
            Slash: ["-", "_", "", ""],
            NumpadDivide: ["/", "/", "", ""],
            NumpadMultiply: ["*", "*", "", ""],
            NumpadSubtract: ["-", "-", "", ""],
            NumpadAdd: ["+", "+", "", ""],
            IntlBackslash: ["<", ">", "|", ""]
        }
    }), Bi({
        id: "apple.german",
        locale: "de",
        displayName: "German",
        virtualLayout: "qwertz",
        platform: "apple",
        score: 0,
        mapping: {
            KeyA: ["a", "A", "å", "Å"],
            KeyB: ["b", "B", "∫", "‹"],
            KeyC: ["c", "C", "ç", "Ç"],
            KeyD: ["d", "D", "∂", "™"],
            KeyE: ["e", "E", "€", "‰"],
            KeyF: ["f", "F", "ƒ", "Ï"],
            KeyG: ["g", "G", "©", "Ì"],
            KeyH: ["h", "H", "ª", "Ó"],
            KeyI: ["i", "I", "⁄", "Û"],
            KeyJ: ["j", "J", "º", "ı"],
            KeyK: ["k", "K", "∆", "ˆ"],
            KeyL: ["l", "L", "@", "ﬂ"],
            KeyM: ["m", "M", "µ", "˘"],
            KeyN: ["n", "N", "~", "›"],
            KeyO: ["o", "O", "ø", "Ø"],
            KeyP: ["p", "P", "π", "∏"],
            KeyQ: ["q", "Q", "«", "»"],
            KeyR: ["r", "R", "®", "¸"],
            KeyS: ["s", "S", "‚", "Í"],
            KeyT: ["t", "T", "†", "˝"],
            KeyU: ["u", "U", "¨", "Á"],
            KeyV: ["v", "V", "√", "◊"],
            KeyW: ["w", "W", "∑", "„"],
            KeyX: ["x", "X", "≈", "Ù"],
            KeyY: ["z", "Z", "Ω", "ˇ"],
            KeyZ: ["y", "Y", "¥", "‡"],
            Digit1: ["1", "!", "¡", "¬"],
            Digit2: ["2", '"', "“", "”"],
            Digit3: ["3", "§", "¶", "#"],
            Digit4: ["4", "$", "¢", "£"],
            Digit5: ["5", "%", "[", "ﬁ"],
            Digit6: ["6", "&", "]", "^"],
            Digit7: ["7", "/", "|", "\\"],
            Digit8: ["8", "(", "{", "˜"],
            Digit9: ["9", ")", "}", "·"],
            Digit0: ["0", "=", "≠", "¯"],
            Space: [" ", " ", " ", " "],
            Minus: ["ß", "?", "¿", "˙"],
            Equal: ["´", "`", "'", "˚"],
            BracketLeft: ["ü", "Ü", "•", "°"],
            BracketRight: ["+", "*", "±", ""],
            Backslash: ["#", "'", "‘", "’"],
            Semicolon: ["ö", "Ö", "œ", "Œ"],
            Quote: ["ä", "Ä", "æ", "Æ"],
            Backquote: ["<", ">", "≤", "≥"],
            Comma: [",", ";", "∞", "˛"],
            Period: [".", ":", "…", "÷"],
            Slash: ["-", "_", "–", "—"],
            NumpadDivide: ["/", "/", "/", "/"],
            NumpadMultiply: ["*", "*", "*", "*"],
            NumpadSubtract: ["-", "-", "-", "-"],
            NumpadAdd: ["+", "+", "+", "+"],
            NumpadDecimal: [",", ",", ".", "."],
            IntlBackslash: ["^", "°", "„", "“"],
            NumpadEqual: ["=", "=", "=", "="]
        }
    }), Bi({
        id: "dvorak",
        locale: "en",
        displayName: "Dvorak",
        virtualLayout: "dvorak",
        platform: "",
        score: 0,
        mapping: {
            KeyA: ["a", "A", "å", "Å"],
            KeyB: ["x", "X", "≈", "˛"],
            KeyC: ["j", "J", "∆", "Ô"],
            KeyD: ["e", "E", "´", "´"],
            KeyE: [".", ">", "≥", "˘"],
            KeyF: ["u", "U", "¨", "¨"],
            KeyG: ["i", "I", "ˆ", "ˆ"],
            KeyH: ["d", "D", "∂", "Î"],
            KeyI: ["c", "C", "ç", "Ç"],
            KeyJ: ["h", "H", "˙", "Ó"],
            KeyK: ["t", "T", "†", "ˇ"],
            KeyL: ["n", "N", "˜", "˜"],
            KeyM: ["m", "M", "µ", "Â"],
            KeyN: ["b", "B", "∫", "ı"],
            KeyO: ["r", "R", "®", "‰"],
            KeyP: ["l", "L", "¬", "Ò"],
            KeyQ: ["'", '"', "æ", "Æ"],
            KeyR: ["p", "P", "π", "∏"],
            KeyS: ["o", "O", "ø", "Ø"],
            KeyT: ["y", "Y", "¥", "Á"],
            KeyU: ["g", "G", "©", "˝"],
            KeyV: ["k", "K", "˚", ""],
            KeyW: [",", "<", "≤", "¯"],
            KeyX: ["q", "Q", "œ", "Œ"],
            KeyY: ["f", "F", "ƒ", "Ï"],
            KeyZ: [";", ":", "…", "Ú"],
            Digit1: ["1", "!", "¡", "⁄"],
            Digit2: ["2", "@", "™", "€"],
            Digit3: ["3", "#", "£", "‹"],
            Digit4: ["4", "$", "¢", "›"],
            Digit5: ["5", "%", "∞", "ﬁ"],
            Digit6: ["6", "^", "§", "ﬂ"],
            Digit7: ["7", "&", "¶", "‡"],
            Digit8: ["8", "*", "•", "°"],
            Digit9: ["9", "(", "ª", "·"],
            Digit0: ["0", ")", "º", "‚"],
            Space: [" ", " ", " ", " "],
            Minus: ["[", "{", "“", "”"],
            Equal: ["]", "}", "‘", "’"],
            BracketLeft: ["/", "?", "÷", "¿"],
            BracketRight: ["=", "+", "≠", "±"],
            Backslash: ["\\", "|", "«", "»"],
            Semicolon: ["s", "S", "ß", "Í"],
            Quote: ["-", "_", "–", "—"],
            Backquote: ["`", "~", "`", "`"],
            Comma: ["w", "W", "∑", "„"],
            Period: ["v", "V", "√", "◊"],
            Slash: ["z", "Z", "Ω", "¸"],
            NumpadDivide: ["/", "/", "/", "/"],
            NumpadMultiply: ["*", "*", "*", "*"],
            NumpadSubtract: ["-", "-", "-", "-"],
            NumpadAdd: ["+", "+", "+", "+"],
            Numpad1: ["1", "1", "1", "1"],
            Numpad2: ["2", "2", "2", "2"],
            Numpad3: ["3", "3", "3", "3"],
            Numpad4: ["4", "4", "4", "4"],
            Numpad5: ["5", "5", "5", "5"],
            Numpad6: ["6", "6", "6", "6"],
            Numpad7: ["7", "7", "7", "7"],
            Numpad8: ["8", "8", "8", "8"],
            Numpad9: ["9", "9", "9", "9"],
            Numpad0: ["0", "0", "0", "0"],
            NumpadDecimal: [".", ".", ".", "."],
            IntlBackslash: ["§", "±", "§", "±"],
            NumpadEqual: ["=", "=", "=", "="],
            AudioVolumeUp: ["", "=", "", "="]
        }
    });
    const qi = [{
            key: "left",
            command: "moveToPreviousChar"
        }, {
            key: "right",
            command: "moveToNextChar"
        }, {
            key: "up",
            command: "moveUp"
        }, {
            key: "down",
            command: "moveDown"
        }, {
            key: "shift+[ArrowLeft]",
            command: "extendSelectionBackward"
        }, {
            key: "shift+[ArrowRight]",
            command: "extendSelectionForward"
        }, {
            key: "shift+[ArrowUp]",
            command: "extendSelectionUpward"
        }, {
            key: "shift+[ArrowDown]",
            command: "extendSelectionDownward"
        }, {
            key: "[Backspace]",
            command: "deleteBackward"
        }, {
            key: "alt+[Delete]",
            command: "deleteBackward"
        }, {
            key: "[Delete]",
            command: "deleteForward"
        }, {
            key: "alt+[Backspace]",
            command: "deleteForward"
        }, {
            key: "alt+[ArrowLeft]",
            command: "moveToPreviousWord"
        }, {
            key: "alt+[ArrowRight]",
            command: "moveToNextWord"
        }, {
            key: "shift+alt+[ArrowLeft]",
            command: "extendToPreviousWord"
        }, {
            key: "shift+alt+[ArrowRight]",
            command: "extendToNextWord"
        }, {
            key: "ctrl+[ArrowLeft]",
            command: "moveToGroupStart"
        }, {
            key: "ctrl+[ArrowRight]",
            command: "moveToGroupEnd"
        }, {
            key: "shift+ctrl+[ArrowLeft]",
            command: "extendToGroupStart"
        }, {
            key: "shift+ctrl+[ArrowRight]",
            command: "extendToGroupEnd"
        }, {
            key: "[Space]",
            ifMode: "math",
            command: "moveAfterParent"
        }, {
            key: "shift+[Space]",
            ifMode: "math",
            command: "moveBeforeParent"
        }, {
            key: "[Home]",
            command: "moveToMathFieldStart"
        }, {
            key: "cmd+[ArrowLeft]",
            command: "moveToMathFieldStart"
        }, {
            key: "shift+[Home]",
            command: "extendToMathFieldStart"
        }, {
            key: "shift+cmd+[ArrowLeft]",
            command: "extendToMathFieldStart"
        }, {
            key: "[End]",
            command: "moveToMathFieldEnd"
        }, {
            key: "cmd+[ArrowRight]",
            command: "moveToMathFieldEnd"
        }, {
            key: "shift+[End]",
            command: "extendToMathFieldEnd"
        }, {
            key: "shift+cmd+[ArrowRight]",
            command: "extendToMathFieldEnd"
        }, {
            key: "[Pageup]",
            command: "moveToGroupStart"
        }, {
            key: "[Pagedown]",
            command: "moveToGroupEnd"
        }, {
            key: "[Tab]",
            ifMode: "math",
            command: "moveToNextPlaceholder"
        }, {
            key: "shift+[Tab]",
            ifMode: "math",
            command: "moveToPreviousPlaceholder"
        }, {
            key: "[Tab]",
            ifMode: "text",
            command: "moveToNextPlaceholder"
        }, {
            key: "shift+[Tab]",
            ifMode: "text",
            command: "moveToPreviousPlaceholder"
        }, {
            key: "[Escape]",
            ifMode: "math",
            command: ["switchMode", "latex"]
        }, {
            key: "[Escape]",
            ifMode: "text",
            command: ["switchMode", "latex"]
        }, {
            key: "\\",
            ifMode: "math",
            command: ["switchMode", "latex", "\\"]
        }, {
            key: "[IntlBackslash]",
            ifMode: "math",
            command: ["switchMode", "latex", "\\"]
        }, {
            key: "[Escape]",
            ifMode: "latex",
            command: ["complete", "complete", {
                selectItem: "true"
            }]
        }, {
            key: "[Tab]",
            ifMode: "latex",
            command: ["complete", "accept-suggestion"]
        }, {
            key: "[Return]",
            ifMode: "latex",
            command: "complete"
        }, {
            key: "[Enter]",
            ifMode: "latex",
            command: "complete"
        }, {
            key: "shift+[Escape]",
            ifMode: "latex",
            command: ["complete", "reject"]
        }, {
            key: "[ArrowDown]",
            ifMode: "latex",
            command: "nextSuggestion"
        }, {
            key: "[ArrowUp]",
            ifMode: "latex",
            command: "previousSuggestion"
        }, {
            key: "ctrl+a",
            ifPlatform: "!macos",
            command: "selectAll"
        }, {
            key: "cmd+a",
            command: "selectAll"
        }, {
            key: "[Cut]",
            command: "cutToClipboard"
        }, {
            key: "[Copy]",
            command: "copyToClipboard"
        }, {
            key: "[Paste]",
            command: "pasteFromClipboard"
        }, {
            key: "[Clear]",
            command: "deleteBackward"
        }, {
            key: "ctrl+z",
            ifPlatform: "!macos",
            command: "undo"
        }, {
            key: "cmd+z",
            command: "undo"
        }, {
            key: "[Undo]",
            command: "undo"
        }, {
            key: "ctrl+y",
            ifPlatform: "!macos",
            command: "redo"
        }, {
            key: "shift+cmd+y",
            command: "redo"
        }, {
            key: "shift+ctrl+z",
            ifPlatform: "!macos",
            command: "redo"
        }, {
            key: "shift+cmd+z",
            command: "redo"
        }, {
            key: "[Redo]",
            command: "redo"
        }, {
            key: "[EraseEof]",
            command: "deleteToGroupEnd"
        }, {
            key: "ctrl+b",
            ifPlatform: "macos",
            command: "moveToPreviousChar"
        }, {
            key: "ctrl+f",
            ifPlatform: "macos",
            command: "moveToNextChar"
        }, {
            key: "ctrl+p",
            ifPlatform: "macos",
            command: "moveUp"
        }, {
            key: "ctrl+n",
            ifPlatform: "macos",
            command: "moveDown"
        }, {
            key: "ctrl+a",
            ifPlatform: "macos",
            command: "moveToMathFieldStart"
        }, {
            key: "ctrl+e",
            ifPlatform: "macos",
            command: "moveToMathFieldEnd"
        }, {
            key: "shift+ctrl+b",
            ifPlatform: "macos",
            command: "extendSelectionBackward"
        }, {
            key: "shift+ctrl+f",
            ifPlatform: "macos",
            command: "extendSelectionForward"
        }, {
            key: "shift+ctrl+p",
            ifPlatform: "macos",
            command: "extendSelectionUpward"
        }, {
            key: "shift+ctrl+n",
            ifPlatform: "macos",
            command: "extendSelectionDownward"
        }, {
            key: "shift+ctrl+a",
            ifPlatform: "macos",
            command: "extendToMathFieldStart"
        }, {
            key: "shift+ctrl+e",
            ifPlatform: "macos",
            command: "extendToMathFieldEnd"
        }, {
            key: "alt+ctrl+b",
            ifPlatform: "macos",
            command: "moveToPreviousWord"
        }, {
            key: "alt+ctrl+f",
            ifPlatform: "macos",
            command: "moveToNextWord"
        }, {
            key: "shift+alt+ctrl+b",
            ifPlatform: "macos",
            command: "extendToPreviousWord"
        }, {
            key: "shift+alt+ctrl+f",
            ifPlatform: "macos",
            command: "extendToNextWord"
        }, {
            key: "ctrl+h",
            ifPlatform: "macos",
            command: "deleteBackward"
        }, {
            key: "ctrl+d",
            ifPlatform: "macos",
            command: "deleteForward"
        }, {
            key: "ctrl+l",
            ifPlatform: "macos",
            command: "scrollIntoView"
        }, {
            key: "ctrl+[Digit2]",
            ifMode: "math",
            command: ["insert", "\\sqrt{#0}"]
        }, {
            key: "ctrl+[Digit5]",
            ifMode: "math",
            command: "moveToOpposite"
        }, {
            key: "ctrl+[Digit6]",
            ifMode: "math",
            command: "moveToSuperscript"
        }, {
            key: "ctrl+[Return]",
            ifMode: "math",
            command: "addRowAfter"
        }, {
            key: "ctrl+[Enter]",
            ifMode: "math",
            command: "addRowAfter"
        }, {
            key: "cmd+[Return]",
            ifMode: "math",
            command: "addRowAfter"
        }, {
            key: "cmd+[Enter]",
            ifMode: "math",
            command: "addRowAfter"
        }, {
            key: "alt+p",
            ifMode: "math",
            command: ["insert", "\\pi"]
        }, {
            key: "alt+v",
            ifMode: "math",
            command: ["insert", "\\sqrt{#0}"]
        }, {
            key: "alt+w",
            ifMode: "math",
            command: ["insert", "\\sum_{i=#?}^{#?}"]
        }, {
            key: "alt+b",
            command: ["insert", "\\int_{#?}^{#?}"]
        }, {
            key: "alt+u",
            ifMode: "math",
            command: ["insert", "\\cup"]
        }, {
            key: "alt+n",
            ifMode: "math",
            command: ["insert", "\\cap"]
        }, {
            key: "alt+o",
            ifMode: "math",
            command: ["insert", "\\emptyset"]
        }, {
            key: "alt+d",
            ifMode: "math",
            command: ["insert", "\\differentialD"]
        }, {
            key: "shift+alt+o",
            ifMode: "math",
            command: ["insert", "\\varnothing"]
        }, {
            key: "shift+alt+d",
            ifMode: "math",
            command: ["insert", "\\partial"]
        }, {
            key: "shift+alt+p",
            ifMode: "math",
            command: ["insert", "\\prod_{i=#?}^{#?}"]
        }, {
            key: "shift+alt+u",
            ifMode: "math",
            command: ["insert", "\\bigcup"]
        }, {
            key: "shift+alt+n",
            ifMode: "math",
            command: ["insert", "\\bigcap"]
        }, {
            key: "shift+alt+a",
            ifMode: "math",
            command: ["insert", "\\forall"]
        }, {
            key: "shift+alt+e",
            ifMode: "math",
            command: ["insert", "\\exists"]
        }, {
            key: "alt+[Backslash]",
            ifMode: "math",
            command: ["insert", "\\backslash"]
        }, {
            key: "[NumpadDivide]",
            ifMode: "math",
            command: ["insert", "\\frac{#@}{#?}"]
        }, {
            key: "alt+[NumpadDivide]",
            ifMode: "math",
            command: ["insert", "\\frac{#?}{#@}"]
        }, {
            key: "shift+alt+k",
            command: "toggleKeystrokeCaption"
        }, {
            key: "alt+[Space]",
            command: "toggleVirtualKeyboard"
        }, {
            key: "alt+ctrl+[ArrowUp]",
            command: ["speak", "all", {
                withHighlighting: !1
            }]
        }, {
            key: "alt+ctrl+[ArrowDown]",
            command: ["speak", "selection", {
                withHighlighting: !1
            }]
        }, {
            key: "alt+[Equal]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["applyStyle", {
                mode: "text"
            }]
        }, {
            key: "alt+[Equal]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "text",
            command: ["applyStyle", {
                mode: "math"
            }]
        }, {
            key: "shift+[Quote]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["switchMode", "text", "", ""]
        }, {
            key: "shift+[Quote]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "text",
            command: ["switchMode", "math", "", ""]
        }, {
            key: "/",
            ifMode: "math",
            command: ["insert", "\\frac{#@}{#?}"]
        }, {
            key: "alt+/",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", "\\/"]
        }, {
            key: "alt+[BracketLeft]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", "\\left\\lbrack #0 \\right\\rbrack"]
        }, {
            key: "ctrl+[Minus]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: "moveToSubscript"
        }, {
            key: "shift+alt+[BracketLeft]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", "\\left\\lbrace #0 \\right\\rbrace"]
        }, {
            key: "ctrl+;",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: "addRowAfter"
        }, {
            key: "cmd+;",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: "addRowAfter"
        }, {
            key: "shift+ctrl+;",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: "addRowBefore"
        }, {
            key: "shift+cmd+;",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: "addRowBefore"
        }, {
            key: "ctrl+[Backspace]",
            ifMode: "math",
            command: "removeRow"
        }, {
            key: "cmd+[Backspace]",
            ifMode: "math",
            command: "removeRow"
        }, {
            key: "ctrl+[Comma]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: "addColumnAfter"
        }, {
            key: "cmd+[Comma]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: "addColumnAfter"
        }, {
            key: "shift+ctrl+[Comma]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: "addColumnBefore"
        }, {
            key: "shift+cmd+[Comma]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: "addColumnBefore"
        }, {
            key: "shift+[Backspace]",
            ifMode: "math",
            command: "removeColumn"
        }, {
            key: "alt+[Digit5]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", "$\\infty"]
        }, {
            key: "alt+[Digit6]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", "\\wedge"]
        }, {
            key: "shift+alt+[Digit6]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", "\\vee"]
        }, {
            key: "alt+[Digit9]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", "("]
        }, {
            key: "alt+[Digit0]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", ")"]
        }, {
            key: "alt+|",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", "|"]
        }, {
            key: "shift+[Backquote]",
            ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
            ifMode: "math",
            command: ["insert", "\\~"]
        }, {
            key: "[Backquote]",
            ifLayout: ["windows.french", "linux.french"],
            ifMode: "math",
            command: ["insert", "^2"]
        }],
        $i = {
            "\\theta": "alt+q",
            "\\sqrt": ["alt+v", "ctrl+[Digit2]"],
            "\\pi": "alt+p",
            "\\prod": "shift+alt+p",
            "\\sum": "alt+w",
            "\\int": "alt+b",
            "\\cup": "alt+u",
            "\\cap": "alt+n",
            "\\bigcup": "shift+alt+u",
            "\\bigcap": "shift+alt+n",
            "\\forall": "shift+alt+a",
            "\\exists": "shift+alt+e",
            "\\infty": "alt+[Digit5]",
            "\\wedge": "alt+[Digit6]",
            "\\vee": "shift+alt+[Digit6]",
            "\\differentialD": "alt+d",
            "\\partial": "shift+alt+d",
            "\\frac": "Slash",
            "\\emptyset": "alt+o",
            "\\varnothing": "shift+alt+o",
            "\\~": "~"
        };

    function Ei(e) {
        let t = e;
        return i(t) && (t = t.length > 0 ? t[0] + "(" + t.slice(1).join("") + ")" : ""), t
    }

    function Oi(e, t) {
        let a = [];
        if ("string" == typeof t) {
            const e = $i[t];
            i(e) ? a = e.slice() : e && a.push(e)
        }
        const o = Ei(t),
            r = new RegExp("^" + o.replace("\\", "\\\\").replace("|", "\\|").replace("*", "\\*").replace("$", "\\$").replace("^", "\\^") + "([^*a-zA-Z]|$)");
        for (const t of e) r.test(Ei(t.command)) && a.push(t.key);
        return a.map(Ni)
    }

    function Ni(e) {
        var t;
        const a = /macos|ios|/.test(l()),
            i = e.split("+");
        let o = "";
        for (const e of i) !a && o && (o += '<span class="ML__shortcut-join">+</span>'), e.startsWith("[Key") ? o += e.slice(4, 5) : e.startsWith("Key") ? o += e.slice(3, 4) : e.startsWith("[Digit") ? o += e.slice(6, 7) : e.startsWith("Digit") ? o += e.slice(5, 6) : o += null !== (t = {
            cmd: "⌘",
            meta: a ? "⌘" : "command",
            shift: a ? "⇧" : "shift",
            alt: a ? "⌥" : "alt",
            ctrl: a ? "⌃" : "control",
            "\n": a ? "⏎" : "return",
            "[return]": a ? "⏎" : "return",
            "[enter]": a ? "⌤" : "enter",
            "[tab]": a ? "⇥" : "tab",
            "[escape]": "esc",
            "[backspace]": a ? "⌫" : "backspace",
            "[delete]": a ? "⌦" : "del",
            "[pageup]": a ? "⇞" : "page up",
            "[pagedown]": a ? "⇟" : "page down",
            "[home]": a ? "⤒" : "home",
            "[end]": a ? "⤓" : "end",
            "[space]": "space",
            "[equal]": "=",
            "[minus]": "-",
            "[comma]": ",",
            "[slash]": "/",
            "[backslash]": "\\",
            "[bracketleft]": "[",
            "[bracketright]": "]",
            semicolon: ";",
            period: ".",
            comma: ",",
            minus: "-",
            equal: "=",
            quote: "'",
            bracketLeft: "[",
            bracketRight: "]",
            backslash: "\\",
            intlbackslash: "\\",
            backquote: "`",
            slash: "/",
            numpadmultiply: "* &#128290;",
            numpaddivide: "/ &#128290;",
            numpadsubtract: "- &#128290;",
            numpadadd: "+ &#128290;",
            numpaddecimal: ". &#128290;",
            numpadcomma: ", &#128290;",
            help: "help",
            left: "⇠",
            up: "⇡",
            right: "⇢",
            down: "⇣",
            "[arrowleft]": "⇠",
            "[arrowup]": "⇡",
            "[arrowright]": "⇢",
            "[arrowdown]": "⇣",
            "[digit0]": "0",
            "[digit1]": "1",
            "[digit2]": "2",
            "[digit3]": "3",
            "[digit4]": "4",
            "[digit5]": "5",
            "[digit6]": "6",
            "[digit7]": "7",
            "[digit8]": "8",
            "[digit9]": "9"
        } [e.toLowerCase()]) && void 0 !== t ? t : e.toUpperCase();
        return o
    }

    function Pi(e, t) {
        if (e.ifPlatform && !/^!?(macos|windows|android|ios|chromeos|other)$/.test(e.ifPlatform)) throw new Error(`Unexpected platform "${e.ifPlatform}" for keybinding ${e.key}`);
        if (void 0 !== e.ifLayout && (0 === t.score || !e.ifLayout.includes(t.id))) return;
        const a = Li(e.key);
        let i = e.ifPlatform;
        if (a.cmd) {
            if (i && "macos" !== i && "ios" !== i) throw new Error('Unexpected "cmd" modifier with platform "' + i + '"\n"cmd" modifier can only be used with macOS or iOS platform.');
            i || (i = "ios" === l() ? "ios" : "macos"), a.win = !1, a.cmd = !1, a.meta = !0
        }
        if (a.win) {
            if (i && "windows" !== i) throw new Error('Unexpected "win" modifier with platform "' + i + '"\n"win" modifier can only be used with Windows platform.');
            i = "windows", a.win = !1, a.cmd = !1, a.meta = !0
        }
        if (i && ! function(e) {
                if (o()) {
                    const t = l(),
                        a = e.startsWith("!"),
                        i = e.endsWith(t);
                    if (a && !i) return !0;
                    if (!a && i) return !0
                }
                return "!other" !== e && "other" === e
            }(i)) return;
        if (/^\[.+\]$/.test(a.key)) return {
            ...e,
            ifPlatform: i,
            key: Ci(a)
        };
        const r = function(e, t) {
            var a;
            const i = {
                shift: !1,
                alt: !1,
                cmd: !1,
                win: !1,
                meta: !1,
                ctrl: !1,
                key: ""
            };
            if (!e) return i;
            for (const [a, o] of Object.entries(t.mapping)) {
                if (o[0] === e) return i.key = `[${a}]`, i;
                if (o[1] === e) return i.shift = !0, i.key = `[${a}]`, i;
                if (o[2] === e) return i.alt = !0, i.key = `[${a}]`, i;
                if (o[3] === e) return i.shift = !0, i.alt = !0, i.key = `[${a}]`, i
            }
            return i.key = null !== (a = Di[e]) && void 0 !== a ? a : "", i
        }(a.key, t);
        if (!r) throw new Error('Invalid keybinding key "' + e.key + '"');
        if (r.shift && a.shift || r.alt && a.alt) throw new Error(`The keybinding ${e.key} (${Fi(e.command)}) is conflicting with the key combination ${Ci(r)} using the ${t.displayName} keyboard layout`);
        return r.shift = r.shift || a.shift, r.alt = r.alt || a.alt, r.meta = a.meta, r.ctrl = a.ctrl, {
            ...e,
            ifPlatform: i,
            key: Ci(r)
        }
    }

    function Fi(e) {
        if (Array.isArray(e)) {
            const t = [...e];
            return t.shift() + "(" + t.map((e => "string" == typeof e ? `"${e}"` : e.toString())).join(", ") + ")"
        }
        return e
    }
    var Ri = '#mathlive-popover-panel{background-color:rgba(97,97,97,.95);border-radius:8px;box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22);color:#fff;display:flex;flex-direction:column;justify-content:center;position:fixed;text-align:center;transition:all .2s cubic-bezier(.64,.09,.08,1);visibility:hidden;z-index:1}#mathlive-popover-panel:after{border-bottom:5px solid rgba(97,97,97,.9);border-left:5px solid transparent;border-right:5px solid transparent;content:"";font-size:1rem;height:0;left:calc(50% - 3px);position:absolute;top:-5px;width:0}#mathlive-popover-panel.is-visible{animation:ML__fade-in .15s cubic-bezier(0,0,.2,1);visibility:inherit}@keyframes ML__fade-in{0%{opacity:0}to{opacity:1}}#mathlive-popover-panel ul{align-items:flex-start;display:flex;flex-flow:column;justify-content:center;list-style:none;margin:0;padding:0}#mathlive-popover-panel li{border-radius:8px;column-gap:1em;cursor:pointer;display:flex;flex-direction:row;justify-content:space-between;margin:8px;padding:8px;width:calc(100% - 32px)}#mathlive-popover-panel li a{color:#5ea6fd;display:block;margin-top:.4em;padding-top:.3em}#mathlive-popover-panel li a:hover{color:#5ea6fd;text-decoration:underline}#mathlive-popover-panel li.is-active,#mathlive-popover-panel li.is-pressed,#mathlive-popover-panel li:hover{background:hsla(0,0%,100%,.1)}.ML__popover__command{font-family:KaTeX_Main;font-size:1.6rem}.ML__popover__latex{align-self:center;font-family:IBM Plex Mono,Source Code Pro,Consolas,Roboto Mono,Menlo,Bitstream Vera Sans Mono,DejaVu Sans Mono,Monaco,Courier,monospace}.ML__popover__keybinding{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:.8em;opacity:.7}.ML__shortcut-join{opacity:.5}',
        Ii = '.ML__sr-only{clip:rect(0,0,0,0);border:0;-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ML__base,.ML__isInline{display:inline-block}.ML__base{border:0;box-sizing:content-box;cursor:text;font-family:inherit;font-style:inherit;font-weight:inherit;margin:0;outline:0;padding:0;position:relative;text-decoration:none;vertical-align:baseline;visibility:inherit;width:min-content}body.ML__fonts-loading .ML__base{visibility:hidden}.ML__strut,.ML__strut--bottom{display:inline-block;min-height:.5em}.ML__small-delim{font-family:KaTeX_Main}.ML__text{font-family:var(--text-font-family,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif);white-space:pre}.ML__cmr{font-family:KaTeX_Main;font-style:normal}.ML__mathit{font-family:KaTeX_Math;font-style:italic}.ML__mathbf{font-family:KaTeX_Main;font-weight:700}.lcGreek.ML__mathbf{font-family:KaTeX_Math;font-weight:400}.ML__mathbfit{font-family:KaTeX_Math;font-style:italic;font-weight:700}.ML__ams,.ML__bb{font-family:KaTeX_AMS}.ML__cal{font-family:KaTeX_Caligraphic}.ML__frak{font-family:KaTeX_Fraktur}.ML__tt{font-family:KaTeX_Typewriter}.ML__script{font-family:KaTeX_Script}.ML__sans{font-family:KaTeX_SansSerif}.ML__series_el,.ML__series_ul{font-weight:100}.ML__series_l{font-weight:200}.ML__series_sl{font-weight:300}.ML__series_sb{font-weight:500}.ML__bold,.ML__boldsymbol{font-weight:700}.ML__series_eb{font-weight:800}.ML__series_ub{font-weight:900}.ML__series_uc{font-stretch:ultra-condensed}.ML__series_ec{font-stretch:extra-condensed}.ML__series_c{font-stretch:condensed}.ML__series_sc{font-stretch:semi-condensed}.ML__series_sx{font-stretch:semi-expanded}.ML__series_x{font-stretch:expanded}.ML__series_ex{font-stretch:extra-expanded}.ML__series_ux{font-stretch:ultra-expanded}.ML__it{font-style:italic}.ML__shape_ol{-webkit-text-stroke:1px #000;text-stroke:1px #000;color:transparent}.ML__shape_sc{font-variant:small-caps}.ML__shape_sl{font-style:oblique}.ML__emph{color:#bc2612}.ML__emph .ML__emph{color:#0c7f99}.ML__highlight{background:#edd1b0;color:#007cb2}.ML__center{text-align:center}.ML__label_padding{padding:0 .5em}.ML__frac-line{min-height:1px;width:100%}.ML__frac-line:after{background:currentColor;box-sizing:content-box;content:"";display:block;margin-top:-.04em;min-height:.04em;-webkit-print-color-adjust:exact;print-color-adjust:exact;transform:translate(0)}.ML__sqrt,.ML__sqrt-sign{display:inline-block}.ML__sqrt-sign{font-family:KaTeX_Main;position:relative}.ML__sqrt-line{display:inline-block;height:.04em;width:100%}.ML__sqrt-line:before{background:currentColor;content:"";display:block;margin-top:-.04em;min-height:.04em;-webkit-print-color-adjust:exact;print-color-adjust:exact;transform:translate(0)}.ML__sqrt-line:after{border-bottom-width:1px;content:" ";display:block;margin-top:-.1em}.ML__sqrt-index{margin-left:.27777778em;margin-right:-.55555556em}.ML__delim-size1{font-family:KaTeX_Size1}.ML__delim-size2{font-family:KaTeX_Size2}.ML__delim-size3{font-family:KaTeX_Size3}.ML__delim-size4{font-family:KaTeX_Size4}.ML__delim-mult .delim-size1>span{font-family:KaTeX_Size1}.ML__delim-mult .delim-size4>span{font-family:KaTeX_Size4}.ML__accent-body>span{font-family:KaTeX_Main;width:0}.ML__accent-vec>span{left:.24em;position:relative}.ML__mathlive{word-wrap:normal;direction:ltr;display:inline-block;font-family:KaTeX_Main,Times New Roman,serif;font-size-adjust:none;font-stretch:normal;font-style:normal;font-variant-caps:normal;letter-spacing:normal;line-height:1.2;text-align:left;text-indent:0;text-rendering:auto;text-shadow:none;-webkit-user-select:none;user-select:none;white-space:nowrap;width:min-content;word-spacing:normal}.ML__mathlive .style-wrap{position:relative}.ML__mathlive .left-right,.ML__mathlive .mfrac{display:inline-block}.ML__mathlive .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.ML__mathlive .vlist-r{display:table-row}.ML__mathlive .vlist{display:table-cell;position:relative;vertical-align:bottom}.ML__mathlive .vlist>span{display:block;height:0;position:relative}.ML__mathlive .vlist>span>span{display:inline-block}.ML__mathlive .vlist>span>.pstrut{overflow:hidden;width:0}.ML__mathlive .vlist-t2{margin-right:-2px}.ML__mathlive .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.ML__mathlive .msubsup{text-align:left}.ML__mathlive .negativethinspace{display:inline-block;height:.71em;margin-left:-.16667em}.ML__mathlive .thinspace{display:inline-block;height:.71em;width:.16667em}.ML__mathlive .mediumspace{display:inline-block;height:.71em;width:.22222em}.ML__mathlive .thickspace{display:inline-block;height:.71em;width:.27778em}.ML__mathlive .enspace{display:inline-block;height:.71em;width:.5em}.ML__mathlive .quad{display:inline-block;height:.71em;width:1em}.ML__mathlive .qquad{display:inline-block;height:.71em;width:2em}.ML__mathlive .llap,.ML__mathlive .rlap{display:inline-block;position:relative;width:0}.ML__mathlive .llap>.inner,.ML__mathlive .rlap>.inner{position:absolute}.ML__mathlive .llap>.fix,.ML__mathlive .rlap>.fix{display:inline-block}.ML__mathlive .llap>.inner{right:0}.ML__mathlive .rlap>.inner{left:0}.ML__mathlive .rule{border:0 solid;box-sizing:border-box;display:inline-block;position:relative}.ML__mathlive .overline .overline-line,.ML__mathlive .underline .underline-line{width:100%}.ML__mathlive .overline .overline-line:before,.ML__mathlive .underline .underline-line:before{border-bottom-style:solid;border-bottom-width:.04em;content:"";display:block}.ML__mathlive .overline .overline-line:after,.ML__mathlive .underline .underline-line:after{border-bottom-style:solid;border-bottom-width:.04em;content:"";display:block;margin-top:-1px;min-height:thin}.ML__mathlive .stretchy{display:block;left:0;overflow:hidden;position:absolute;width:100%}.ML__mathlive .stretchy:after,.ML__mathlive .stretchy:before{content:""}.ML__mathlive .stretchy svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.ML__mathlive .slice-1-of-2{left:0}.ML__mathlive .slice-1-of-2,.ML__mathlive .slice-2-of-2{display:inline-flex;overflow:hidden;position:absolute;width:50.2%}.ML__mathlive .slice-2-of-2{right:0}.ML__mathlive .slice-1-of-3{display:inline-flex;left:0;overflow:hidden;position:absolute;width:25.1%}.ML__mathlive .slice-2-of-3{display:inline-flex;left:25%;overflow:hidden;position:absolute;width:50%}.ML__mathlive .slice-3-of-3{display:inline-flex;overflow:hidden;position:absolute;right:0;width:25.1%}.ML__mathlive .slice-1-of-1{display:inline-flex;left:0;overflow:hidden;position:absolute;width:100%}.ML__mathlive .nulldelimiter{display:inline-block;width:.12em}.ML__mathlive .op-group{display:inline-block}.ML__mathlive .op-symbol{position:relative}.ML__mathlive .op-symbol.small-op{font-family:KaTeX_Size1}.ML__mathlive .op-symbol.large-op{font-family:KaTeX_Size2}.ML__mathlive .accent>.vlist>span{text-align:center}.ML__mathlive .mtable .vertical-separator{box-sizing:border-box;display:inline-block;min-width:1px}.ML__mathlive .mtable .arraycolsep{display:inline-block}.ML__mathlive .mtable .col-align-m>.vlist-t{text-align:center}.ML__mathlive .mtable .col-align-c>.vlist-t{text-align:center}.ML__mathlive .mtable .col-align-l>.vlist-t{text-align:left}.ML__mathlive .mtable .col-align-r>.vlist-t{text-align:right}.ML__error{background-color:rgba(204,0,65,.1);background-image:radial-gradient(ellipse at center,#cc0041,transparent 70%);background-position:0 100%;background-repeat:repeat-x;background-size:3px 3px;display:inline-block;padding-bottom:3px}.ML__error>.ML__error{background:transparent;padding:0}.ML__composition{background:#fff1c2;color:#000;-webkit-text-decoration:underline var(--caret-color-computed,var(--ML__caret-color));text-decoration:underline var(--caret-color-computed,var(--ML__caret-color))}@media (prefers-color-scheme:dark){.ML__composition{background:#69571c;color:#fff}}.ML__placeholder{color:var(--placeholder-color,var(--ML__placeholder-color));font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;opacity:var(--placeholder-opacity,.4);padding-left:.4ex;padding-right:.4ex}.ML__placeholdercontainer{display:none}.ML__placeholdercontainer math-field{border:1px solid var(--editable-border);border-radius:4px;display:inline-block;min-width:32px;padding-left:4px;padding-right:4px;position:absolute;z-index:1001}.ML__isReadOnly .ML__placeholdercontainer{display:block}.ML__container{min-height:auto!important}';

    function Vi(e) {
        var t;
        "function" != typeof(null === (t = e.listeners) || void 0 === t ? void 0 : t.onSelectionDidChange) || e.suppressChangeNotifications || (e.suppressChangeNotifications = !0, e.listeners.onSelectionDidChange(e), e.suppressChangeNotifications = !1)
    }

    function ji(e, t = {}) {
        if (e.suppressChangeNotifications || !e.mathfield.host) return !0;
        e.suppressChangeNotifications = !0;
        const a = e.mathfield.host.dispatchEvent(new InputEvent("beforeinput", {
            ...t,
            cancelable: !0,
            bubbles: !0,
            composed: !0
        }));
        return e.suppressChangeNotifications = !1, a
    }

    function Hi(e, t) {
        !e.suppressChangeNotifications && e.mathfield.host && (e.suppressChangeNotifications = !0, e.mathfield.host.dispatchEvent(new InputEvent("input", {
            ...t,
            bubbles: !0,
            composed: !0
        })), e.suppressChangeNotifications = !1)
    }

    function Wi(e) {
        var t, a;
        const i = e.atoms.find((e => e instanceof aa));
        return i && null !== (a = null === (t = i.body) || void 0 === t ? void 0 : t.filter((e => e instanceof ta))) && void 0 !== a ? a : []
    }

    function Ji(e, t) {
        var a;
        let i = 0,
            o = !1;
        const r = Number.isFinite(null == t ? void 0 : t.before) ? null !== (a = null == t ? void 0 : t.before) && void 0 !== a ? a : 0 : e.lastOffset;
        for (; i <= r && !o;) {
            const t = e.at(i);
            o = t instanceof ta && t.isSuggestion, o || i++
        }
        if (!o) return [void 0, void 0];
        let n = i,
            s = !1;
        for (; n <= r && !s;) {
            const t = e.at(n);
            s = !(t instanceof ta && t.isSuggestion), s || n++
        }
        return [i - 1, n - 1]
    }

    function Ui(e) {
        const t = Wi(e.model).filter((e => e.isSuggestion));
        if (0 !== t.length) {
            e.model.position = e.model.offsetOf(t[0].leftSibling);
            for (const e of t) e.parent.removeChild(e)
        }
    }

    function Xi(e, t) {
        var a;
        const {
            model: i
        } = e;
        Ui(e);
        for (const e of Wi(i)) e.isError = !1;
        if (!i.selectionIsCollapsed) return void oo(e);
        const o = [];
        let r = i.at(i.position);
        for (; r && r instanceof ta && /^[a-zA-Z\*]$/.test(r.value);) r = r.leftSibling;
        if (r && r instanceof ta && "\\" === r.value)
            for (o.push(r), r = r.rightSibling; r && r instanceof ta && /^[a-zA-Z\*]$/.test(r.value);) o.push(r), r = r.rightSibling;
        const n = o.map((e => e.value)).join(""),
            s = n ? function(e, t) {
                var a, i;
                if ("\\" === t) return [];
                if (!t.startsWith("\\")) return [];
                const o = [];
                for (const e in M) e.startsWith(t) && !M[e].infix && o.push({
                    match: e,
                    frequency: null !== (a = M[e].frequency) && void 0 !== a ? a : 0
                });
                for (const e in _) e.startsWith(t) && o.push({
                    match: e,
                    frequency: null !== (i = _[e].frequency) && void 0 !== i ? i : 0
                });
                const r = t.substring(1);
                for (const t of Object.keys(e.options.macros)) t.startsWith(r) && o.push({
                    match: "\\" + t,
                    frequency: 0
                });
                return o.sort(((e, t) => {
                    var a, i;
                    return e.frequency === t.frequency ? e.match.length === t.match.length ? e.match < t.match ? -1 : 1 : e.match.length - t.match.length : (null !== (a = t.frequency) && void 0 !== a ? a : 0) - (null !== (i = e.frequency) && void 0 !== i ? i : 0)
                })), o.map((e => e.match))
            }(e, n) : [];
        if (0 === s.length) return /^\\[a-zA-Z\*]+$/.test(n) && o.forEach((e => {
            e.isError = !0
        })), void oo(e);
        e.suggestionIndex = null !== (a = null == t ? void 0 : t.atIndex) && void 0 !== a ? a : 0, e.suggestionIndex < 0 && (e.suggestionIndex = s.length - 1);
        const l = s[e.suggestionIndex % s.length];
        if (l !== n) {
            const t = o[o.length - 1];
            t.parent.addChildrenAfter([...l.slice(n.length - l.length)].map((t => new ta(t, e, {
                isSuggestion: !0
            }))), t), no(e)
        }! function(e, t) {
            if (0 === t.length || !1 === e.options.enablePopover) return void oo(e);
            t = t.slice(0, 10);
            let a = "<ul>";
            for (const i of t) {
                const t = i,
                    o = to(e, i),
                    r = Oi(e.keybindings, t).join("<br>");
                a += `<li role="button" data-command="${t}"><span class="ML__popover__latex">${t}</span><span class="ML__popover__command">${o}</span>`, r && (a += `<span class="ML__popover__keybinding">${r}</span>`), a += "</li>"
            }
            a += "</ul>", e.popover = function(e, t) {
                return e.popover ? (e.popover.innerHTML = e.options.createHTML(t), e.popover) : (e.popover = ri("mathlive-popover-panel"), void 0 === Yi && (Yi = Si(Ri).toString(36)), Qi = Mi(null, Ri, Yi), eo = Mi(null, Ii, Si(Ii).toString(36)), e.popover.innerHTML = e.options.createHTML(t), e.popover)
            }(e, a);
            const i = e.popover.querySelectorAll("ul li");
            for (const t of i) t.addEventListener("pointerdown", (e => {
                e.preventDefault()
            })), t.addEventListener("click", (a => {
                Zi(e, "reject"), Oa.insert("math", e.model, t.dataset.command, {
                    selectionMode: "placeholder",
                    format: "latex"
                }), e.dirty = !0, e.scrollIntoView(), e.focus()
            }));
            setTimeout((() => {
                const t = li(e.field);
                t && io(e, t), e.popover && (e.popover.classList.add("is-visible"), e.popoverVisible = !0)
            }), 32)
        }(e, s)
    }

    function Gi(e) {
        const [t, a] = Ji(e, {
            before: e.position
        });
        if (void 0 === t || void 0 === a) return !1;
        let i = !1;
        return e.getAtoms([t, a]).forEach((e => {
            e.isSuggestion && (e.isSuggestion = !1, i = !0)
        })), i
    }

    function Zi(e, t = "accept", a) {
        var i, o;
        oo(e);
        const r = e.model.atoms.find((e => e instanceof aa));
        if (!r) return !1;
        if ("accept-suggestion" === t) {
            const t = Wi(e.model).filter((e => e.isSuggestion));
            if (0 === t.length) return !1;
            for (const e of t) e.isSuggestion = !1;
            return e.model.position = e.model.offsetOf(t[t.length - 1]), !0
        }
        const n = Wi(e.model).filter((e => !e.isSuggestion)).map((e => e.value)).join(""),
            s = r.leftSibling;
        return r.parent.removeChild(r), e.model.position = e.model.offsetOf(s), e.mode = null !== (i = null == a ? void 0 : a.mode) && void 0 !== i ? i : "math", "reject" === t || (Oa.insert("math", e.model, n, {
            selectionMode: null !== (o = null == a ? void 0 : a.selectItem) && void 0 !== o && o ? "item" : "placeholder",
            format: "latex"
        }), e.snapshot(), e.model.announce("replacement")), !0
    }
    let Yi;
    new class extends Oa {
        createAtom(e, t, a) {
            return new ta(e, t)
        }
        onPaste(e, t) {
            if (!t.clipboardData) return !1;
            let a = t.clipboardData.getData("text/x-latex");
            return a || (a = t.clipboardData.getData("text/plain")), !(!a || !ji(e.model, {
                inputType: "insertFromPaste",
                data: a
            }) || (e.snapshot(), this.insert(e.model, a) && (Hi(e.model, {
                inputType: "insertFromPaste"
            }), no(e)), t.preventDefault(), t.stopPropagation(), 0))
        }
        insert(e, t, a) {
            if (!ji(e, {
                    data: t,
                    inputType: "insertText"
                })) return !1;
            a || (a = {}), a.insertionMode || (a.insertionMode = "replaceSelection"), a.selectionMode || (a.selectionMode = "placeholder");
            const {
                suppressChangeNotifications: i
            } = e;
            a.suppressChangeNotifications && (e.suppressChangeNotifications = !0);
            const o = e.suppressChangeNotifications;
            e.suppressChangeNotifications = !0, "replaceSelection" !== a.insertionMode || e.selectionIsCollapsed ? "replaceAll" === a.insertionMode ? (e.root.setChildren([], "body"), e.position = 0) : "insertBefore" === a.insertionMode ? e.collapseSelection("backward") : "insertAfter" === a.insertionMode && e.collapseSelection("forward") : e.deleteAtoms(Ca(e.selection));
            const r = [];
            for (const a of t) D.test(a) && r.push(new ta(a, e.mathfield));
            let n = e.at(e.position);
            if (n instanceof aa && (n = n.lastChild), !(n.parent instanceof aa)) {
                const t = new aa("", e.mathfield);
                n.parent.addChildAfter(t, n), n = t.firstChild
            }
            const s = n.parent.addChildrenAfter(r, n);
            return e.suppressChangeNotifications = o, "before" === a.selectionMode || ("item" === a.selectionMode ? e.setSelection(e.anchor, e.offsetOf(s)) : s && (e.position = e.offsetOf(s))), Hi(e, {
                data: t,
                inputType: "insertText"
            }), e.suppressChangeNotifications = i, !0
        }
        constructor() {
            super("latex")
        }
    };
    let Qi = null,
        eo = null;

    function to(e, t) {
        const a = e,
            i = new lt("root", a);
        return i.body = Nt(t, a, {
            parseMode: "math"
        }), je(Fe(Ve(new Ne(i.render(new Ae({
            registers: a.registers
        }, {
            fontSize: 5
        }, "displaystyle")), {
            classes: "ML__base"
        }))), {
            classes: "ML__mathlive"
        }).toMarkup()
    }

    function ao(e, t) {
        var a;
        if (e.element && e.element.mathfield === e && e.popover && e.popoverVisible)
            if (null == t ? void 0 : t.deferred) setTimeout((() => ao(e)), 100);
            else if ("latex" !== (null === (a = e.model.at(e.model.position)) || void 0 === a ? void 0 : a.type)) oo(e);
        else {
            const t = li(e.field);
            t && io(e, t)
        }
    }

    function io(e, t) {
        if (r(), !e.popover || !e.popoverVisible) return;
        const a = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight,
            i = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
            o = window.innerWidth - document.documentElement.clientWidth,
            n = window.innerHeight - document.documentElement.clientHeight,
            s = e.virtualKeyboard.height;
        t.x + e.popover.offsetWidth / 2 > i - o ? e.popover.style.left = i - e.popover.offsetWidth - o + "px" : t.x - e.popover.offsetWidth / 2 < 0 ? e.popover.style.left = "0" : e.popover.style.left = t.x - e.popover.offsetWidth / 2 + "px", t.y + e.popover.offsetHeight + 5 > a - n - s ? (e.popover.classList.add("ML__popover--reverse-direction"), e.popover.style.top = t.y - t.height - e.popover.offsetHeight - 5 + "px") : (e.popover.classList.remove("ML__popover--reverse-direction"), e.popover.style.top = `${t.y+5}px`)
    }

    function oo(e) {
        e.suggestionIndex = 0, e.popoverVisible = !1, e.popover && (e.popover.classList.remove("is-visible"), e.popover.innerHTML = "")
    }

    function ro(e) {
        let t = 0;
        for (let a = 0; a < e.length; a++) t = 31 * t + e.charCodeAt(a), t |= 0;
        return Math.abs(t)
    }

    function no(e, t) {
        e.dirty || (e.dirty = !0, requestAnimationFrame((() => {
            si(e) && e.dirty && (e.atomBoundsCache = new Map, so(e, t), e.atomBoundsCache = void 0)
        })))
    }

    function so(e, t) {
        var a;
        if (r(), !si(e)) return;
        t = null != t ? t : {};
        const {
            model: i
        } = e;
        i.root.caret = "", i.root.isSelected = !1, i.root.containsCaret = !0;
        for (const e of i.atoms) e.caret = "", e.isSelected = !1, e.containsCaret = !1;
        const o = !e.options.readOnly && e.hasFocus();
        if (i.selectionIsCollapsed) i.at(i.position).caret = o ? e.mode : "";
        else {
            const e = i.getAtoms(i.selection, {
                includeChildren: !0
            });
            for (const t of e) t.isSelected = !0
        }
        if (o) {
            let e = i.at(i.position).parent;
            for (; e;) e.containsCaret = !0, e = e.parent
        }
        const n = function(e, t) {
                var a;
                return t = null != t ? t : {}, je(Ve(e.model.root.render(new Ae({
                    registers: e.registers,
                    atomIdsSettings: {
                        seed: t.forHighlighting ? ro(lt.serialize(e.model.root, {
                            expandMacro: !1,
                            defaultMode: e.options.defaultMode
                        })) : "random",
                        groupNumbers: null !== (a = t.forHighlighting) && void 0 !== a && a
                    },
                    renderPlaceholder: e.options.readOnly ? (t, a) => {
                        if (a.placeholderId) {
                            const i = e.getPlaceholderField(a.placeholderId);
                            return a.createMathfieldBox(t, i, a.placeholderId)
                        }
                        return a.createBox(t)
                    } : void 0
                }, {
                    fontSize: 5,
                    letterShapeStyle: e.options.letterShapeStyle
                }, "inline-math" === e.options.defaultMode ? "textstyle" : "displaystyle")), e.options.horizontalSpacingScale), {
                    classes: "ML__mathlive",
                    attributes: {
                        translate: "no",
                        "aria-hidden": "true"
                    }
                })
            }(e, t),
            s = e.field,
            l = s.classList.contains("ML__focused");
        l && !o ? s.classList.remove("ML__focused") : !l && o && s.classList.add("ML__focused"), s.innerHTML = e.options.createHTML(n.toMarkup()), e.fieldContent = s.querySelector(".ML__mathlive"), e.accessibleNode.innerHTML = e.options.createHTML('<math xmlns="http://www.w3.org/1998/Math/MathML">' + Ua(i.root, e.options) + "</math>"), lo(e), e.options.readOnly && e.attachNestedMathfield(), null !== (a = t.interactive) && void 0 !== a && a || setTimeout((() => lo(e)), 32), e.dirty = !1
    }

    function lo(e) {
        r();
        const t = e.field;
        if (!t) return;
        for (const e of t.querySelectorAll(".ML__selection, .ML__contains-highlight")) e.remove();
        if (!e.hasFocus()) return;
        const a = e.model,
            i = parseFloat(getComputedStyle(t).width);
        let o = t.getBoundingClientRect().width / i;
        if (o = isNaN(o) ? 1 : o, a.selectionIsCollapsed) {
            setTimeout((() => ao(e)), 32);
            let i = a.at(a.position);
            for (; i && (!i.containsCaret || !i.displayContainsHighlight);) i = i.parent;
            if ((null == i ? void 0 : i.containsCaret) && i.displayContainsHighlight) {
                const a = ci(e, pi(e, i));
                if (a) {
                    a.left /= o, a.right /= o, a.top /= o, a.bottom /= o;
                    const e = document.createElement("div");
                    e.classList.add("ML__contains-highlight"), e.style.position = "absolute", e.style.left = `${a.left}px`, e.style.top = `${a.top}px`, e.style.width = `${Math.ceil(a.right-a.left)}px`, e.style.height = `${Math.ceil(a.bottom-a.top-1)}px`, t.insertBefore(e, t.childNodes[0])
                }
            }
        } else
            for (const a of function(e) {
                    let t = [];
                    for (const a of e) {
                        let e = !1;
                        for (const i of t)
                            if (a.left === i.left && a.right === i.right && a.top === i.top && a.bottom === i.bottom) {
                                e = !0;
                                break
                            } e || t.push(a)
                    }
                    e = t, t = [];
                    for (const a of e) {
                        let i = 0;
                        for (const t of e)
                            if (a.left >= t.left && a.right <= t.right && a.top >= t.top && a.bottom <= t.bottom && (i += 1, i > 1)) break;
                        1 === i && t.push(a)
                    }
                    return t
                }(hi(e, {
                    excludeAtomsWithBackground: !0
                }))) {
                a.left /= o, a.right /= o, a.top /= o, a.bottom /= o;
                const e = document.createElement("div");
                e.classList.add("ML__selection"), e.style.position = "absolute", e.style.left = `${a.left}px`, e.style.top = `${a.top}px`, e.style.width = `${Math.ceil(a.right-a.left)}px`, e.style.height = `${Math.ceil(a.bottom-a.top-1)}px`, t.insertBefore(e, t.childNodes[0])
            }
    }
    const co = {};

    function uo(e, t) {
        t = null != t ? t : {
            target: "mathfield",
            canUndo: !1
        };
        for (const a of Object.keys(e)) co[a] = {
            ...t,
            fn: e[a]
        }
    }

    function po(e) {
        var t;
        let a;
        return a = i(e) ? e[0] : e, a = a.replace(/-\w/g, (e => e[1].toUpperCase())), null === (t = co[a]) || void 0 === t ? void 0 : t.target
    }

    function ho(e, t, a) {
        return t + ai(a, {
            ...e,
            textToSpeechMarkup: "",
            textToSpeechRulesOptions: {
                ...e.textToSpeechRulesOptions,
                markup: "none"
            }
        })
    }

    function mo(e, t) {
        var a, i, r;
        if (o() && (null != t || (t = null !== (a = Cn().config) && void 0 !== a ? a : {}), t))
            if (t.speechEngine && "local" !== t.speechEngine)
                if ("amazon" === t.speechEngine) {
                    if ("AWS" in window) {
                        const a = new globalThis.AWS.Polly({
                                apiVersion: "2016-06-10"
                            }),
                            o = {
                                OutputFormat: "mp3",
                                VoiceId: null !== (i = t.speechEngineVoice) && void 0 !== i ? i : "Joanna",
                                Engine: ["Amy", "Emma", "Brian", "Ivy", "Joanna", "Kendra", "Kimberly", "Salli", "Joey", "Justin", "Matthew"].includes(null !== (r = t.speechEngineVoice) && void 0 !== r ? r : "Joanna") ? "neural" : "standard",
                                Text: e,
                                TextType: "ssml"
                            };
                        a.synthesizeSpeech(o, ((e, t) => {
                            if (e);
                            else if (null == t ? void 0 : t.AudioStream) {
                                const e = new Uint8Array(t.AudioStream),
                                    a = new Blob([e.buffer], {
                                        type: "audio/mpeg"
                                    }),
                                    i = URL.createObjectURL(a);
                                new Audio(i).play().catch((e => {}))
                            }
                        }))
                    }
                } else t.speechEngine;
        else {
            const t = new SpeechSynthesisUtterance(e);
            window.speechSynthesis.speak(t)
        }
    }

    function fo(e) {
        if (e && (e.classList.remove("ML__highlight"), e.children))
            for (const t of e.children) fo(t)
    }

    function yo(e, t) {
        var a;
        e && (t && (null === (a = e.dataset) || void 0 === a ? void 0 : a.atomId) !== t ? (e.classList.remove("ML__highlight"), e.children && e.children.length > 0 && [...e.children].forEach((e => {
            e instanceof HTMLElement && yo(e, t)
        }))) : (e.classList.add("ML__highlight"), e.children && e.children.length > 0 && [...e.children].forEach((e => {
            e instanceof HTMLElement && yo(e)
        }))))
    }

    function bo(e, t, a) {
        var i;
        if (!o()) return;
        if (null != a || (a = Cn().config), "amazon" !== a.speechEngine) return void(a.speakHook && a.speakHook(t, a));
        if (!globalThis.AWS) return;
        const r = new globalThis.AWS.Polly({
                apiVersion: "2016-06-10"
            }),
            n = {
                OutputFormat: "json",
                VoiceId: null !== (i = a.speechEngineVoice) && void 0 !== i ? i : "Joanna",
                Engine: "standard",
                Text: t,
                TextType: "ssml",
                SpeechMarkTypes: ["ssml"]
            };
        Cn().readAloudElement = e, r.synthesizeSpeech(n, ((e, t) => {
            if (e) return;
            if (!(null == t ? void 0 : t.AudioStream)) return;
            const a = new TextDecoder("utf-8").decode(new Uint8Array(t.AudioStream));
            Cn().readAloudMarks = a.split("\n").map((e => e ? JSON.parse(e) : {})), Cn().readAloudTokens = [];
            for (const e of Cn().readAloudMarks) e.value && Cn().readAloudTokens.push(e.value);
            Cn().readAloudCurrentMark = "", n.OutputFormat = "mp3", n.SpeechMarkTypes = [], r.synthesizeSpeech(n, ((e, t) => {
                if (e) return;
                if (!(null == t ? void 0 : t.AudioStream)) return;
                const a = new Uint8Array(t.AudioStream),
                    i = new Blob([a.buffer], {
                        type: "audio/mpeg"
                    }),
                    o = URL.createObjectURL(i),
                    r = Cn();
                r.readAloudAudio ? r.readAloudAudio.pause() : (r.readAloudAudio = new Audio, r.readAloudAudio.addEventListener("ended", (() => {
                    const e = r.readAloudMathField;
                    r.readAloudStatus = "ended", document.body.dispatchEvent(new Event("read-aloud-status-change", {
                        bubbles: !0,
                        composed: !0
                    })), e ? (so(e), r.readAloudElement = null, r.readAloudMathField = null, r.readAloudTokens = [], r.readAloudMarks = [], r.readAloudCurrentMark = "") : fo(r.readAloudElement)
                })), r.readAloudAudio.addEventListener("timeupdate", (() => {
                    let e = "";
                    const t = 1e3 * r.readAloudAudio.currentTime + 100;
                    for (const a of r.readAloudMarks) a.time < t && (e = a.value);
                    r.readAloudCurrentMark !== e && (r.readAloudCurrentToken = e, e && e === r.readAloudFinalToken ? r.readAloudAudio.pause() : (r.readAloudCurrentMark = e, yo(r.readAloudElement, r.readAloudCurrentMark)))
                }))), r.readAloudAudio.src = o, r.readAloudStatus = "playing", document.body.dispatchEvent(new Event("read-aloud-status-change", {
                    bubbles: !0,
                    composed: !0
                })), r.readAloudAudio.play()
            }))
        }))
    }

    function go(e, t) {
        var a, r, s;
        const l = vo(e, Object.keys(e));
        for (const e of Object.keys(t)) switch (e) {
            case "scriptDepth":
                if (i(t.scriptDepth)) l.scriptDepth = [t.scriptDepth[0], t.scriptDepth[1]];
                else {
                    if ("number" != typeof t.scriptDepth) throw new TypeError("Unexpected value for scriptDepth");
                    l.scriptDepth = [t.scriptDepth, t.scriptDepth]
                }
                break;
            case "locale":
                "auto" === t.locale ? l.locale = o() ? navigator.language.slice(0, 5) : "en" : l.locale = t.locale, c.locale = l.locale;
                break;
            case "strings":
                c.merge(t.strings), l.strings = c.strings;
                break;
            case "virtualKeyboardLayout":
                l.virtualKeyboardLayout = t.virtualKeyboardLayout;
                break;
            case "virtualKeyboardMode":
                const d = t.virtualKeyboardMode.toLowerCase();
                l.virtualKeyboardMode = "auto" === d ? n() ? "onfocus" : "off" : d;
                break;
            case "customVirtualKeyboardLayers":
                l.customVirtualKeyboardLayers = {
                    ...l.customVirtualKeyboardLayers,
                    ...t.customVirtualKeyboardLayers
                };
                break;
            case "customVirtualKeyboards":
                l.customVirtualKeyboards = {
                    ...l.customVirtualKeyboards,
                    ...t.customVirtualKeyboards
                };
                break;
            case "letterShapeStyle":
                "auto" === t.letterShapeStyle ? c.locale.startsWith("fr") ? l.letterShapeStyle = "french" : l.letterShapeStyle = "tex" : l.letterShapeStyle = t.letterShapeStyle;
                break;
            case "plonkSound":
                void 0 !== t.plonkSound && (l.plonkSound = t.plonkSound);
                break;
            case "keypressSound":
                null === t.keypressSound ? l.keypressSound = {
                    default: null,
                    delete: null,
                    return: null,
                    spacebar: null
                } : "string" == typeof t.keypressSound ? l.keypressSound = {
                    delete: t.keypressSound,
                    return: t.keypressSound,
                    spacebar: t.keypressSound,
                    default: t.keypressSound
                } : "object" == typeof t.keypressSound && "default" in t.keypressSound && (l.keypressSound = {
                    ...t.keypressSound
                }, l.keypressSound.delete = null !== (a = l.keypressSound.delete) && void 0 !== a ? a : t.keypressSound.default, l.keypressSound.return = null !== (r = l.keypressSound.return) && void 0 !== r ? r : t.keypressSound.default, l.keypressSound.spacebar = null !== (s = l.keypressSound.spacebar) && void 0 !== s ? s : t.keypressSound.default);
                break;
            case "computeEngine":
                l.computeEngine = t.computeEngine;
                break;
            case "virtualKeyboardContainer":
                l.virtualKeyboardContainer = t.virtualKeyboardContainer;
                break;
            case "macros":
                l.macros = J(t.macros);
                break;
            default:
                i(t[e]) ? l[e] = [...t[e]] : "object" == typeof t[e] ? l[e] = {
                    ...t[e]
                } : l[e] = t[e]
        }
        return l
    }

    function vo(e, t) {
        let a;
        a = "string" == typeof t ? [t] : void 0 === t ? Object.keys(e) : t;
        const o = {};
        for (const t of a) null === e[t] ? o[t] = null : i(e[t]) ? o[t] = [...e[t]] : "object" != typeof e[t] || e[t] instanceof Element || "computeEngine" === t ? o[t] = e[t] : o[t] = {
            ...e[t]
        };
        return "string" == typeof t ? o[t] : o
    }
    uo({
        performWithFeedback: (e, t) => function(e, t) {
            e.focus(), e.options.keypressVibration && s() && navigator.vibrate(3), "moveToNextPlaceholder" === (t = t.replace(/-\w/g, (e => e[1].toUpperCase()))) || "moveToPreviousPlaceholder" === t || "complete" === t ? e.playSound("return") : "deleteBackward" === t || "deleteForward" === t || "deletePreviousWord" === t || "deleteNextWord" === t || "deleteToGroupStart" === t || "deleteToGroupEnd" === t || "deleteToMathFieldStart" === t || "deleteToMathFieldEnd" === t ? e.playSound("delete") : e.playSound("keypress");
            const a = e.executeCommand(t);
            return e.scrollIntoView(), a
        }(e, t)
    }), uo({
        complete: Zi,
        nextSuggestion: function(e) {
            return Xi(e, {
                atIndex: e.suggestionIndex + 1
            }), !1
        },
        previousSuggestion: function(e) {
            return Xi(e, {
                atIndex: e.suggestionIndex - 1
            }), !1
        }
    }, {
        target: "mathfield",
        category: "autocomplete"
    }), uo({
        speak: (e, t, a) => function(e, t, a) {
            var i, r;
            a = null != a ? a : {
                withHighlighting: !1
            };
            const {
                model: n
            } = e, s = function(e) {
                let t = null;
                switch (e) {
                    case "all":
                    default:
                        t = n.root;
                        break;
                    case "selection":
                        t = n.getAtoms(n.selection);
                        break;
                    case "left":
                        t = n.getAtoms(n.offsetOf(n.at(n.position).leftSibling), n.position);
                        break;
                    case "right":
                        t = n.getAtoms(n.position, n.offsetOf(n.at(n.position).rightSibling));
                        break;
                    case "group":
                        t = n.getAtoms(n.getSiblingsRange(n.position));
                        break;
                    case "parent": {
                        const {
                            parent: e
                        } = n.at(n.position);
                        t = e && "root" !== e.type ? e : n.root;
                        break
                    }
                }
                return t
            }(t);
            if (null === s) return null === (r = (i = e.options).speakHook) || void 0 === r || r.call(i, function(e) {
                let t = "";
                switch (e) {
                    case "all":
                    case "group":
                    default:
                        break;
                    case "selection":
                        t = "no selection";
                        break;
                    case "left":
                        t = "at start";
                        break;
                    case "right":
                        t = "at end";
                        break;
                    case "parent":
                        t = "no parent"
                }
                return t
            }(t), e.options), !1;
            const l = {
                ...e.options
            };
            (a.withHighlighting || "amazon" === l.speechEngine) && (l.textToSpeechMarkup = globalThis.sre && "sre" === l.textToSpeechRules ? "ssml_step" : "ssml"), l.textToSpeechMarkup || /firefox/i.test(navigator.userAgent) || (l.textToSpeechMarkup = "ssml");
            const d = ai(s, l);
            return o() && a.withHighlighting ? (Cn().readAloudMathField = e, so(e, {
                forHighlighting: !0
            }), e.options.readAloudHook && e.options.readAloudHook(e.field, d, e.options)) : e.options.speakHook && e.options.speakHook(d, l), !1
        }(e, t, a)
    }, {
        target: "mathfield",
        category: "speech"
    });
    const ko = '<span style="width: 21px; margin-top: 4px;"><svg style="width: 21px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M528 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h480c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm16 336c0 8.823-7.177 16-16 16H48c-8.823 0-16-7.177-16-16V112c0-8.823 7.177-16 16-16h480c8.823 0 16 7.177 16 16v288zM168 268v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-336 80v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm384 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zM120 188v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-96 152v-8c0-6.627-5.373-12-12-12H180c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h216c6.627 0 12-5.373 12-12z"/></svg></span>';

    function xo() {
        var e, t, a;
        return {
            readOnly: !1,
            createHTML: e => e,
            fontsDirectory: "./fonts",
            soundsDirectory: "./sounds",
            computeEngine: void 0,
            defaultMode: "math",
            macros: H(),
            registers: {},
            colorMap: g,
            backgroundColorMap: v,
            horizontalSpacingScale: 1,
            letterShapeStyle: c.locale.startsWith("fr") ? "french" : "tex",
            smartMode: !1,
            smartFence: !0,
            smartSuperscript: !0,
            scriptDepth: [1 / 0, 1 / 0],
            removeExtraneousParentheses: !0,
            mathModeSpace: "",
            decimalSeparator: ".",
            fractionNavigationOrder: "numerator-denominator",
            placeholderSymbol: "▢",
            enablePopover: !0,
            locale: c.locale,
            strings: c.strings,
            keybindings: qi,
            inlineShortcuts: Da,
            inlineShortcutTimeout: 0,
            virtualKeyboardToggleGlyph: ko,
            virtualKeyboardMode: "auto",
            virtualKeyboards: "all",
            virtualKeyboardLayout: "auto",
            customVirtualKeyboardLayers: {},
            customVirtualKeyboards: {},
            virtualKeyboardTheme: o() && /android|cros/i.test(navigator.userAgent) ? "material" : "apple",
            keypressVibration: !0,
            keypressSound: null,
            plonkSound: null,
            virtualKeyboardToolbar: "default",
            virtualKeyboardContainer: null !== (t = null === (e = globalThis.document) || void 0 === e ? void 0 : e.body) && void 0 !== t ? t : null,
            useSharedVirtualKeyboard: !1,
            sharedVirtualKeyboardTargetOrigin: null === (a = globalThis.window) || void 0 === a ? void 0 : a.origin,
            originValidator: "same-origin",
            textToSpeechRules: "mathlive",
            textToSpeechMarkup: "",
            textToSpeechRulesOptions: {},
            speechEngine: "local",
            speechEngineVoice: "Joanna",
            speechEngineRate: "100%",
            speakHook: mo,
            readAloudHook: bo,
            onInlineShortcut: () => "",
            onExport: Ea,
            value: ""
        }
    }

    function wo(e) {
        return "inline-math" === e.defaultMode ? "math" : e.defaultMode
    }
    var _o, So, Mo = '@keyframes ML__caret-blink{0%,to{opacity:1}50%{opacity:0}}.ML__caret:after{animation:ML__caret-blink 1.05s step-end infinite forwards;border:none;border-radius:2px;border-right:2px solid var(--caret-color,var(--ML__caret-color));content:"";left:-1px;margin-right:-2px;position:relative}.ML__text-caret:after{animation:ML__caret-blink 1.05s step-end infinite forwards;border:none;border-radius:1px;border-right:1px solid var(--caret-color,var(--ML__caret-color));content:"";left:0;margin-right:-1px;position:relative}.ML__latex-caret:after{animation:ML__caret-blink 1.05s step-end infinite forwards;border:none;color:var(--caret-color,var(--ML__caret-color));content:"_";margin-right:calc(-1ex - 2px);position:relative}.ML__container{--ML__selection-background-color:hsl(var(--hue,212),97%,85%);--ML__text-highlight-background-color:hsla(var(--hue,212),40%,50%,0.1);--ML__contains-highlight-background-color:hsl(var(--hue,212),40%,95%);--ML__selection-color:currentColor;--ML__caret-color:hsl(var(--hue,212),40%,49%);--ML__smart-fence-color:currentColor;--ML__latex-color:var(--primary,hsl(var(--hue,212),40%,50%));--ML__placeholder-color:hsl(var(--hue,212),40%,49%);align-items:flex-end;display:flex;flex-flow:row;isolation:isolate;justify-content:space-between;min-height:39px;touch-action:none;width:100%}@media (prefers-color-scheme:dark){.ML__container{--ML__selection-background-color:hsl(var(--hue,212),25%,45%);--ML__text-highlight-background-color:hsla(var(--hue,212),40%,50%,0.2);--ML__contains-highlight-background-color:hsl(var(--hue,212),5%,34%);--ML__caret-color:hsl(var(--hue,212),60%,69%);--ML__latex-color:var(--primary,hsl(var(--hue,212),40%,50%));--ML__placeholder-color:hsl(var(--hue,212),60%,69%)}}.ML__content{align-items:center;align-self:center;display:flex;overflow:hidden;padding:2px 0 2px 1px;position:relative;width:100%}.ML__virtual-keyboard-toggle{box-sizing:border-box;display:none}.ML__virtual-keyboard-toggle>span{align-items:center;align-self:center;display:flex}.ML__virtual-keyboard-toggle.is-visible{fill:currentColor;align-items:center;align-self:center;background:transparent;border:1px solid transparent;border-radius:8px;color:var(--primary,hsl(var(--hue,212),40%,50%));cursor:pointer;display:flex;flex-direction:column;flex-shrink:0;height:34px;justify-content:center;margin-right:4px;padding:0;transition:background .2s cubic-bezier(.64,.09,.08,1);width:34px}.ML__virtual-keyboard-toggle.is-visible:hover{fill:currentColor;background:hsla(0,0%,70%,.5);border-radius:8px;color:#333}.ML__textarea__textarea{clip:rect(0 0 0 0);border:none;display:inline-block;font-family:KaTeX_Main;font-size:1em;height:1px;outline:none;position:absolute;resize:none;transform:scale(0);width:1px}.ML__focused .ML__text{background:var(--highlight-text,var(--ML__text-highlight-background-color))}.ML__smart-fence__close{color:var(--smart-fence-color,var(--ML__smart-fence-color));opacity:var(--smart-fence-opacity,.5)}.ML__focused .ML__selection{background:var(--selection-background-color-focused,var(--selection-background-color,var(--ML__selection-background-color)))!important}.ML__focused .ML__selected,.ML__focused .ML__selected .ML__contains-caret,.ML__focused .ML__selected .ML__placeholder,.ML__focused .ML__selected .ML__smart-fence__close{color:var(--selection-color-focused,var(--selection-color,var(--ML__selection-color)))!important}.ML__selection{background:var(--selection-background-color,var(--ML__selection-background-color))!important;box-sizing:border-box}.ML__selected,.ML__selected .ML__contains-caret,.ML__selected .ML__placeholder,.ML__selected .ML__smart-fence__close{color:var(--selection-color,var(--ML__selection-color));opacity:1}.ML__contains-caret .ML__sqrt-line,.ML__contains-caret .ML__sqrt-sign,.ML__contains-caret.ML__close,.ML__contains-caret.ML__open,.ML__contains-caret>.ML__close,.ML__contains-caret>.ML__open{color:var(--caret-color,var(--ML__caret-color))}.ML__contains-highlight{background:var(--contains-highlight-backround-color,var(--ML__contains-highlight));box-sizing:border-box}.ML__latex{color:var(--latex-color,var(--ML__latex-color));font-family:IBM Plex Mono,Source Code Pro,Consolas,Roboto Mono,Menlo,Bitstream Vera Sans Mono,DejaVu Sans Mono,Monaco,Courier,monospace;font-weight:400}.ML__suggestion{opacity:.5}.ML__virtual-keyboard-toggle.is-visible.is-pressed:hover{fill:currentColor;background:hsl(var(--hue,212),25%,35%);color:#fafafa}.ML__virtual-keyboard-toggle:focus{border:2px solid var(--primary,hsl(var(--hue,212),40%,50%));border-radius:8px;outline:none}.ML__virtual-keyboard-toggle.is-active,.ML__virtual-keyboard-toggle.is-active:hover,.ML__virtual-keyboard-toggle.is-pressed{fill:currentColor;background:hsl(var(--hue,212),25%,35%);color:#fafafa}.ML__tooltip-container{position:relative;transform:scale(0)}.ML__tooltip-container .ML__tooltip-content{background:#616161;border-radius:8px;box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.2);color:#fff;display:inline-table;max-width:400px;opacity:0;padding:12px;position:fixed;transition:opacity .15s cubic-bezier(.4,0,1,1);visibility:hidden;width:max-content;z-index:2}.ML__tooltip-container .ML__tooltip-content .ML__text{white-space:normal}.ML__tooltip-container .ML__tooltip-content .ML__base{display:contents}.ML__tooltip-container:hover .ML__tooltip-content{font-size:.75em;opacity:1;transform:scale(1) translateY(3em);visibility:visible}[data-ML__tooltip]{position:relative}[data-ML__tooltip][data-placement=top]:after{bottom:100%;top:inherit}[data-ML__tooltip]:after{background:#616161;border-radius:2px;box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.2);color:#fff;content:attr(data-ML__tooltip);display:none;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:12px;font-weight:400;max-width:200px;opacity:0;padding:8px;position:absolute;right:110%;text-align:center;transform:scale(.5);transition:all .15s cubic-bezier(.4,0,1,1);width:max-content;z-index:2}@media only screen and (max-width:767px){[data-ML__tooltip]:after{font-size:16px;padding:8px 16px}}:not(.tracking) [data-ML__tooltip]:hover{position:relative}:not(.tracking) [data-ML__tooltip]:hover:after{display:inline-table;opacity:1;transform:scale(1);visibility:visible}[data-ML__tooltip][data-delay]:after{transition-delay:0s}[data-ML__tooltip][data-delay]:hover:after{transition-delay:1s}';
    let Lo = null;

    function Co(e) {
        if (/^(?:[a-z+]+:)?\/\//i.test(e)) return new URL(e).href;
        if (null === Lo) try {
            const e = new XMLHttpRequest;
            e.open("HEAD", Ao, !1), e.send(null), 200 === e.status && (Lo = e.responseURL)
        } catch (e) {}
        return Lo ? new URL(e, Lo).href : ""
    }
    const Ao = (null === (So = null === (_o = null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) || void 0 === _o ? void 0 : _o.currentScript) || void 0 === So ? void 0 : So.src) || function() {
        const e = String((new Error).stack).replace(/^Error.*\n/, "").split("\n");
        if (0 === e.length) return "";
        let t = e[1],
            a = t.match(/http.*\.ts[\?:]/);
        return a && (t = e[2]), a = t.match(/(https?:.*):[0-9]+:[0-9]+/), a || (a = t.match(/at (.*(\.ts))[\?:]/), a || (a = t.match(/at (.*(\.mjs|\.js))[\?:]/))), a ? a[1] : ""
    }();
    async function Do(e) {
        var t;
        if (o() && !document.body.classList.contains("ML__fonts-loading") && (null === (t = getComputedStyle(document.documentElement).getPropertyValue("--ML__static-fonts")) || void 0 === t || !t) && (document.body.classList.remove("ML__fonts-did-not-load"), "fonts" in document)) {
            const t = ["KaTeX_Main", "KaTeX_Math", "KaTeX_AMS", "KaTeX_Caligraphic", "KaTeX_Fraktur", "KaTeX_SansSerif", "KaTeX_Script", "KaTeX_Typewriter", "KaTeX_Size1", "KaTeX_Size2", "KaTeX_Size3", "KaTeX_Size4"],
                a = Array.from(document.fonts).map((e => e.family));
            if (t.every((e => a.includes(e)))) return;
            const i = Co(null != e ? e : "./fonts");
            if (!i) return;
            document.body.classList.add("ML__fonts-loading");
            const o = [
                ["KaTeX_Main-Regular"],
                ["KaTeX_Main-BoldItalic", {
                    style: "italic",
                    weight: "bold"
                }],
                ["KaTeX_Main-Bold", {
                    weight: "bold"
                }],
                ["KaTeX_Main-Italic", {
                    style: "italic"
                }],
                ["KaTeX_Math-Italic", {
                    style: "italic"
                }],
                ["KaTeX_Math-BoldItalic", {
                    style: "italic",
                    weight: "bold"
                }],
                ["KaTeX_AMS-Regular"],
                ["KaTeX_Caligraphic-Regular"],
                ["KaTeX_Caligraphic-Bold", {
                    weight: "bold"
                }],
                ["KaTeX_Fraktur-Regular"],
                ["KaTeX_Fraktur-Bold", {
                    weight: "bold"
                }],
                ["KaTeX_SansSerif-Regular", {
                    style: "italic"
                }],
                ["KaTeX_SansSerif-Bold", {
                    weight: "bold"
                }],
                ["KaTeX_SansSerif-Italic", {
                    style: "italic"
                }],
                ["KaTeX_Script-Regular"],
                ["KaTeX_Typewriter-Regular"],
                ["KaTeX_Size1-Regular"],
                ["KaTeX_Size2-Regular"],
                ["KaTeX_Size3-Regular"],
                ["KaTeX_Size4-Regular"]
            ].map((e => function(e, t, a = {}) {
                return new FontFace(e, `url(${t}.woff2) format('woff2')`, a)
            }(e[0].replace(/-[a-zA-Z]+$/, ""), i + "/" + e[0], e[1])));
            try {
                (await Promise.all(o.map((e => {
                    try {
                        return e.load()
                    } catch {}
                })))).forEach((e => document.fonts.add(e)))
            } catch (e) {
                document.body.classList.add("ML__fonts-did-not-load")
            }
            document.body.classList.remove("ML__fonts-loading")
        }
    }

    function To(e) {
        return "number" == typeof e && !Number.isNaN(e)
    }

    function zo(e) {
        return Array.isArray(e) && 2 === e.length
    }

    function Bo(e) {
        return null != e && "object" == typeof e && "ranges" in e && Array.isArray(e.ranges)
    }
    const Ko = {
            "\\ne": "≠",
            "\\neq": "≠",
            "−": "-",
            "-": "-",
            "\\alpha": "alpha",
            "\\beta": "beta",
            "\\gamma": "gamma",
            "\\delta": "delta",
            "\\epsilon": "epsilon",
            "\\varepsilon": "varepsilon",
            "\\zeta": "zeta",
            "\\eta": "eta",
            "\\theta": "theta",
            "\\vartheta": "vartheta",
            "\\iota": "iota",
            "\\kappa": "kappa",
            "\\lambda": "lambda",
            "\\mu": "mu",
            "\\nu": "nu",
            "\\xi": "xi",
            "\\pi": "pi",
            "\\rho": "rho",
            "\\sigma": "sigma",
            "\\tau": "tau",
            "\\upsilon": "upsilon",
            "\\phi": "phi",
            "\\varphi": "varphi",
            "\\chi": "chi",
            "\\psi": "psi",
            "\\omega": "omega",
            "\\Gamma": "Gamma",
            "\\Delta": "Delta",
            "\\Theta": "Theta",
            "\\Lambda": "Lambda",
            "\\Xi": "Xi",
            "\\Pi": "Pi",
            "\\Sigma": "Sigma",
            "\\Phi": "Phi",
            "\\Psi": "Psi",
            "\\Omega": "Omega",
            "\\exponentialE": "e",
            "\\imaginaryI": "i",
            "\\imaginaryJ": "j",
            "\\!": " ",
            "\\,": " ",
            "\\:": " ",
            "\\;": " ",
            "\\enskip": " ",
            "\\enspace": " ",
            "\\qquad": " ",
            "\\quad": " "
        },
        qo = {
            "\\pm": "+-",
            "\\times": "xx",
            "\\colon": ":",
            "\\vert": "|",
            "\\Vert": "||",
            "\\mid": "|",
            "\\lbrace": "{",
            "\\rbrace": "}",
            "\\lparen": "(",
            "\\rparen": ")",
            "\\langle": "(:",
            "\\rangle": ":)"
        };

    function $o(e) {
        var t, a, o, r, n, s, l, d, c, u, p, h, m;
        if (!e) return "";
        if (i(e)) {
            if (0 === e.length) return "";
            if ("first" === e[0].type && (e = e.slice(1)), 0 === e.length) return "";
            let a = "";
            if ("latex" === e[0].mode)
                for (const t of e) a += $o(t);
            else if ("text" === e[0].mode) {
                let i = 0;
                for (a = '"';
                    "text" === (null === (t = e[i]) || void 0 === t ? void 0 : t.mode);) a += e[i].body ? $o(e[i].body) : e[i].value, i++;
                a += '"' + $o(e.slice(i))
            } else if ("math" === e[0].mode) {
                let t = 0;
                for (; e[t] && "math" === e[t].mode;) a += $o(e[t]), t++;
                a += $o(e.slice(t))
            }
            return a.trim()
        }
        if ("text" === e.mode) return '"' + e.value + '"';
        let f = "";
        const {
            command: y
        } = e;
        let b;
        switch (e.type) {
            case "first":
                return "";
            case "group":
            case "root":
                f = null !== (a = Ko[y]) && void 0 !== a ? a : $o(e.body);
                break;
            case "genfrac": {
                const t = e;
                (t.leftDelim || t.rightDelim) && (f += "." !== t.leftDelim && t.leftDelim ? t.leftDelim : "{:"), t.hasBarLine ? (f += "(", f += $o(t.above), f += ")/(", f += $o(t.below), f += ")") : (f += "(" + $o(t.above) + "),", f += "(" + $o(t.below) + ")"), (t.leftDelim || t.rightDelim) && (f += "." !== t.rightDelim && t.rightDelim ? t.rightDelim : "{:")
            }
            break;
            case "surd":
                f += e.hasEmptyBranch("above") ? "sqrt(" + $o(e.body) + ")" : "root(" + $o(e.above) + ")(" + $o(e.body) + ")";
                break;
            case "latex":
                f = e.value;
                break;
            case "leftright": {
                const t = e;
                f += "." !== t.leftDelim && t.leftDelim ? t.leftDelim : "{:", f += $o(t.body), f += "." !== t.rightDelim && t.rightDelim ? t.rightDelim : ":}"
            }
            break;
            case "sizeddelim":
            case "delim":
            case "overlap":
            case "overunder":
            case "box":
                break;
            case "mord":
                f = null !== (r = null !== (o = Ko[y]) && void 0 !== o ? o : y) && void 0 !== r ? r : "string" == typeof e.value ? e.value : "", f.startsWith("\\") && (f += " "), b = y ? y.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null, b ? f = String.fromCodePoint(Number.parseInt("0x" + b[1])) : f.length > 0 && f.startsWith("\\") && (f = "string" == typeof e.value ? e.value.charAt(0) : e.command);
                break;
            case "mbin":
            case "mrel":
            case "minner":
                f = null !== (s = null !== (n = Ko[y]) && void 0 !== n ? n : qo[y]) && void 0 !== s ? s : e.value;
                break;
            case "mopen":
            case "mclose":
                f += e.value;
                break;
            case "mpunct":
                f = null !== (l = qo[y]) && void 0 !== l ? l : y;
                break;
            case "mop":
                "​" !== e.value && (f = "", f += "\\operatorname" === y ? $o(e.body) : null !== (d = e.value) && void 0 !== d ? d : y, f += " ");
                break;
            case "array":
                const t = e.array,
                    i = e.environmentName,
                    g = null !== (c = {
                        bmatrix: ["[", "]"],
                        "bmatrix*": ["[", "]"]
                    } [i]) && void 0 !== c ? c : ["(", ")"],
                    v = [];
                for (const e of t) {
                    const t = [];
                    for (const a of e) t.push(g[0] + $o(a) + g[1]);
                    v.push(t.join(","))
                }
                const k = null !== (u = {
                    bmatrix: ["[", "]"],
                    "bmatrix*": ["[", "]"],
                    cases: ["{", ":}"]
                } [i]) && void 0 !== u ? u : ["(", ")"];
                f = k[0] + v.join(",") + k[1];
                break;
            case "spacing":
                f = null !== (p = Ko[y]) && void 0 !== p ? p : " ";
                break;
            case "enclose":
                f = "(" + $o(e.body) + ")";
                break;
            case "space":
                f = " ";
                break;
            case "msubsup":
                f = "";
                break;
            case "macro":
                f = null !== (m = null !== (h = Ko[y]) && void 0 !== h ? h : qo[y]) && void 0 !== m ? m : $o(e.body)
        }
        if (!e.hasEmptyBranch("subscript")) {
            f += "_";
            const t = $o(e.subscript);
            f += t.length > 1 ? "(" + t + ")" : t
        }
        if (!e.hasEmptyBranch("superscript")) {
            f += "^";
            const t = $o(e.superscript);
            f += t.length > 1 ? "(" + t + ")" : t
        }
        return f
    }

    function Eo(e) {
        let t;
        if ("body" === e.treeBranch) t = {
            enclose: "cross out",
            leftright: "delimiter",
            surd: "square root",
            root: "math field",
            mop: "operator"
        } [e.type];
        else if ("genfrac" === e.parent.type) {
            if ("above" === e.treeBranch) return "numerator";
            if ("below" === e.treeBranch) return "denominator"
        } else "surd" === e.parent.type ? "above" === e.treeBranch && (t = "index") : "superscript" === e.treeBranch ? t = "superscript" : "subscript" === e.treeBranch && (t = "subscript");
        return null != t ? t : "parent"
    }
    class Oo {
        get atoms() {
            return this.root.children
        }
        get selection() {
            return this._selection
        }
        set selection(e) {
            this.setSelection(e)
        }
        setSelection(e, t) {
            return this.deferNotifications({
                selection: !0
            }, (() => {
                const a = this.normalizeSelection(e, t);
                if (void 0 === a) throw new TypeError("Invalid selection");
                if (1 === a.ranges.length && a.ranges[0][0] === a.ranges[0][1]) {
                    const e = a.ranges[0][0];
                    this._position = e, this._anchor = e, this._selection = a
                } else {
                    const e = Ca(a);
                    "backward" === a.direction ? [this._position, this._anchor] = e : [this._anchor, this._position] = e;
                    const t = this.at(e[0] + 1),
                        i = this.at(e[1]),
                        o = lt.commonAncestor(t, i);
                    "array" === (null == o ? void 0 : o.type) && t.parent === o && i.parent, this._selection = {
                        ranges: [e],
                        direction: a.direction
                    }
                }
            }))
        }
        setPositionHandlingPlaceholder(e) {
            var t, a, i;
            "placeholder" === (null === (t = this.at(e)) || void 0 === t ? void 0 : t.type) ? this.setSelection(e - 1, e): "placeholder" === (null === (i = null === (a = this.at(e)) || void 0 === a ? void 0 : a.rightSibling) || void 0 === i ? void 0 : i.type) ? this.setSelection(e, e + 1) : this.position = e
        }
        getState() {
            return {
                content: this.root.toJson(),
                selection: this.selection
            }
        }
        setState(e, t) {
            var a;
            const i = this.suppressChangeNotifications;
            this.suppressChangeNotifications = null === (a = null == t ? void 0 : t.suppressChangeNotifications) || void 0 === a || a;
            let o = {};
            "undo" === (null == t ? void 0 : t.type) && (o = {
                inputType: "historyUndo"
            }), "redo" === (null == t ? void 0 : t.type) && (o = {
                inputType: "historyRedo"
            }), ji(this, o) && (this.root = ga(e.content, this.mathfield), this.selection = e.selection, Hi(this, o)), this.suppressChangeNotifications = i
        }
        get position() {
            return this._position
        }
        set position(e) {
            this.setSelection(e, e)
        }
        get anchor() {
            return this._anchor
        }
        get selectionIsCollapsed() {
            return this._anchor === this._position
        }
        get selectionIsPlaceholder() {
            return 1 === Math.abs(this._anchor - this._position) && "placeholder" === this.at(Math.max(this._anchor, this._position)).type
        }
        collapseSelection(e = "forward") {
            return this._anchor !== this._position && (this.position = "backward" === e ? Math.min(this._anchor, this._position) : Math.max(this._anchor, this._position), !0)
        }
        get lastOffset() {
            return this.atoms.length - 1
        }
        at(e) {
            return this.atoms[e]
        }
        offsetOf(e) {
            return this.atoms.indexOf(e)
        }
        getSiblingsRange(e) {
            const t = this.at(e),
                {
                    parent: a
                } = t;
            if (!a) return [0, this.lastOffset];
            const i = t.parent.branch(t.treeBranch);
            return [this.offsetOf(i[0]), this.offsetOf(i[i.length - 1])]
        }
        getBranchRange(e, t) {
            const a = this.at(e).branch(t);
            return [this.offsetOf(a[0]), this.offsetOf(a[a.length - 1])]
        }
        getAtoms(e, t, a) {
            var i, o;
            let r, n, s = null != a ? a : {};
            if (Bo(e)) {
                if (s = null !== (i = t) && void 0 !== i ? i : {}, e.ranges.length > 1) return e.ranges.reduce(((e, t) => [...e, ...this.getAtoms(t, s)]), []);
                e = e.ranges[0]
            }
            if (To(e)) {
                if (r = e, !To(t)) return [];
                n = t
            } else [r, n] = e, s = null !== (o = t) && void 0 !== o ? o : {};
            if (!Number.isFinite(r)) return [];
            void 0 === s.includeChildren && (s.includeChildren = !1), r < 0 && (r = this.lastOffset - r + 1), n < 0 && (n = this.lastOffset - n + 1);
            const l = Math.min(r, n) + 1,
                d = Math.max(r, n);
            if (1 === l && d === this.lastOffset) return [this.root];
            let c = [];
            for (let e = l; e <= d; e++) {
                const t = this.atoms[e];
                No(this, t, l, d) && c.push(t)
            }
            return s.includeChildren || (c = c.filter((e => {
                let t = !1,
                    {
                        parent: a
                    } = e;
                for (; a && !t;) t = No(this, a, l, d), a = a.parent;
                return !t
            }))), c
        }
        getAllAtoms(e) {
            const t = [],
                a = this.lastOffset;
            for (let i = e; i <= a; i++) t.push(this.atoms[i]);
            for (let a = 0; a < e; a++) t.push(this.atoms[a]);
            return t
        }
        extractAtoms(e) {
            let t = this.getAtoms(e);
            1 === t.length && "root" === t[0].type && (t = t[0].children);
            for (const e of t) e.parent.removeChild(e);
            return t
        }
        deleteAtoms(e) {
            this.extractAtoms(e), this.position = e[0]
        }
        atomToString(e, t) {
            const a = null != t ? t : "latex";
            if (a.startsWith("latex")) return Be.serialize([e], {
                expandMacro: "latex-expanded" === a,
                skipStyles: "latex-unstyled" === a,
                defaultMode: this.mathfield.options.defaultMode
            });
            if ("math-ml" === a) return Ua(e, this.mathfield.options);
            if ("spoken" === a) return ai(e, this.mathfield.options);
            if ("spoken-text" === a) {
                const t = this.mathfield.options.textToSpeechMarkup;
                this.mathfield.options.textToSpeechMarkup = "";
                const a = ai(e, this.mathfield.options);
                return this.mathfield.options.textToSpeechMarkup = t, a
            }
            if ("spoken-ssml" === a || "spoken-ssml-with-highlighting" === a) {
                const t = this.mathfield.options.textToSpeechMarkup;
                this.mathfield.options.textToSpeechMarkup = "ssml";
                const a = ai(e, this.mathfield.options);
                return this.mathfield.options.textToSpeechMarkup = t, a
            }
            if ("math-json" === a) {
                if (!this.mathfield.computeEngine) return "";
                try {
                    const t = this.mathfield.computeEngine.parse(lt.serialize(e, {
                        expandMacro: !1,
                        defaultMode: "math"
                    }));
                    return JSON.stringify(t.json)
                } catch (e) {
                    return JSON.stringify(["Error", "Nothing", `'${e.toString()}'`])
                }
            }
            return "ascii-math" === a ? $o(e) : ""
        }
        getValue(e, t, a) {
            if (void 0 === e) return this.atomToString(this.root, "latex");
            if ("string" == typeof e) return this.atomToString(this.root, e);
            let i, o;
            if (To(e) && To(t) ? (i = [this.normalizeRange([e, t])], o = null != a ? a : "latex") : zo(e) ? (i = [this.normalizeRange(e)], o = t) : Bo(e) ? (i = e.ranges, o = t) : (i = [], o = "latex"), o.startsWith("latex")) {
                const e = {
                    expandMacro: "latex-expanded" === o,
                    skipStyles: "latex-unstyled" === o,
                    defaultMode: this.mathfield.options.defaultMode
                };
                return at(i.map((t => lt.serialize(this.getAtoms(t), e))))
            }
            return i.map((e => this.getAtoms(e).map((e => this.atomToString(e, o))).join(""))).join("")
        }
        extendSelection(e) {
            let t = this._anchor;
            if ("forward" === e) {
                let e = this._position;
                do {
                    let t = this.at(e + 1);
                    if (null == t ? void 0 : t.inCaptureSelection) {
                        for (; !t.captureSelection;) t = t.parent;
                        e = this.offsetOf(null == t ? void 0 : t.lastChild) + 1
                    } else e += 1
                } while (e <= this.lastOffset && this.at(e).isFirstSibling);
                return e === t - 1 && "first" === this.at(t).type && (e = t), this.extendSelectionTo(t, e)
            }
            let a = this._position - 1;
            if (a < 0) return !1;
            for (; a >= 0 && this.at(a).isLastSibling;) {
                let e = this.at(a);
                if (null == e ? void 0 : e.inCaptureSelection) {
                    for (; !e.captureSelection;) e = e.parent;
                    a = this.offsetOf(e.firstChild) - 1
                } else a -= 1
            }
            return a < 0 && (a = 0), a === t + 1 && "first" === this.at(a).type && (t = a), this.extendSelectionTo(t, a)
        }
        extendSelectionTo(e, t) {
            return this.deferNotifications({
                selection: !0
            }, (() => {
                const a = this.normalizeRange([e, t]);
                let [i, o] = a, {
                    parent: r
                } = this.at(o);
                if (r && ("genfrac" === r.type || "msubsup" === r.type))
                    for (; r !== this.root && Po(this, r, [i, o]);) o = this.offsetOf(r), r = r.parent;
                for (r = this.at(i).parent; r !== this.root && Po(this, r, [i, o]);) i = this.offsetOf(r.leftSibling), r = r.parent;
                if (r = this.at(o).parent, "genfrac" === (null == r ? void 0 : r.type))
                    for (; r !== this.root && Po(this, r, [i, o]);) o = this.offsetOf(r), r = r.parent;
                this._position = this.normalizeOffset(t), this._selection = {
                    ranges: [
                        [i, o]
                    ],
                    direction: "none"
                }
            }))
        }
        setListeners(e) {
            this.listeners = e
        }
        announce(e, t, a = []) {
            var i, o;
            null === (o = null === (i = this.mathfield.host) || void 0 === i ? void 0 : i.dispatchEvent(new CustomEvent("announce", {
                detail: {
                    command: e,
                    previousPosition: t,
                    atoms: a
                },
                cancelable: !0,
                bubbles: !0,
                composed: !0
            }))) || void 0 === o || o || function(e, t, a, i) {
                let o = "";
                "plonk" === t ? (e.playSound("plonk"), e.flushInlineShortcutBuffer()) : "delete" === t ? o = ho(e.options, "deleted: ", i) : "focus" === t || t.includes("move") ? o = function(e, t) {
                    if (Number.isNaN(t)) return "";
                    const a = e.at(t);
                    if (!a) return "";
                    if (a.treeDepth <= e.at(e.position).treeDepth) return "";
                    let i = "",
                        o = a.parent;
                    const r = e.at(e.position).parent;
                    for (; o !== e.root && o !== r;) i += `out of ${Eo(o)};`, o = o.parent;
                    return i
                }(e.model, a) + (e.model.selectionIsCollapsed ? "" : "selected: ") + function(e, t) {
                    if (!e.selectionIsCollapsed) return ho(t, "", e.getAtoms(e.selection));
                    let a = "";
                    const i = e.at(e.position),
                        o = Eo(i);
                    return i.isFirstSibling && (a = (o ? "start of " + o : "unknown") + ": "), i.isLastSibling ? i.isFirstSibling || (a += o ? "end of " + o : "unknown") : a += ho(t, "", i), a
                }(e.model, e.options) : "replacement" === t ? o = ho(e.options, "", e.model.at(e.model.position)) : "line" === t ? (o = ho(e.options, "", e.model.root), e.keyboardDelegate.setAriaLabel("after: " + o)) : o = i ? ho(e.options, t + " ", i) : t;
                const r = e.ariaLiveText.textContent.includes(" ") ? "   " : "   ";
                e.ariaLiveText.textContent = o + r
            }(this.mathfield, e, t, a)
        }
        deferNotifications(e, t) {
            const a = this._selection,
                i = this._anchor,
                o = this._position,
                r = this.suppressChangeNotifications;
            this.suppressChangeNotifications = !0;
            const n = this.root.changeCounter;
            t();
            const s = this.root.changeCounter !== n,
                l = i !== this._anchor || o !== this._position || "different" === function(e, t) {
                    if (e.direction === t.direction) {
                        const a = e.ranges.length;
                        if (t.ranges.length === a) {
                            let i = 0;
                            for (; i < a && "equal" === La(e.ranges[i], t.ranges[i]);) i++;
                            return i === a ? "equal" : "different"
                        }
                    }
                    return "different"
                }(this._selection, a);
            return this.suppressChangeNotifications = r, e.content && s && Hi(this, {
                data: e.data,
                inputType: e.type
            }), e.selection && l && Vi(this), s || l
        }
        normalizeOffset(e) {
            return e > 0 ? e = Math.min(e, this.lastOffset) : e < 0 && (e = this.lastOffset + e + 1), e
        }
        normalizeRange(e) {
            let [t, a] = e;
            return t = this.normalizeOffset(t), a = this.normalizeOffset(a), t < a ? [t, a] : [a, t]
        }
        normalizeSelection(e, t) {
            var a;
            let i;
            if (To(e)) {
                const a = this.normalizeOffset(e);
                if (To(t)) {
                    const e = this.normalizeOffset(t);
                    i = a <= e ? {
                        ranges: [
                            [a, e]
                        ],
                        direction: "none"
                    } : {
                        ranges: [
                            [e, a]
                        ],
                        direction: "backward"
                    }
                } else i = {
                    ranges: [
                        [a, a]
                    ],
                    direction: "none"
                }
            } else if (zo(e)) {
                const t = this.normalizeOffset(e[0]),
                    a = this.normalizeOffset(e[1]);
                i = t <= a ? {
                    ranges: [
                        [t, a]
                    ],
                    direction: "none"
                } : {
                    ranges: [
                        [a, t]
                    ],
                    direction: "backward"
                }
            } else Bo(e) && (i = {
                ranges: e.ranges.map((e => this.normalizeRange(e))),
                direction: null !== (a = e.direction) && void 0 !== a ? a : "none"
            });
            return i
        }
        constructor(e, t, a) {
            this.options = e, this._selection = {
                ranges: [
                    [0, 0]
                ],
                direction: "none"
            }, this._anchor = 0, this._position = 0, this.mathfield = a, this.suppressChangeNotifications = !1, this.root = new lt("root", a, {
                mode: e.mode
            }), this.root.body = [], this.setListeners(t)
        }
    }

    function No(e, t, a, i) {
        const o = e.offsetOf(t);
        if (o < a || o > i) return !1;
        if (!t.hasChildren) return !0;
        const r = e.offsetOf(t.firstChild);
        if (r >= a && r <= i) {
            const o = e.offsetOf(t.lastChild);
            if (o >= a && o <= i) return !0
        }
        return !1
    }

    function Po(e, t, a) {
        if (!(null == t ? void 0 : t.hasChildren)) return !1;
        const [i, o] = a, r = e.offsetOf(t.firstChild), n = e.offsetOf(t.lastChild);
        return r >= i && r <= o && n >= r && n <= o
    }

    function Fo(e, t) {
        let a = e.at(e.position);
        for (; a && !(Array.isArray(a.treeBranch) && a.parent instanceof Vt);) a = a.parent;
        if (Array.isArray(null == a ? void 0 : a.treeBranch) && (null == a ? void 0 : a.parent) instanceof Vt) {
            const i = a.parent;
            let o;
            switch (t) {
                case "after row":
                    i.addRowAfter(a.treeBranch[0]), o = e.offsetOf(i.getCell(a.treeBranch[0] + 1, 0)[0]);
                    break;
                case "after column":
                    if (i.maxColumns <= i.colCount) return void e.announce("plonk");
                    i.addColumnAfter(a.treeBranch[1]), o = e.offsetOf(i.getCell(a.treeBranch[0], a.treeBranch[1] + 1)[0]);
                    break;
                case "before row":
                    i.addRowBefore(a.treeBranch[0]), o = e.offsetOf(i.getCell(a.treeBranch[0] - 1, 0)[0]);
                    break;
                case "before column":
                    if (i.maxColumns <= i.colCount) return void e.announce("plonk");
                    i.addColumnBefore(a.treeBranch[1]), o = e.offsetOf(i.getCell(a.treeBranch[0], a.treeBranch[1] - 1)[0])
            }
            e.setSelection(o, o + 1)
        }
    }

    function Ro(e) {
        return !!ji(e, {
            inputType: "insertText"
        }) && (Fo(e, "after row"), Hi(e, {
            inputType: "insertText"
        }), !0)
    }

    function Io(e) {
        return !!ji(e, {
            inputType: "insertText"
        }) && (Fo(e, "after column"), Hi(e, {
            inputType: "insertText"
        }), !0)
    }

    function Vo(e, t) {
        let a = e.at(e.position);
        for (; a && !(Array.isArray(a.treeBranch) && a.parent instanceof Vt);) a = a.parent;
        if (Array.isArray(null == a ? void 0 : a.treeBranch) && (null == a ? void 0 : a.parent) instanceof Vt) {
            const i = a.parent,
                o = a.treeBranch;
            let r;
            switch (t) {
                case "row":
                    if (i.rowCount > 1) {
                        i.removeRow(o[0]);
                        const t = i.getCell(Math.max(0, o[0] - 1), o[1]);
                        r = e.offsetOf(t[t.length - 1])
                    }
                    break;
                case "column":
                    if (i.colCount > i.minColumns) {
                        i.removeColumn(o[1]);
                        const t = i.getCell(o[0], Math.max(0, o[1] - 1));
                        r = e.offsetOf(t[t.length - 1])
                    }
            }
            r && e.setPositionHandlingPlaceholder(r)
        }
    }

    function jo(e, t, a, i) {
        var o, r, n, s, l, d;
        const c = a.parent;
        if (a instanceof Tt) {
            const o = !i && "forward" === t || "body" === i && "backward" === t;
            let r = o ? e.offsetOf(a.firstChild) : e.offsetOf(a.lastChild);
            return o ? "?" !== a.rightDelim && "." !== a.rightDelim ? (a.leftDelim = ".", a.isDirty = !0) : (c.addChildrenAfter(a.removeBranch("body"), a), c.removeChild(a), r--) : "?" !== a.leftDelim && "." !== a.leftDelim ? (a.rightDelim = ".", a.isDirty = !0) : (c.addChildrenAfter(a.removeBranch("body"), a), c.removeChild(a), r--), e.position = r, !0
        }
        if ("surd" === a.type) {
            if ("forward" === t && !i || "backward" === t && "body" === i) {
                const t = a.leftSibling;
                a.hasChildren && c.addChildrenAfter(a.removeBranch("body"), a), c.removeChild(a), e.position = e.offsetOf(t)
            } else "forward" === t && "body" === i ? e.position = e.offsetOf(a) : i || "backward" !== t ? "above" === i && (a.hasEmptyBranch("above") && a.removeBranch("above"), e.position = "backward" === t ? e.offsetOf(a.leftSibling) : e.offsetOf(a.body[0])) : a.hasChildren ? e.position = e.offsetOf(a.lastChild) : (e.position = Math.max(0, e.offsetOf(a) - 1), c.removeChild(a));
            return !0
        }
        if ("box" === a.type || "enclose" === a.type) {
            const o = i && "backward" === t || !i && "forward" === t ? a.leftSibling : a.lastChild;
            return c.addChildrenAfter(a.removeBranch("body"), a), c.removeChild(a), e.position = e.offsetOf(o), !0
        }
        if ("genfrac" === a.type || "overunder" === a.type) {
            if (!i) return !("overunder" === a.type && a.hasEmptyBranch("body") || "genfrac" === a.type && a.hasEmptyBranch("below") && a.hasEmptyBranch("above") || (e.position = e.offsetOf("forward" === t ? a.firstChild : a.lastChild), 0));
            const o = "numerator-denominator" === a.context.fractionNavigationOrder ? "above" : "below",
                r = "above" === o ? "below" : "above";
            if ("forward" === t && i === o || "backward" === t && i === r) {
                const t = a.removeBranch(o),
                    i = a.removeBranch(r);
                return c.addChildrenAfter([...t, ...i], a), c.removeChild(a), e.position = e.offsetOf(t.length > 0 ? t[t.length - 1] : i[0]), !0
            }
            return "backward" === t ? (e.position = e.offsetOf(a.leftSibling), !0) : (e.position = e.offsetOf(a), !0)
        }
        if (a.isExtensibleSymbol || "msubsup" === a.type) {
            if (!i && "forward" === t) return !1;
            if (!i) {
                if (a.subscript || a.superscript) {
                    const i = "forward" === t ? null !== (r = null === (o = a.superscript) || void 0 === o ? void 0 : o[0]) && void 0 !== r ? r : null === (n = a.subscript) || void 0 === n ? void 0 : n[0] : null !== (l = null === (s = a.subscript) || void 0 === s ? void 0 : s[0].lastSibling) && void 0 !== l ? l : null === (d = a.superscript) || void 0 === d ? void 0 : d[0].lastSibling;
                    return i && (e.position = e.offsetOf(i)), !0
                }
                return !1
            }
            if (i && a.hasEmptyBranch(i) && a.removeBranch(i), !a.hasChildren) {
                const i = "forward" === t ? e.offsetOf(a) : Math.max(0, e.offsetOf(a) - 1);
                return a.parent.removeChild(a), e.position = i, !0
            }
            if ("superscript" === i)
                if ("backward" === t) {
                    const t = e.offsetOf(a.firstChild) - 1;
                    e.position = t
                } else a.subscript ? e.position = e.offsetOf(a.subscript[0]) : e.position = e.offsetOf(a);
            else "subscript" === i && ("backward" === t && a.superscript ? e.position = e.offsetOf(a.superscript[0].lastSibling) : e.position = "backward" === t ? e.offsetOf(a.firstChild) - 1 : e.offsetOf(a));
            return !0
        }
        return !1
    }

    function Ho(e, t, a) {
        const i = e.getAtoms(t);
        if (i.length > 0 && i[0].parent) {
            let a = i[0].parent.firstChild;
            "first" === a.type && (a = a.rightSibling);
            const o = i[i.length - 1].parent.lastChild;
            let r = i[0];
            "first" === r.type && (r = r.rightSibling);
            const n = i[i.length - 1];
            if (r === a && n === o) {
                const a = i[0].parent;
                "root" !== a.type && (t = [e.offsetOf(a.leftSibling), e.offsetOf(a.rightSibling)])
            }
        }
        return e.deferNotifications({
            content: !0,
            selection: !0,
            type: a
        }, (() => e.deleteAtoms(t)))
    }

    function Wo(e, t) {
        const a = e.at(t);
        let i;
        if (a) {
            i = a.mode;
            let e = a.parent;
            for (; !i && e;) e && (i = e.mode), e = e.parent
        }
        return i
    }

    function Jo(e, t) {
        e && t && (i(e) ? e.forEach((e => Jo(e, t))) : "object" == typeof e && (e.style.color || e.style.backgroundColor || e.style.fontFamily || e.style.fontShape || e.style.fontSeries || e.style.fontSize || e.style.variant || e.style.variantStyle || (e.applyStyle(t), Jo(e.body, t), Jo(e.above, t), Jo(e.below, t), Jo(e.subscript, t), Jo(e.superscript, t))))
    }

    function Uo(e, t, a, i) {
        function o(e, t) {
            for (const a of r)
                if (a.style[e] !== t) return !1;
            return !0
        }
        if ((t = e.normalizeRange(t))[0] === t[1]) return !1;
        const r = e.getAtoms(t, {
            includeChildren: !0
        });
        "toggle" === i.operation && (a.color && o("color", a.color) && (a.color = "none", a.verbatimColor = void 0), a.backgroundColor && o("backgroundColor", a.backgroundColor) && (a.backgroundColor = "none", a.verbatimBackgroundColor = void 0), a.fontFamily && o("fontFamily", a.fontFamily) && (a.fontFamily = "none"), a.fontSeries && o("fontSeries", a.fontSeries) && (a.fontSeries = "auto"), a.fontShape && o("fontShape", a.fontShape) && (a.fontShape = "auto"), a.fontSize && o("fontSize", a.fontSize) && (a.fontSize = 5));
        for (const e of r) e.applyStyle(a);
        return !0
    }

    function Xo(e, t, a) {
        if ("text" !== e.at(t).mode) return t;
        const i = "backward" === a ? -1 : 1;
        let o;
        if (z.test(e.at(t).value)) {
            let a, r = t;
            do {
                a = "text" === e.at(r).mode && z.test(e.at(r).value), r += i
            } while (e.at(r) && a);
            o = e.at(r) ? r - 2 * i : r - i
        } else if (/\s/.test(e.at(t).value)) {
            let a = t;
            for (; e.at(a) && "text" === e.at(a).mode && /\s/.test(e.at(a).value);) a += i;
            if (e.at(a)) {
                let t = !0;
                do {
                    t = "text" === e.at(a).mode && !/\s/.test(e.at(a).value), a += i
                } while (e.at(a) && t);
                o = e.at(a) ? a - 2 * i : a - i
            } else o = a - i
        } else {
            let a = t;
            for (; e.at(a) && "text" === e.at(a).mode && !/\s/.test(e.at(a).value);) a += i;
            o = e.at(a) ? a : a - i;
            let r = !0;
            for (; e.at(a) && r;) r = "text" === e.at(a).mode && /\s/.test(e.at(a).value), r && (o = a), a += i;
            o = e.at(a) ? a - 2 * i : a - i
        }
        return o - (i > 0 ? 0 : 1)
    }

    function Go(e, t, a) {
        var i, o, r, n, s, l, d;
        const c = e.position;
        null !== (i = null == a ? void 0 : a.extend) && void 0 !== i && i || e.collapseSelection(t);
        let u = e.at(e.position);
        if ("forward" === t && ("msubsup" === u.type ? (u = u.rightSibling, u || (u = e.at(e.position + 1))) : u = e.at(e.position + 1)), !u) return e.announce("plonk"), !1;
        let p = e.offsetOf(u);
        if (u instanceof $t) p = Xo(e, p, t);
        else if (u instanceof ta)
            if (u.isSuggestion)
                for (; u && u instanceof ta;) u.isSuggestion = !1, p = e.offsetOf(u), u = u.rightSibling;
            else if ("forward" === t) {
            if (u = u.rightSibling, !(u && u instanceof ta)) return e.announce("plonk"), !1;
            for (; u && u instanceof ta && /[a-zA-Z\*]/.test(u.value);) p = e.offsetOf(u), u = u.rightSibling
        } else {
            if (u = u.leftSibling, !(u && u instanceof ta)) return e.announce("plonk"), !1;
            for (; u && u instanceof ta && /[a-zA-Z\*]/.test(u.value);) p = e.offsetOf(u), u = u.leftSibling
        } else if ("forward" === t && "mopen" === u.type) {
            let t = 0;
            do {
                "mopen" === u.type ? t += 1 : "mclose" === u.type && (t -= 1), u = u.rightSibling
            } while (!u.isLastSibling && 0 !== t);
            p = e.offsetOf(u.leftSibling)
        } else if ("backward" === t && "mclose" === u.type) {
            let t = 0;
            do {
                "mopen" === u.type ? t += 1 : "mclose" === u.type && (t -= 1), u = u.leftSibling
            } while (!u.isFirstSibling && 0 !== t);
            p = e.offsetOf(u)
        } else if ("backward" === t)
            if ("first" === u.type)
                for (; p > 0 && "first" === u.type;) p -= 1, u = e.at(p);
            else {
                const t = u.type;
                "msubsup" === u.type && (p = e.offsetOf(e.at(p).leftSibling)), p -= 1;
                let a = null === (o = e.at(p)) || void 0 === o ? void 0 : o.type;
                for (; p >= 0 && a === t;) "msubsup" === (null === (r = e.at(p)) || void 0 === r ? void 0 : r.type) ? p = e.offsetOf(e.at(p).leftSibling) : p -= 1, a = e.at(p).type
            }
        else {
            const {
                type: t
            } = u;
            let a = null === (n = e.at(p)) || void 0 === n ? void 0 : n.type;
            const {
                lastOffset: i
            } = e;
            for (; p <= i && (a === t || "msubsup" === a);) {
                for (;
                    "msubsup" === (null === (s = e.at(p).rightSibling) || void 0 === s ? void 0 : s.type);) p = e.offsetOf(e.at(p).rightSibling);
                p += 1, a = null === (l = e.at(p)) || void 0 === l ? void 0 : l.type
            }
            p -= 1
        }
        if (null !== (d = null == a ? void 0 : a.extend) && void 0 !== d && d) {
            if (!e.setSelection(e.anchor, p)) return e.announce("plonk"), !1
        } else {
            if (p === e.position) return e.announce("plonk"), !1;
            e.position = p
        }
        return e.announce("move", c), !0
    }

    function Zo(e, t, a) {
        var i, o, r, n, s, l, d, c;
        if (a = null != a ? a : {
                extend: !1
            }, "forward" !== t) {
            const [t, a] = Ji(e);
            void 0 !== t && void 0 !== a && e.deleteAtoms([t, a])
        }
        if ("upward" === t) return function(e, t) {
            var a, i, o, r;
            const n = null !== (a = null == t ? void 0 : t.extend) && void 0 !== a && a;
            n || e.collapseSelection("backward");
            const s = e.at(e.position);
            let l = s;
            for (; l && "below" !== l.treeBranch && !(Array.isArray(l.treeBranch) && l.parent instanceof Vt);) l = l.parent;
            if (Array.isArray(null == l ? void 0 : l.treeBranch) && l.parent instanceof Vt) {
                const t = l.parent,
                    a = Math.max(0, l.treeBranch[0] - 1);
                Yo(e, s, t.array[a][l.treeBranch[1]], n, "up")
            } else {
                if (!l) {
                    let t = !0;
                    return e.suppressChangeNotifications || (t = null === (r = null === (o = e.mathfield.host) || void 0 === o ? void 0 : o.dispatchEvent(new CustomEvent("move-out", {
                        detail: {
                            direction: "upward"
                        },
                        cancelable: !0,
                        bubbles: !0,
                        composed: !0
                    }))) || void 0 === r || r), e.announce(t ? "plonk" : "line"), t
                }
                Yo(e, s, null !== (i = l.parent.branch("above")) && void 0 !== i ? i : l.parent.createBranch("above"), n, "up")
            }
            return !0
        }(e, a);
        if ("downward" === t) return function(e, t) {
            var a, i, o, r;
            const n = null !== (a = null == t ? void 0 : t.extend) && void 0 !== a && a;
            n || e.collapseSelection("forward");
            const s = e.at(e.position);
            let l = s;
            for (; l && "above" !== l.treeBranch && !(Array.isArray(l.treeBranch) && l.parent instanceof Vt);) l = l.parent;
            if (Array.isArray(null == l ? void 0 : l.treeBranch) && l.parent instanceof Vt) {
                const t = l.parent,
                    a = Math.min(t.array.length - 1, l.treeBranch[0] + 1);
                Yo(e, s, t.array[a][l.treeBranch[1]], n, "down")
            } else {
                if (!l) {
                    let t = !0;
                    return e.suppressChangeNotifications || (t = null === (r = null === (o = e.mathfield.host) || void 0 === o ? void 0 : o.dispatchEvent(new CustomEvent("move-out", {
                        detail: {
                            direction: "downward"
                        },
                        cancelable: !0,
                        bubbles: !0,
                        composed: !0
                    }))) || void 0 === r || r), e.announce(t ? "plonk" : "line"), t
                }
                Yo(e, s, null !== (i = l.parent.branch("below")) && void 0 !== i ? i : l.parent.createBranch("below"), n, "down")
            }
            return !0
        }(e, a);
        const u = e.position;
        if (a.extend) return e.extendSelection(t);
        if (e.selectionIsPlaceholder) return e.collapseSelection(t), Zo(e, t);
        if (!e.collapseSelection(t)) {
            let u = e.position + ("forward" === t ? 1 : -1),
                p = e.at(u);
            if (u >= 0 && u <= e.lastOffset)
                if ("forward" === t)
                    if (p.inCaptureSelection) {
                        for (; !p.captureSelection;) p = p.parent;
                        u = e.offsetOf(p)
                    } else if (!p.isFirstSibling && p.isLastSibling && (null === (i = p.parent) || void 0 === i ? void 0 : i.skipBoundary)) {
                if (u + 1 !== e.lastOffset) return e.position = u, Zo(e, "forward", a);
                u += 1
            } else(null === (o = p.parent) || void 0 === o ? void 0 : o.skipBoundary) && (null === (r = p.rightSibling) || void 0 === r ? void 0 : r.isLastSibling) ? u += 2 : (null === (n = p.parent) || void 0 === n ? void 0 : n.skipBoundary) && "first" === p.type ? u += 1 : p instanceof ta && p.isSuggestion && (p.isSuggestion = !1);
            else if ("backward" === t)
                if (null === (s = p.parent) || void 0 === s ? void 0 : s.inCaptureSelection) {
                    for (; !p.captureSelection;) p = p.parent;
                    u = Math.max(0, e.offsetOf(p.leftSibling))
                } else(p.skipBoundary || (null === (l = p.parent) || void 0 === l ? void 0 : l.skipBoundary) && "first" === p.type) && (u = Math.max(0, e.position - 2));
            if (u < 0 || u > e.lastOffset) {
                let a = !0;
                return e.suppressChangeNotifications || (a = null === (c = null === (d = e.mathfield.host) || void 0 === d ? void 0 : d.dispatchEvent(new CustomEvent("move-out", {
                    detail: {
                        direction: t
                    },
                    cancelable: !0,
                    bubbles: !0,
                    composed: !0
                }))) || void 0 === c || c), a && e.announce("plonk"), a
            }
            e.setPositionHandlingPlaceholder(u)
        }
        return e.announce("move", u), !0
    }

    function Yo(e, t, a, i, o) {
        const r = fi(e.mathfield.getHTMLElement(t)).right,
            n = e.offsetOf(function(e, t, a) {
                let i = 1 / 0,
                    o = 0;
                for (; o < t.length; o++) {
                    const r = fi(e.getHTMLElement(t[o])).right,
                        n = Math.abs(a - r);
                    if (!(n <= i)) break;
                    i = n
                }
                return t[o - 1]
            }(e.mathfield, a, r));
        if (i) {
            const [t, a] = e.selection.ranges[0];
            let i;
            i = n < ("up" === o ? t : a) ? {
                ranges: [
                    [n, a]
                ],
                direction: "backward"
            } : {
                ranges: [
                    [t, n]
                ],
                direction: "forward"
            }, e.setSelection(i)
        } else e.setPositionHandlingPlaceholder(n);
        e.announce(`move ${o}`)
    }

    function Qo(e) {
        const t = e.position,
            a = e.at(t).parent;
        return a && "root" !== a.type ? (e.position = e.offsetOf(a), e.announce("move", t), !0) : (e.announce("plonk"), !1)
    }

    function er(e) {
        var t;
        if (e.collapseSelection(), function(e) {
                let t = 0,
                    a = e.at(e.position),
                    i = !1;
                for (; a;) a.hasEmptyBranch("superscript") && a.hasEmptyBranch("subscript") || (t += 1), a.hasEmptyBranch("superscript") ? a.hasEmptyBranch("subscript") || (i = !1) : i = !0, a = a.parent;
                return i ? t : 0
            }(e) >= e.mathfield.options.scriptDepth[1]) return e.announce("plonk"), !1;
        let a = e.at(e.position);
        return void 0 === a.subsupPlacement && ("msubsup" !== (null === (t = a.rightSibling) || void 0 === t ? void 0 : t.type) && a.parent.addChildAfter(new zt(e.mathfield, {
            style: a.computedStyle
        }), a), a = a.rightSibling), a.createBranch("superscript"), e.setSelection(e.getSiblingsRange(e.offsetOf(a.superscript[0]))), !0
    }

    function tr(e) {
        var t;
        if (e.collapseSelection(), function(e) {
                let t = 0,
                    a = e.at(e.position),
                    i = !1;
                for (; a;) a.hasEmptyBranch("superscript") && a.hasEmptyBranch("subscript") || (t += 1), a.hasEmptyBranch("superscript") ? a.hasEmptyBranch("subscript") || (i = !0) : i = !1, a = a.parent;
                return i ? t : 0
            }(e) >= e.mathfield.options.scriptDepth[0]) return e.announce("plonk"), !1;
        let a = e.at(e.position);
        return void 0 === a.subsupPlacement && ("msubsup" !== (null === (t = e.at(e.position + 1)) || void 0 === t ? void 0 : t.type) && a.parent.addChildAfter(new zt(e.mathfield, {
            style: e.at(e.position).computedStyle
        }), a), a = e.at(e.position + 1)), a.createBranch("subscript"), e.setSelection(e.getSiblingsRange(e.offsetOf(a.subscript[0]))), !0
    }

    function ar(e, t, a = !0) {
        var i, r;
        const n = "forward" === t ? 1 : -1;
        "placeholder" === e.at(e.anchor).type && Zo(e, t);
        const s = e.getAllAtoms(Math.max(e.position + n, 0));
        "backward" === t && s.reverse();
        const l = s.filter((e => "placeholder" === e.type || e.treeDepth > 2 && e.isFirstSibling && e.isLastSibling));
        if (0 === l.length) {
            if (!a || null !== (r = null === (i = e.mathfield.host) || void 0 === i ? void 0 : i.dispatchEvent(new CustomEvent("focus-out", {
                    detail: {
                        direction: t
                    },
                    cancelable: !0,
                    bubbles: !0,
                    composed: !0
                }))) && void 0 !== r && !r) return e.announce("plonk"), !1;
            const s = function() {
                function e(e) {
                    var a;
                    return !((a = e).disabled || "hidden" === a.type && "INPUT" === a.tagName.toUpperCase() || function(e) {
                        if (!o() || e === document.activeElement || e.contains(document.activeElement)) return !1;
                        if ("hidden" === getComputedStyle(e).visibility) return !0;
                        const t = e.getBoundingClientRect();
                        if (0 === t.width || 0 === t.height) return !0;
                        for (; e;) {
                            if ("none" === getComputedStyle(e).display) return !0;
                            e = e.parentElement
                        }
                        return !1
                    }(a) || function(e) {
                        return "INPUT" === e.tagName.toUpperCase() && "radio" === e.type && ! function(e) {
                            var t;
                            if (!e.name) return !0;
                            const a = function(e, t) {
                                for (const a of e)
                                    if (a.checked && a.form === t) return a;
                                return null
                            }((null !== (t = e.form) && void 0 !== t ? t : e.ownerDocument).querySelectorAll('input[type="radio"][name="' + e.name + '"]'), e.form);
                            return !a || a === e
                        }(e)
                    }(e) || t(e) < 0)
                }

                function t(e) {
                    var t;
                    const a = Number.parseInt(null !== (t = e.getAttribute("tabindex")) && void 0 !== t ? t : "NaN", 10);
                    return Number.isNaN(a) ? "true" === e.contentEditable ? 0 : "AUDIO" !== e.nodeName && "VIDEO" !== e.nodeName || null !== e.getAttribute("tabindex") ? e.tabIndex : 0 : a
                }
                return o() ? function(a) {
                    const i = [],
                        o = [];
                    return [...a.querySelectorAll('input, select, textarea, a[href], button,\n        [tabindex], audio[controls], video[controls],\n        [contenteditable]:not([contenteditable="false"]), details>summary')].filter(e).forEach(((e, a) => {
                        const r = t(e);
                        0 === r ? i.push(e) : o.push({
                            documentOrder: a,
                            tabIndex: r,
                            node: e
                        })
                    })), o.sort(((e, t) => e.tabIndex === t.tabIndex ? e.documentOrder - t.documentOrder : e.tabIndex - t.tabIndex)).map((e => e.node)).concat(i)
                }(document.body) : []
            }();
            if (!document.activeElement || 1 === s.length) return e.announce("plonk"), !1;
            let l = s.indexOf(document.activeElement) + n;
            return !!(document.activeElement instanceof fn && d(document.activeElement, t, n)) || (l < 0 && (l = s.length - 1), l >= s.length && (l = 0), !!(s[l] instanceof fn && d(s[l], t, n)) || (s[l].focus(), 0 !== l || (e.announce("plonk"), !1)))
        }

        function d(e, t, a) {
            var i, o, r;
            const n = [...null !== (o = null === (i = e.shadowRoot) || void 0 === i ? void 0 : i.querySelectorAll("math-field")) && void 0 !== o ? o : []];
            if (n.length) {
                const i = null === (r = e.shadowRoot) || void 0 === r ? void 0 : r.activeElement,
                    o = n.indexOf(i);
                let s = o + a;
                if (o < 0 && "backward" === t && (s = n.length - 1), s >= 0 && s < n.length) return n[s].focus(), !0
            }
            return !1
        }
        const c = e.position,
            u = e.offsetOf(l[0]);
        return "placeholder" === l[0].type ? e.setSelection(u - 1, u) : e.position = u, e.announce("move", c), !0
    }

    function ir(e) {
        var t, a, i, o, r, n;
        if ("text" === Wo(e, e.position)) {
            let t = Math.min(e.anchor, e.position),
                a = Math.max(e.anchor, e.position),
                i = !1;
            for (; !i && t > 0;) {
                const a = e.at(t);
                "text" === a.mode && z.test(a.value) ? t -= 1 : i = !0
            }
            for (i = !1; !i && a <= e.lastOffset;) {
                const t = e.at(a);
                "text" === t.mode && z.test(t.value) ? a += 1 : i = !0
            }
            if (i && (a -= 1), t >= a) return e.setSelection(a - 1, a), !0;
            e.setSelection(t, a)
        } else {
            const s = e.at(e.position);
            if (s.isDigit()) {
                let i = Math.min(e.anchor, e.position),
                    o = Math.max(e.anchor, e.position);
                for (; null === (t = e.at(i)) || void 0 === t ? void 0 : t.isDigit();) i -= 1;
                for (; null === (a = e.at(o)) || void 0 === a ? void 0 : a.isDigit();) o += 1;
                e.setSelection(i, o - 1)
            } else if (s.style.variant || s.style.variantStyle) {
                let t = Math.min(e.anchor, e.position),
                    a = Math.max(e.anchor, e.position),
                    l = null === (i = e.at(t)) || void 0 === i ? void 0 : i.style;
                for (; l && l.variant === s.style.variant && l.variantStyle === s.style.variantStyle;) t -= 1, l = null === (o = e.at(t)) || void 0 === o ? void 0 : o.style;
                for (l = null === (r = e.at(a)) || void 0 === r ? void 0 : r.style; l && l.variant === s.style.variant && l.variantStyle === s.style.variantStyle;) a += 1, l = null === (n = e.at(a)) || void 0 === n ? void 0 : n.style;
                e.setSelection(t, a - 1)
            } else e.setSelection(e.offsetOf(s.firstSibling), e.offsetOf(s.lastSibling))
        }
        return !0
    }
    uo({
        addRowAfter: Ro,
        addColumnAfter: Io,
        addRowBefore: function(e) {
            return !!ji(e, {
                inputType: "insertText"
            }) && (Fo(e, "before row"), Hi(e, {
                inputType: "insertText"
            }), !0)
        },
        addColumnBefore: function(e) {
            return !!ji(e, {
                inputType: "insertText"
            }) && (Fo(e, "before column"), Hi(e, {
                inputType: "insertText"
            }), !0)
        },
        removeRow: function(e) {
            return !!ji(e, {
                inputType: "deleteContent"
            }) && (Vo(e, "row"), Hi(e, {
                inputType: "deleteContent"
            }), !0)
        },
        removeColumn: function(e) {
            return !!ji(e, {
                inputType: "deleteContent"
            }) && (Vo(e, "column"), Hi(e, {
                inputType: "deleteContent"
            }), !0)
        }
    }, {
        target: "model",
        category: "array-edit"
    }), uo({
        deleteAll: e => ji(e, {
            inputType: "deleteContent"
        }) && Ho(e, [0, -1], "deleteContent"),
        deleteForward: e => function(e) {
            return !!ji(e, {
                inputType: "deleteContentForward"
            }) && (e.selectionIsCollapsed ? e.deferNotifications({
                content: !0,
                selection: !0,
                type: "deleteContentForward"
            }, (() => {
                var t, a;
                let i = e.at(e.position).rightSibling;
                if (i && jo(e, "forward", i)) return;
                if (i) {
                    if (e.at(e.position).isLastSibling && jo(e, "forward", i.parent, i.treeBranch)) return
                } else {
                    if (i = e.at(e.position), i.isLastSibling && jo(e, "forward", i.parent, i.treeBranch)) return;
                    i = null
                }
                if (e.position === e.lastOffset || !i) return void e.announce("plonk");
                i.parent.removeChild(i);
                let o = null === (t = e.at(e.position)) || void 0 === t ? void 0 : t.rightSibling;
                for (;
                    "msubsup" === (null == o ? void 0 : o.type);) o.parent.removeChild(o), o = null === (a = e.at(e.position)) || void 0 === a ? void 0 : a.rightSibling;
                e.announce("delete", void 0, [i])
            })) : Ho(e, Ca(e.selection), "deleteContentForward"))
        }(e),
        deleteBackward: e => function(e) {
            return !!ji(e, {
                inputType: "deleteContentBackward"
            }) && (e.selectionIsCollapsed ? e.deferNotifications({
                content: !0,
                selection: !0,
                type: "deleteContentBackward"
            }, (() => {
                let t = e.at(e.position);
                if (!t || !jo(e, "backward", t)) {
                    if (null == t ? void 0 : t.isFirstSibling) {
                        if (jo(e, "backward", t.parent, t.treeBranch)) return;
                        t = null
                    }
                    t ? (e.position = e.offsetOf(t.leftSibling), t.parent.removeChild(t), e.announce("delete", void 0, [t])) : e.announce("plonk")
                }
            })) : Ho(e, Ca(e.selection), "deleteContentBackward"))
        }(e),
        deleteNextWord: e => ji(e, {
            inputType: "deleteWordForward"
        }) && Ho(e, [e.anchor, Xo(e, e.position, "forward")], "deleteWordForward"),
        deletePreviousWord: e => ji(e, {
            inputType: "deleteWordBackward"
        }) && Ho(e, [e.anchor, Xo(e, e.position, "backward")], "deleteWordBackward"),
        deleteToGroupStart: e => ji(e, {
            inputType: "deleteSoftLineBackward"
        }) && Ho(e, [e.anchor, e.offsetOf(e.at(e.position).firstSibling)], "deleteSoftLineBackward"),
        deleteToGroupEnd: e => ji(e, {
            inputType: "deleteSoftLineForward"
        }) && Ho(e, [e.anchor, e.offsetOf(e.at(e.position).lastSibling)], "deleteSoftLineForward"),
        deleteToMathFieldStart: e => ji(e, {
            inputType: "deleteHardLineBackward"
        }) && Ho(e, [e.anchor, 0], "deleteHardLineBackward"),
        deleteToMathFieldEnd: e => ji(e, {
            inputType: "deleteHardLineForward"
        }) && Ho(e, [e.anchor, -1], "deleteHardLineForward")
    }, {
        target: "model",
        category: "delete"
    }), uo({
        moveToOpposite: e => {
            const t = e.at(e.position),
                {
                    parent: a
                } = t;
            if (!a) return e.announce("plonk"), !1;
            const i = t.treeBranch;
            let o;
            return "string" == typeof i && (o = {
                superscript: "subscript",
                subscript: "superscript",
                above: "below",
                below: "above"
            } [i]), o ? (a.branch(o) || a.createBranch(o), e.setSelection(e.getBranchRange(e.offsetOf(a), o))) : t.subsupPlacement ? tr(e) : er(e)
        },
        moveBeforeParent: e => {
            const {
                parent: t
            } = e.at(e.position);
            return t ? (e.position = e.offsetOf(t), !0) : (e.announce("plonk"), !1)
        },
        moveAfterParent: e => Qo(e),
        moveToNextPlaceholder: e => ar(e, "forward"),
        moveToPreviousPlaceholder: e => ar(e, "backward"),
        moveToNextChar: e => Zo(e, "forward"),
        moveToPreviousChar: e => Zo(e, "backward"),
        moveUp: e => Zo(e, "upward"),
        moveDown: e => Zo(e, "downward"),
        moveToNextWord: e => Go(e, "forward"),
        moveToPreviousWord: e => Go(e, "backward"),
        moveToGroupStart: e => {
            const t = e.offsetOf(e.at(e.position).firstSibling);
            return t === e.position ? (e.announce("plonk"), !1) : (e.position = t, !0)
        },
        moveToGroupEnd: e => {
            const t = e.offsetOf(e.at(e.position).lastSibling);
            return t === e.position ? (e.announce("plonk"), !1) : (e.position = t, !0)
        },
        moveToMathFieldStart: e => 0 === e.position ? (e.announce("plonk"), !1) : (e.position = 0, !0),
        moveToMathFieldEnd: e => e.position === e.lastOffset ? (e.announce("plonk"), !1) : (e.position = e.lastOffset, !0),
        moveToSuperscript: e => er(e),
        moveToSubscript: e => tr(e)
    }, {
        target: "model",
        category: "selection-anchor"
    }), uo({
        selectGroup: e => {
            const t = ir(e);
            return t || e.announce("plonk"), t
        },
        selectAll: e => e.setSelection(0, e.lastOffset),
        extendSelectionForward: e => {
            const t = e.extendSelection("forward");
            return t || e.announce("plonk"), t
        },
        extendSelectionBackward: e => {
            const t = e.extendSelection("backward");
            return t || e.announce("plonk"), t
        },
        extendToNextWord: e => Go(e, "forward", {
            extend: !0
        }),
        extendToPreviousWord: e => Go(e, "backward", {
            extend: !0
        }),
        extendSelectionUpward: e => Zo(e, "upward", {
            extend: !0
        }),
        extendSelectionDownward: e => Zo(e, "downward", {
            extend: !0
        }),
        extendToNextBoundary: e => Go(e, "forward", {
            extend: !0
        }),
        extendToPreviousBoundary: e => Go(e, "backward", {
            extend: !0
        }),
        extendToGroupStart: e => {
            const t = e.setSelection(e.anchor, e.offsetOf(e.at(e.position).firstSibling));
            return t || e.announce("plonk"), t
        },
        extendToGroupEnd: e => {
            const t = e.setSelection(e.anchor, e.offsetOf(e.at(e.position).lastSibling));
            return t || e.announce("plonk"), t
        },
        extendToMathFieldStart: e => {
            const t = e.setSelection(e.anchor, 0);
            return t || e.announce("plonk"), t
        },
        extendToMathFieldEnd: e => {
            const t = e.setSelection(e.anchor, e.lastOffset);
            return t || e.announce("plonk"), t
        }
    }, {
        target: "model",
        category: "selection-extend"
    });
    class or {
        get element() {
            if (this._element) return this._element;
            const e = document.createElement("div");
            return e.setAttribute("role", "presentation"), e.style.position = "fixed", e.style.contain = "content", e.style.top = "0", e.style.left = "0", e.style.right = "0", e.style.bottom = "0", e.style.zIndex = "var(--scrim-zindex, 10099)", e.style.outline = "none", this.translucent ? (e.style.background = "rgba(255, 255, 255, .2)", e.style.backdropFilter = "contrast(40%)") : e.style.background = "transparent", this._element = e, e
        }
        open(e) {
            var t;
            if ("closed" !== this.state) return;
            this.state = "opening", this.savedActiveElement = rr();
            const {
                element: a
            } = this;
            (null !== (t = null == e ? void 0 : e.root) && void 0 !== t ? t : document.body).appendChild(a), a.addEventListener("click", this), document.addEventListener("touchmove", this, !1), document.addEventListener("scroll", this, !1);
            const i = window.innerWidth - document.documentElement.clientWidth;
            this.savedMarginRight = document.body.style.marginRight, this.savedOverflow = document.body.style.overflow, document.body.style.overflow = "hidden";
            const o = Number.parseFloat(getComputedStyle(document.body).marginRight);
            document.body.style.marginRight = `${o+i}px`, (null == e ? void 0 : e.child) && a.append(e.child), this.state = "open"
        }
        close() {
            var e, t, a, i;
            if ("open" !== this.state) return;
            this.state = "closing", "function" == typeof this.onClose && this.onClose();
            const {
                element: o
            } = this;
            o.removeEventListener("click", this), document.removeEventListener("touchmove", this, !1), document.removeEventListener("scroll", this, !1), o.remove(), document.body.style.overflow = null !== (e = this.savedOverflow) && void 0 !== e ? e : "", document.body.style.marginRight = null !== (t = this.savedMarginRight) && void 0 !== t ? t : "", rr() !== this.savedActiveElement && (null === (i = null === (a = this.savedActiveElement) || void 0 === a ? void 0 : a.focus) || void 0 === i || i.call(a)), o.innerHTML = "", this.state = "closed"
        }
        handleEvent(e) {
            this.preventOverlayClose || (e.target === this._element && "click" === e.type ? (this.close(), e.preventDefault(), e.stopPropagation()) : e.target !== document || "touchmove" !== e.type && "scroll" !== e.type || (this.close(), e.preventDefault(), e.stopPropagation()))
        }
        constructor(e) {
            var t, a;
            this.preventOverlayClose = null !== (t = null == e ? void 0 : e.preventOverlayClose) && void 0 !== t && t, this.translucent = null !== (a = null == e ? void 0 : e.translucent) && void 0 !== a && a, this.state = "closed"
        }
    }

    function rr() {
        var e;
        let t = document.activeElement;
        for (; null === (e = null == t ? void 0 : t.shadowRoot) || void 0 === e ? void 0 : e.activeElement;) t = t.shadowRoot.activeElement;
        return t
    }
    const nr = new Set(["Backquote", "Digit0", "Digit1", "Digit2", "Digit3", "Digit4", "Digit5", "Digit6", "Digit7", "Digit8", "Digit9", "Minus", "Equal", "IntlYen", "KeyQ", "KeyW", "KeyE", "KeyR", "KeyT", "KeyY", "KeyU", "KeyI", "KeyO", "KeyP", "BracketLeft", "BracketRight", "Backslash", "KeyA", "KeyS", "KeyD", "KeyF", "KeyG", "KeyH", "KeyJ", "KeyK", "KeyL", "Semicolon", "Quote", "IntlBackslash", "KeyZ", "KeyX", "KeyC", "KeyV", "KeyB", "KeyN", "KeyM", "Comma", "Period", "Slash", "IntlRo", "Space", "Numpad0", "Numpad1", "Numpad2", "Numpad3", "Numpad4", "Numpad5", "Numpad6", "Numpad7", "Numpad8", "Numpad9", "NumpadAdd", "NumpadComma", "NumpadDecimal", "NumpadDivide", "NumpadEqual", "NumpadHash", "NumpadMultiply", "NumpadParenLeft", "NumpadParenRight", "NumpadStar", "NumpadSubstract"]);

    function sr(e) {
        return !e.ctrlKey && !e.metaKey && "Dead" !== e.key && ("" === e.code || nr.has(e.code))
    }

    function lr(e) {
        const t = [];
        return (e = function(e) {
            if (e.code) return e;
            const t = Object.entries(Ki().mapping);
            let a = !1,
                i = !1,
                o = "";
            for (let r = 0; r < 4; r++) {
                for (const [n, s] of t)
                    if (s[r] === e.key) {
                        o = n, 3 === r ? (a = !0, i = !0) : 2 === r ? a = !0 : 1 === r && (i = !0);
                        break
                    } if (o) break
            }
            return new KeyboardEvent(e.type, {
                ...e,
                altKey: a,
                shiftKey: i,
                code: o
            })
        }(e)).ctrlKey && t.push("ctrl"), e.metaKey && t.push("meta"), e.altKey && t.push("alt"), e.shiftKey && t.push("shift"), 0 === t.length ? "[" + e.code + "]" : (t.push("[" + e.code + "]"), t.join("+"))
    }

    function dr() {
        var e;
        if (!o()) return null;
        let t = document.activeElement;
        for (; null === (e = null == t ? void 0 : t.shadowRoot) || void 0 === e ? void 0 : e.activeElement;) t = t.shadowRoot.activeElement;
        return t
    }

    function cr(e) {
        var t;
        if (!e) return "";
        let a;
        return "Unidentified" === e.key && e.target && (a = e.target.value), a = null !== (t = null != a ? a : e.key) && void 0 !== t ? t : e.code, /^(Dead|Return|Enter|Tab|Escape|Delete|PageUp|PageDown|Home|End|Help|ArrowLeft|ArrowRight|ArrowUp|ArrowDown)$/.test(a) && (a = ""), a
    }
    class ur {
        get maximumDepth() {
            return 1e3
        }
        reset() {
            this.stack = [], this.index = -1
        }
        startRecording() {
            this.recording = !0
        }
        canUndo() {
            return this.index > 0
        }
        canRedo() {
            return this.index !== this.stack.length - 1
        }
        undo() {
            return !!this.canUndo() && (this.model.setState(this.stack[this.index - 1], {
                suppressChangeNotifications: !1,
                type: "undo"
            }), this.index -= 1, this.canCoalesce = !1, !0)
        }
        redo() {
            return !!this.canRedo() && (this.index += 1, this.model.setState(this.stack[this.index], {
                suppressChangeNotifications: !1,
                type: "redo"
            }), this.canCoalesce = !1, !0)
        }
        pop() {
            this.canUndo() && (this.index -= 1, this.stack.pop())
        }
        snapshot() {
            return !!this.recording && (this.stack.splice(this.index + 1, this.stack.length - this.index - 1), this.stack.push(this.model.getState()), this.index++, this.stack.length > this.maximumDepth && this.stack.shift(), this.canCoalesce = !1, !0)
        }
        snapshotAndCoalesce() {
            if (!this.recording) return !1;
            this.canCoalesce && this.pop();
            const e = this.snapshot();
            return this.canCoalesce = !0, e
        }
        constructor(e) {
            this.recording = !1, this.canCoalesce = !1, this.model = e, this.reset()
        }
    }
    var pr = '.ML__keyboard{--hue:206;--keyboard-background:rgba(209,213,217,.97);--keyboard-text:#000;--keyboard-text-active:var(--primary,hsl(var(--hue),40%,50%));--keyboard-background-border:#ddd;--keycap-background:#fff;--keycap-background-active:#e5e5e5;--keycap-background-border:#e5e6e9;--keycap-background-border-bottom:#8d8f92;--keycap-text:#000;--keycap-text-active:#fff;--keycap-secondary-text:#000;--keycap-modifier-background:#b9bdc7;--keycap-modifier-border:#c5c9d0;--keycap-modifier-border-bottom:#989da6;--keyboard-alternate-background:#fff;--keyboard-alternate-background-active:var(--primary,hsl(var(--hue),40%,50%));--keyboard-alternate-text:var(--keycap-text,#000);--keyboard-alternate-text-active:#fff;--keyboard-alternate-key-length:70px;--keyboard-alternate-key-font-size:30px;--keyboard-alternate-key-aside-font-size:12px;--keyboard-height:276px;--keycap-height:52px;--keycap-font-size:20px;--keycap-small-font-size:calc(var(--keycap-font-size)*0.8);--keycap-extra-small-font-size:calc(var(--keycap-font-size)/1.42);--keycap-tt-font-size:calc(var(--keycap-font-size)*1.5);height:100%;left:0;pointer-events:none;position:fixed;top:0;width:100%;z-index:var(--keyboard-zindex,105)}.ML__keyboard.is-visible .ML__keyboard--plate{opacity:1;transform:translateY(calc(var(--keyboard-height, 276px)*-1));transition-timing-function:cubic-bezier(.4,0,1,1);visibility:visible}.ML__keyboard.alternate-keys{align-content:center;background-color:var(--keyboard-alternate-background);border-radius:6px;bottom:auto;box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22);box-sizing:content-box;display:flex;flex-direction:row;justify-content:center;max-width:286px;position:fixed;text-align:center;top:0;transform:none;transition:none;visibility:hidden;z-index:calc(var(--keyboard-zindex, 105) + 1)}@media only screen and (max-height:412px){.ML__keyboard.alternate-keys{max-width:320px}}.ML__keyboard.alternate-keys.is-visible{visibility:visible}.ML__keyboard.alternate-keys.compact{--keyboard-alternate-key-length:50px;--keyboard-alternate-key-font-size:24px;--keyboard-alternate-key-aside-font-size:10px}.ML__keyboard.alternate-keys ul{display:flex;flex-flow:row wrap-reverse;justify-content:center;list-style:none;margin:3px;padding:0}.ML__keyboard.alternate-keys ul>li{fill:currentColor;align-items:center;background:transparent;border:1px solid transparent;border-radius:5px;box-sizing:border-box;color:var(--keyboard-alternate-text);display:flex;flex-flow:column;font-size:var(--keyboard-alternate-key-font-size);height:var(--keyboard-alternate-key-length);justify-content:center;margin:0;pointer-events:all;width:var(--keyboard-alternate-key-length)}@media only screen and (max-height:412px){.ML__keyboard.alternate-keys ul>li{font-size:24px;height:50px;width:50px}}.ML__keyboard.alternate-keys ul>li.is-active,.ML__keyboard.alternate-keys ul>li.is-pressed,.ML__keyboard.alternate-keys ul>li:hover{background:var(--keyboard-alternate-background-active);color:var(--keyboard-alternate-text-active)}.ML__keyboard.alternate-keys ul>li.small{font-size:var(--keycap-small-font-size,16px)}.ML__keyboard.alternate-keys ul>li.small-button{background:#fbfbfb;height:42px;margin:2px;width:42px}.ML__keyboard.alternate-keys ul>li.small-button:hover{background:var(--keyboard-alternate-background-active)}.ML__keyboard.alternate-keys ul>li.box>div,.ML__keyboard.alternate-keys ul>li.box>span{border:1px dashed rgba(0,0,0,.24)}.ML__keyboard.alternate-keys ul>li .warning{align-items:center;background:#cd0030;border-radius:5px;color:#fff;display:flex;justify-content:center;min-height:60px;min-width:60px;padding:5px}.ML__keyboard.alternate-keys ul>li .warning.is-active,.ML__keyboard.alternate-keys ul>li .warning.is-pressed,.ML__keyboard.alternate-keys ul>li .warning:hover{background:red}.ML__keyboard.alternate-keys ul>li .warning svg.svg-glyph{height:50px;width:50px}.ML__keyboard.alternate-keys ul>li aside{font-size:var(--keyboard-alternate-key-aside-font-size);line-height:12px;opacity:.78;padding-top:2px}.ML__keyboard .ML__keyboard--plate{-webkit-backdrop-filter:grayscale(50%);backdrop-filter:grayscale(50%);background-color:var(--keyboard-background);border:1px solid var(--keyboard-background-border);bottom:calc(var(--keyboard-height, 276px)*-1);box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);box-sizing:border-box;cursor:pointer;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:16px;font-weight:400;left:0;margin:0;opacity:0;padding-top:5px;pointer-events:all;position:absolute;text-shadow:none;touch-action:none;transform:translate(0);transition:.28s cubic-bezier(0,0,.2,1);transition-property:transform,opacity;-webkit-user-select:none;user-select:none;visibility:hidden;width:100%}.ML__keyboard .ML__keyboard--plate .tex{font-family:KaTeX_Math,KaTeX_Main,Cambria Math,Asana Math,OpenSymbol,Symbola,STIX,Times,serif!important}.ML__keyboard .ML__keyboard--plate .tex-math{font-family:KaTeX_Math,Cambria Math,Asana Math,OpenSymbol,Symbola,STIX,Times,serif!important}.ML__keyboard .ML__keyboard--plate .tt{font-family:IBM Plex Mono,Source Code Pro,Consolas,Roboto Mono,Menlo,Bitstream Vera Sans Mono,DejaVu Sans Mono,Monaco,Courier,monospace!important;font-size:var(--keycap-tt-font-size,30px);font-weight:400}.ML__keyboard .ML__keyboard--plate>div.keyboard-layer{display:none;outline:none}.ML__keyboard .ML__keyboard--plate>div.keyboard-layer.is-visible{display:flex;flex-flow:column}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar{align-self:center;display:flex;flex-flow:row;justify-content:space-between;min-width:736px}@media only screen and (min-width:768px) and (max-width:1024px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar{min-width:556px}}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar{max-width:100vw;min-width:365px;width:365px}}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar svg{height:20px;width:20px}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar svg{height:13px;width:17px}}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>.left{display:flex;flex-flow:row;justify-content:flex-start;position:relative}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>.right{display:flex;flex-flow:row;justify-content:flex-end}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div{fill:currentColor;align-items:baseline;background:0;border:none;border-bottom:2px solid transparent;box-shadow:none;color:var(--keyboard-text);cursor:pointer;display:flex;font-size:110%;justify-content:center;margin:7px 4px 6px;min-height:0;padding:4px 10px}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.disabled svg,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.disabled.is-pressed svg,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.disabled:hover svg{color:var(--keyboard-text);opacity:.2}@media only screen and (max-width:414px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div{font-size:100%;padding:0 6px 0 0}}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div{font-size:90%;padding-left:4px;padding-right:4px}}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.is-active,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.is-pressed,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div:active,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div:hover{color:var(--keyboard-text-active)}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.selected{border-bottom:2px solid var(--keyboard-text-active);color:var(--keyboard-text-active);margin-bottom:8px;padding-bottom:0}.ML__keyboard .ML__keyboard--plate [data-tooltip]{position:relative}.ML__keyboard .ML__keyboard--plate [data-tooltip]:after{background:#616161;border-radius:2px;bottom:100%;box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.2);color:#fff;content:attr(data-tooltip);display:inline-table;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:12px;font-weight:400;max-width:200px;opacity:0;padding:8px;position:absolute;text-align:center;top:inherit;transform:scale(.5);transition:all .15s cubic-bezier(.4,0,1,1) 1s;width:max-content;z-index:2}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate [data-tooltip]:after{font-size:16px;padding:8px 16px}}.ML__keyboard .ML__keyboard--plate [data-tooltip]:hover{position:relative}.ML__keyboard .ML__keyboard--plate [data-tooltip]:hover:after{opacity:1;transform:scale(1)}.ML__keyboard .ML__keyboard--plate div .rows{align-items:center;border:0;border-collapse:separate;clear:both;display:flex;flex-flow:column;margin:auto}.ML__keyboard .ML__keyboard--plate div .rows>ul{height:40px;list-style:none;margin:0 0 3px;padding:0}.ML__keyboard .ML__keyboard--plate div .rows>ul>li{fill:currentColor;-webkit-tap-highlight-color:transparent;align-items:center;background:var(--keycap-background);border:1px solid var(--keycap-background-border);border-bottom-color:var(--keycap-background-border-bottom);border-radius:5px;box-sizing:border-box;color:var(--keycap-text);display:flex;flex-flow:column;float:left;font-size:var(--keycap-font-size,20px);height:40px;justify-content:center;margin-right:2px;overflow:hidden;padding:8px 0;position:relative;text-align:center;-webkit-user-select:none;user-select:none;vertical-align:top;width:34px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li:last-child{margin-right:0}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.small{font-size:var(--keycap-small-font-size,16px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.tt{color:var(--keyboard-text-active)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.bottom{justify-content:flex-end}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.left{align-items:flex-start;padding-left:4px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.right{align-items:flex-end;padding-right:4px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li svg.svg-glyph{height:20px;width:20px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li .warning{align-items:center;background:#cd0030;border-radius:100%;color:#fff;display:flex;height:25px;justify-content:center;margin-bottom:-2px;min-height:25px;min-width:25px;padding:5px;width:25px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li .warning svg.svg-glyph{height:16px;width:16px}@media only screen and (max-width:768px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li .warning{height:16px;min-height:16px;min-width:16px;width:16px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li .warning svg.svg-glyph{height:14px;width:14px}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w0{width:0}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w5{width:16px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w15{width:52px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w20{width:70px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w50{width:178px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.separator{background:transparent;border:none;pointer-events:none}@media only screen and (max-width:560px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li.if-wide{display:none}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.tex-math{font-size:25px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.is-pressed,.ML__keyboard .ML__keyboard--plate div .rows>ul>li:hover{background:var(--keycap-background-active);color:var(--keyboard-text-active)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action:active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.keycap.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.keycap:active{color:var(--keyboard-text-active);transform:translateY(calc(var(--keycap-height, 52px)*-.2)) scale(1.4);z-index:calc(var(--keyboard-zindex, 105) - 5)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier:active{background:var(--keyboard-text-active);color:var(--keycap-text-active)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.font-glyph,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.font-glyph{font-size:18px}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.font-glyph,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.font-glyph{font-size:16px}}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li.fnbutton{font-size:12px}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.bigfnbutton{font-size:var(--keycap-extra-small-font-size,14px)}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li.bigfnbutton{font-size:calc(var(--keycap-extra-small-font-size, 14px)/1.55)}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier{background-color:var(--keycap-modifier-background);border-color:var(--keycap-modifier-border);border-bottom-color:var(--keycap-modifier-border-bottom);font-size:65%;font-weight:100}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected{color:var(--keyboard-text-active)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected.is-pressed,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected:active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected:hover,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected.is-pressed,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected:active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected:hover{color:#fff}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.keycap.w50{font-size:80%;font-weight:100;padding-top:10px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li small{color:#555}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li small{font-size:9px}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li aside{color:#666;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:10px;line-height:10px}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li aside{display:none}}@media only screen and (max-width:414px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li{margin-right:2px;width:calc(10vw - 2px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w5{width:calc(5vw - 2px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w15{width:calc(15vw - 2px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w20{width:calc(20vw - 2px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w50{width:calc(50vw - 2px)}}@media only screen and (min-width:415px) and (max-width:768px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li{margin-right:3px;width:37px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w5{width:17px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w15{width:57px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w20{width:77px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w50{width:197px}}@media only screen and (min-width:768px) and (max-width:1024px){.ML__keyboard .ML__keyboard--plate div .rows>ul{height:var(--keycap-height,52px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li{height:var(--keycap-height,52px);margin-right:4px;width:51px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w5{width:23.5px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w15{width:78.5px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w20{width:106px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w50{width:271px}}@media only screen and (min-width:1025px){.ML__keyboard .ML__keyboard--plate div .rows>ul{height:var(--keycap-height,52px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li{height:var(--keycap-height,52px);margin-right:6px;width:66px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.action,.ML__keyboard .ML__keyboard--plate div .rows>ul>.modifier{font-size:80%}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w5{width:30px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w15{width:102px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w20{width:138px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w50{width:354px}}@media (prefers-color-scheme:dark){body:not([theme=light]) .ML__keyboard{--hue:206;--keyboard-background:#4e6373;--keyboard-background:#4e6073;--keyboard-background:hsl(var(--hue),19%,38%);--keyboard-text:#f0f0f0;--keyboard-text-active:hsl(var(--hue),100%,60%);--keyboard-background-border:#333;--keycap-background:hsl(var(--hue),25%,39%);--keycap-background-active:hsl(var(--hue),35%,42%);--keycap-background-border:hsl(var(--hue),25%,35%);--keycap-background-border-bottom:#426b8a;--keycap-text:#d0d0d0;--keycap-text-active:#000;--keycap-secondary-text:#fff;--keycap-modifier-background:hsl(var(--hue),35%,40%);--keycap-modifier-border:hsl(var(--hue),35%,35%);--keycap-modifier-border-bottom:hsl(var(--hue),35%,42%);--keyboard-alternate-background:hsl(var(--hue),19%,38%)}}body[theme=dark] .ML__keyboard{--hue:206;--keyboard-background:hsl(var(--hue),19%,38%);--keyboard-text:#f0f0f0;--keyboard-text-active:hsl(var(--hue),100%,60%);--keyboard-background-border:#333;--keycap-background:hsl(var(--hue),25%,39%);--keycap-background-active:hsl(var(--hue),35%,42%);--keycap-background-border:hsl(var(--hue),25%,35%);--keycap-background-border-bottom:#426b8a;--keycap-text:#d0d0d0;--keycap-text-active:#000;--keycap-secondary-text:#fff;--keycap-modifier-background:hsl(var(--hue),35%,40%);--keycap-modifier-border:hsl(var(--hue),35%,35%);--keycap-modifier-border-bottom:hsl(var(--hue),35%,42%);--keyboard-alternate-background:hsl(var(--hue),19%,38%)}div.ML__keyboard.material{--keyboard-background:rgba(209,213,217,.9);--keyboard-background-border:#ddd;--keycap-background:transparent;--keycap-background-active:#cccfd1;--keycap-background-border:transparent;--keyboard-alternate-background:#efefef;--keyboard-alternate-text:#000;font-family:Roboto,sans-serif}div.ML__keyboard.material.alternate-keys{background:var(--keyboard-alternate-background);border:1px solid transparent;border-radius:5px;box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22)}div.ML__keyboard.material.alternate-keys ul li.is-active,div.ML__keyboard.material.alternate-keys ul li.is-pressed,div.ML__keyboard.material.alternate-keys ul li:active,div.ML__keyboard.material.alternate-keys ul li:hover{fill:currentColor;background:#5f97fc;border:1px solid transparent;color:#fff}div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar>div>div{font-size:16px}div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div div:active,div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div div:hover,div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div.div.is-active,div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div.div.is-pressed{fill:currentColor;color:#5f97fc}div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar>div>.selected{fill:currentColor;border-bottom:2px solid #5f97fc;color:#5f97fc;margin-bottom:8px;padding-bottom:0}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap{fill:currentColor;background:transparent;border:1px solid transparent;border-radius:5px;color:var(--keycap-text);transition:none}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap.tt{color:#5f97fc}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "]{background:#e0e0e0;height:20px;margin-bottom:10px;margin-top:10px}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "].is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "].is-pressed,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "]:active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "]:hover{background:#d0d0d0;box-shadow:none;transform:none}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]):hover{background:var(--keycap-background-active);border:1px solid transparent;box-shadow:none}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-pressed,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]):active{background:var(--keyboard-alternate-background);box-shadow:0 10px 20px rgba(0,0,0,.19),0 6px 6px rgba(0,0,0,.23);color:var(--keyboard-alternate-text)}@media only screen and (max-width:767px){div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-pressed,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]):active{box-shadow:0 10px 20px rgba(0,0,0,.19),0 6px 6px rgba(0,0,0,.23);font-size:10px;justify-content:flex-start;margin-left:10px;margin-right:10px;padding:2px 0 0;transform:translateY(-10px) scale(2);transition:none;vertical-align:top;width:19.5px;z-index:calc(var(--ML_keyboard-zindex, 105) - 5)}}@media only screen and (max-width:414px){div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-pressed,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]):active{width:16.5px}}@media only screen and (max-width:767px){div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:last-child.is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:last-child:active{margin-left:14px;margin-right:0}}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier{fill:currentColor;background:transparent;border:0;color:#869096;font-size:16px;transition:none}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action.selected,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier.selected{border-bottom:2px solid #5f97fc;border-radius:0;color:#5f97fc}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action.is-active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action.is-pressed,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action:active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action:hover,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier.is-active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier.is-pressed,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier:active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier:hover{background:var(--keycap-background-active);border:0;box-shadow:none;color:var(--keycap-text)}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton{background:transparent;border:0}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.selected,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.selected{fill:currentColor;border-bottom:2px solid #5f97fc;border-radius:0;color:#5f97fc}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.is-active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.is-pressed,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton:active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton:hover,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.is-active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.is-pressed,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton:active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton:hover{fill:currentColor;background:var(--keycap-background-active);border:0;box-shadow:none;color:#5f97fc}@media (prefers-color-scheme:dark){body:not([theme=light]) div.ML__keyboard.material{--hue:198;--keyboard-background:hsl(var(--hue),19%,18%);--keyboard-text:#d4d6d7;--keyboard-text-active:#5f97fc;--keyboard-background-border:#333;--keycap-background:hsl(var(--hue),25%,39%);--keycap-background-active:#5f97fc;--keycap-background-border:transparent;--keycap-background-border-bottom:transparent;--keycap-text:#d0d0d0;--keycap-text-active:#d4d6d7;--keycap-secondary-text:#5f97fc;--keycap-modifier-background:hsl(var(--hue),35%,40%);--keycap-modifier-border:hsl(var(--hue),35%,35%);--keycap-modifier-border-bottom:hsl(var(--hue),35%,42%);--keyboard-alternate-background:hsl(var(--hue),8%,2%);--keyboard-alternate-background-active:hsl(var(--hue),35%,42%);--keyboard-alternate-text:#d1d1d1}}body[theme=dark] div.ML__keyboard.material{--hue:198;--keyboard-background:hsl(var(--hue),19%,18%);--keyboard-text:#d4d6d7;--keyboard-text-active:#5f97fc;--keyboard-background-border:#333;--keycap-background:hsl(var(--hue),25%,39%);--keycap-background-active:#5f97fc;--keycap-background-border:transparent;--keycap-background-border-bottom:transparent;--keycap-text:#d0d0d0;--keycap-text-active:#d4d6d7;--keycap-secondary-text:#5f97fc;--keycap-modifier-background:hsl(var(--hue),35%,40%);--keycap-modifier-border:hsl(var(--hue),35%,35%);--keycap-modifier-border-bottom:hsl(var(--hue),35%,42%);--keyboard-alternate-background:hsl(var(--hue),8%,2%);--keyboard-alternate-background-active:hsl(var(--hue),35%,42%);--keyboard-alternate-text:#d1d1d1}';

    function hr(e, t, a) {
        var i;
        let o, r, n, s, l;
        "object" == typeof(i = a) && ("default" in i || "pressed" in i) ? (a.default && (t.dataset.command = JSON.stringify(a.default)), a.alt && (t.dataset.commandAlt = JSON.stringify(a.alt)), a.altshift && (t.dataset.commandAltshift = JSON.stringify(a.altshift)), a.shift && (t.dataset.commandShift = JSON.stringify(a.shift)), a.pressed && (t.dataset.commandPressed = JSON.stringify(a.pressed)), a.pressAndHoldStart && (t.dataset.commandPressAndHoldStart = JSON.stringify(a.pressAndHoldStart)), a.pressAndHoldEnd && (t.dataset.commandPressAndHoldEnd = JSON.stringify(a.pressAndHoldEnd))) : t.dataset.command = JSON.stringify(a), ii(t, "mousedown touchstart:passive", (a => {
            if ("mousedown" !== a.type || 1 === a.buttons) {
                a.stopPropagation(), "touchstart" !== a.type && a.preventDefault(), document.body.style["-webkit-user-select"] = "none", t.classList.add("is-pressed"), o = Date.now(), "touchstart" === a.type && (n = a.changedTouches[0].identifier);
                const i = t.getAttribute("data-command-pressed");
                i && e(JSON.parse(i));
                const s = t.getAttribute("data-command-press-and-hold-start");
                s && (r = t, l && clearTimeout(l), l = setTimeout((() => {
                    t.classList.contains("is-pressed") && e(JSON.parse(s))
                }), 300))
            }
        })), ii(t, "mouseleave touchcancel", (() => {
            t.classList.remove("is-pressed")
        })), ii(t, "touchmove:passive", (e => {
            for (let t = 0; t < e.changedTouches.length; t++)
                if (e.changedTouches[t].identifier === n) {
                    const a = document.elementsFromPoint(e.changedTouches[t].clientX, e.changedTouches[t].clientY),
                        i = a[a.length - 1];
                    i !== s && s && (s.dispatchEvent(new MouseEvent("mouseleave"), {
                        bubbles: !0
                    }), s = null), i && (s = i, i.dispatchEvent(new MouseEvent("mouseenter", {
                        bubbles: !0,
                        buttons: 1
                    })))
                }
        })), ii(t, "mouseenter", (e => {
            1 === e.buttons && t.classList.add("is-pressed")
        })), ii(t, "mouseup touchend click", (a => {
            if (document.body.style["-webkit-user-select"] = "", s) {
                a.stopPropagation(), a.preventDefault();
                const e = s;
                return s = null, void e.dispatchEvent(new MouseEvent("mouseup", {
                    bubbles: !0
                }))
            }
            if (t.classList.remove("is-pressed"), t.classList.add("is-active"), "click" === a.type && 0 !== a.detail) return a.stopPropagation(), void a.preventDefault();
            setTimeout((() => t.classList.remove("is-active")), 150);
            let i = t.getAttribute("data-command-press-and-hold-end");
            const n = Date.now();
            (t !== r || n < o + 300) && (i = null), !i && a.altKey && a.shiftKey && (i = t.getAttribute("data-command-altshift")), !i && a.altKey && (i = t.getAttribute("data-command-alt")), !i && a.shiftKey && (i = t.getAttribute("data-command-shift")), i || (i = t.getAttribute("data-command")), i && e(JSON.parse(i)), a.stopPropagation(), a.preventDefault()
        }))
    }
    let mr;

    function fr() {
        var e;
        r();
        const t = document.querySelector("#mathlive-alternate-keys-panel");
        return t && (t.classList.remove("is-visible"), t.innerHTML = ""), null === (e = or.scrim) || void 0 === e || e.close(), !1
    }
    class yr {
        setOptions(e) {
            var t, a;
            let i = "";
            if (this._element) {
                const e = this._element.querySelector("div.keyboard-layer.is-visible");
                e && (i = null !== (t = e.getAttribute("data-layer")) && void 0 !== t ? t : ""), this._element.remove(), this._element = void 0
            }
            if (this.options = e, this.visible) {
                this.buildAndAttachElement(e.virtualKeyboardTheme);
                const t = this.element.querySelector(`.keyboard-layer[data-layer="${i}"]`);
                t && (null === (a = this.element.querySelector(".keyboard-layer.is-visible")) || void 0 === a || a.classList.remove("is-visible"), t.classList.add("is-visible")), this.element.classList.add("is-visible")
            }
        }
        get element() {
            return this._element
        }
        set element(e) {
            var t;
            this._element !== e && (null === (t = this._element) || void 0 === t || t.remove(), this._element = e)
        }
        get visible() {
            return this._visible
        }
        set visible(e) {
            this._visible = e
        }
        get height() {
            var e, t;
            return null !== (t = null === (e = this.element) || void 0 === e ? void 0 : e.offsetHeight) && void 0 !== t ? t : 0
        }
        buildAndAttachElement(e) {
            var t;
            this.element = function(e, t) {
                var a, i, o, n;
                r();
                let s = '<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n\n    <symbol id="svg-delete-backward" viewBox="0 0 576 512">\n      <path d="M432.1 208.1L385.9 256L432.1 303C442.3 312.4 442.3 327.6 432.1 336.1C423.6 346.3 408.4 346.3 399 336.1L352 289.9L304.1 336.1C295.6 346.3 280.4 346.3 271 336.1C261.7 327.6 261.7 312.4 271 303L318.1 256L271 208.1C261.7 199.6 261.7 184.4 271 175C280.4 165.7 295.6 165.7 304.1 175L352 222.1L399 175C408.4 165.7 423.6 165.7 432.1 175C442.3 184.4 442.3 199.6 432.1 208.1V208.1zM512 64C547.3 64 576 92.65 576 128V384C576 419.3 547.3 448 512 448H205.3C188.3 448 172 441.3 160 429.3L9.372 278.6C3.371 272.6 0 264.5 0 256C0 247.5 3.372 239.4 9.372 233.4L160 82.75C172 70.74 188.3 64 205.3 64L512 64zM528 128C528 119.2 520.8 112 512 112H205.3C201 112 196.9 113.7 193.9 116.7L54.63 256L193.9 395.3C196.9 398.3 201 400 205.3 400H512C520.8 400 528 392.8 528 384V128z"/>\n    </symbol>\n\n    <symbol id="svg-shift" viewBox="0 0 384 512">\n      <path d="M2.438 252.3C7.391 264.2 19.06 272 32 272h80v160c0 26.51 21.49 48 48 48h64C250.5 480 272 458.5 272 432v-160H352c12.94 0 24.61-7.797 29.56-19.75c4.953-11.97 2.219-25.72-6.938-34.88l-160-176C208.4 35.13 200.2 32 192 32S175.6 35.13 169.4 41.38l-160 176C.2188 226.5-2.516 240.3 2.438 252.3zM192 86.63L313.4 224H224v208H160V224H70.63L192 86.63z"/>\n    </symbol>\n\n    <symbol id="svg-commit" viewBox="0 0 512 512">\n      <path d="M135 432.1l-128-128C2.344 300.3 0 294.2 0 288s2.344-12.28 7.031-16.97l128-128c9.375-9.375 24.56-9.375 33.94 0s9.375 24.56 0 33.94L81.94 264H464v-208C464 42.75 474.8 32 488 32S512 42.75 512 56V288c0 13.25-10.75 24-24 24H81.94l87.03 87.03c9.375 9.375 9.375 24.56 0 33.94S144.4 442.3 135 432.1z"/>\n    </symbol>\n\n    <symbol id="svg-command" viewBox="0 0 640 512">\n      <path d="M34.495 36.465l211.051 211.05c4.686 4.686 4.686 12.284 0 16.971L34.495 475.535c-4.686 4.686-12.284 4.686-16.97 0l-7.071-7.07c-4.686-4.686-4.686-12.284 0-16.971L205.947 256 10.454 60.506c-4.686-4.686-4.686-12.284 0-16.971l7.071-7.07c4.686-4.687 12.284-4.687 16.97 0zM640 468v-10c0-6.627-5.373-12-12-12H300c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h328c6.627 0 12-5.373 12-12z"/>\n    </symbol>\n\n    <symbol id="svg-undo" viewBox="0 0 512 512">\n      <path d="M20 8h10c6.627 0 12 5.373 12 12v110.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H180c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V20c0-6.627 5.373-12 12-12z"/>\n    </symbol>\n    <symbol id="svg-redo" viewBox="0 0 512 512">\n      <path d="M492 8h-10c-6.627 0-12 5.373-12 12v110.625C426.804 57.047 346.761 7.715 255.207 8.001 118.82 8.428 7.787 120.009 8 256.396 8.214 393.181 119.166 504 256 504c63.926 0 122.202-24.187 166.178-63.908 5.113-4.618 5.354-12.561.482-17.433l-7.069-7.069c-4.503-4.503-11.749-4.714-16.482-.454C361.218 449.238 311.065 470 256 470c-117.744 0-214-95.331-214-214 0-117.744 95.331-214 214-214 82.862 0 154.737 47.077 190.289 116H332c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h160c6.627 0 12-5.373 12-12V20c0-6.627-5.373-12-12-12z"/>\n    </symbol>\n    <symbol id="svg-arrow-left" viewBox="0 0 320 512">\n      <path d="M206.7 464.6l-183.1-191.1C18.22 267.1 16 261.1 16 256s2.219-11.97 6.688-16.59l183.1-191.1c9.152-9.594 24.34-9.906 33.9-.7187c9.625 9.125 9.938 24.37 .7187 33.91L73.24 256l168 175.4c9.219 9.5 8.906 24.78-.7187 33.91C231 474.5 215.8 474.2 206.7 464.6z"/>\n    </symbol>\n    <symbol id="svg-arrow-right" viewBox="0 0 320 512">\n      <path d="M113.3 47.41l183.1 191.1c4.469 4.625 6.688 10.62 6.688 16.59s-2.219 11.97-6.688 16.59l-183.1 191.1c-9.152 9.594-24.34 9.906-33.9 .7187c-9.625-9.125-9.938-24.38-.7187-33.91l168-175.4L78.71 80.6c-9.219-9.5-8.906-24.78 .7187-33.91C88.99 37.5 104.2 37.82 113.3 47.41z"/>\n    </symbol>\n    <symbol id="svg-tab" viewBox="0 0 448 512">\n      <path d="M32 217.1c0-8.8 7.2-16 16-16h144v-93.9c0-7.1 8.6-10.7 13.6-5.7l143.5 143.1c6.3 6.3 6.3 16.4 0 22.7L205.6 410.4c-5 5-13.6 1.5-13.6-5.7v-93.9H48c-8.8 0-16-7.2-16-16v-77.7m-32 0v77.7c0 26.5 21.5 48 48 48h112v61.9c0 35.5 43 53.5 68.2 28.3l143.6-143c18.8-18.8 18.8-49.2 0-68L228.2 78.9c-25.1-25.1-68.2-7.3-68.2 28.3v61.9H48c-26.5 0-48 21.6-48 48zM436 64h-8c-6.6 0-12 5.4-12 12v360c0 6.6 5.4 12 12 12h8c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12z"/>\n    </symbol>\n    <symbol id="svg-copy" viewBox="0 0 448 512">\n      <path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM352 32.491a15.88 15.88 0 0 1 7.431 4.195l51.882 51.883A15.885 15.885 0 0 1 415.508 96H352V32.491zM288 464c0 8.822-7.178 16-16 16H48c-8.822 0-16-7.178-16-16V144c0-8.822 7.178-16 16-16h80v240c0 26.51 21.49 48 48 48h112v48zm128-96c0 8.822-7.178 16-16 16H176c-8.822 0-16-7.178-16-16V48c0-8.822 7.178-16 16-16h144v72c0 13.2 10.8 24 24 24h72v240z"/>\n    </symbol>\n    <symbol id="svg-angle-double-right" viewBox="0 0 320 512">\n      <path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17zm128-17l-117.8-116c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17L255.3 256 153.1 356.4c-4.7 4.7-4.7 12.3 0 17l7.1 7.1c4.7 4.7 12.3 4.7 17 0l117.8-116c4.6-4.7 4.6-12.3-.1-17z"/>\n    </symbol>\n    <symbol id="svg-angle-double-left" viewBox="0 0 320 512">\n      <path d="M153.1 247.5l117.8-116c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L192.7 256l102.2 100.4c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L153 264.5c-4.6-4.7-4.6-12.3.1-17zm-128 17l117.8 116c4.7 4.7 12.3 4.7 17 0l7.1-7.1c4.7-4.7 4.7-12.3 0-17L64.7 256l102.2-100.4c4.7-4.7 4.7-12.3 0-17l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L25 247.5c-4.6 4.7-4.6 12.3.1 17z"/>\n    </symbol>\n    <symbol id="svg-trash" viewBox="0 0 448 512">\n      <path d="M336 64l-33.6-44.8C293.3 7.1 279.1 0 264 0h-80c-15.1 0-29.3 7.1-38.4 19.2L112 64H24C10.7 64 0 74.7 0 88v2c0 3.3 2.7 6 6 6h26v368c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V96h26c3.3 0 6-2.7 6-6v-2c0-13.3-10.7-24-24-24h-88zM184 32h80c5 0 9.8 2.4 12.8 6.4L296 64H152l19.2-25.6c3-4 7.8-6.4 12.8-6.4zm200 432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V96h320v368zm-176-44V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm-80 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm160 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12z"/>\n    </symbol>\n</svg>\n        ';
                e.create(), vr["foreground-color"] = [];
                for (const e of Object.keys(f)) vr["foreground-color"].push({
                    class: "small-button",
                    content: '<span style="border-radius:50%;width:32px;height:32px; box-sizing: border-box; border: 3px solid ' + f[e] + '"></span>',
                    command: ["applyStyle", {
                        color: e
                    }]
                });
                vr["background-color"] = [];
                for (const e of Object.keys(m)) vr["background-color"].push({
                    class: "small-button",
                    content: '<span style="border-radius:50%;width:32px;height:32px; background:' + m[e] + '"></span>',
                    command: ["applyStyle", {
                        backgroundColor: e
                    }]
                });
                kr = {
                    ...vr
                };
                for (const e of Object.keys(kr)) kr[e] = kr[e].slice();
                for (let e = 0; e < 26; e++) {
                    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" [e];
                    kr[t] || (kr[t] = []), kr[t].unshift({
                        latex: "\\mathbb{" + t + "}",
                        aside: "blackboard",
                        insert: "\\mathbb{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathbf{" + t + "}",
                        aside: "bold",
                        insert: "\\mathbf{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathsf{" + t + "}",
                        aside: "sans",
                        insert: "\\mathsf{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathtt{" + t + "}",
                        aside: "monospace",
                        insert: "\\mathtt{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathcal{" + t + "}",
                        aside: "calligraphy",
                        insert: "\\mathcal{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathfrak{" + t + "}",
                        aside: "fraktur",
                        insert: "\\mathfrak{" + t + "}"
                    })
                }
                for (let e = 0; e <= 26; e++) {
                    const t = "abcdefghijklmnopqrstuvwxyz" [e];
                    kr[t] || (kr[t] = []), kr[t].unshift({
                        latex: "\\mathsf{" + t + "}",
                        aside: "sans",
                        insert: "\\mathsf{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathbf{" + t + "}",
                        aside: "bold",
                        insert: "\\mathbf{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathtt{" + t + "}",
                        aside: "monospace",
                        insert: "\\mathtt{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathfrak{" + t + "}",
                        aside: "fraktur",
                        insert: "\\mathfrak{" + t + "}"
                    })
                }
                for (let e = 0; e < 10; e++) {
                    const t = "0123456789" [e];
                    kr[t] || (kr[t] = []), kr[t].unshift({
                        latex: "\\mathbf{" + t + "}",
                        aside: "bold",
                        insert: "\\mathbf{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathsf{" + t + "}",
                        aside: "sans",
                        insert: "\\mathsf{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathtt{" + t + "}",
                        aside: "monospace",
                        insert: "\\mathtt{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathcal{" + t + "}",
                        aside: "script",
                        insert: "\\mathcal{" + t + "}"
                    }), kr[t].unshift({
                        latex: "\\mathfrak{" + t + "}",
                        aside: "fraktur",
                        insert: "\\mathfrak{" + t + "}"
                    })
                }
                let l = e.options.virtualKeyboards;
                l || (l = "all"), l = l.replace(/\ball\b/i, "numeric functions symbols roman  greek");
                const d = {
                        ...xr,
                        ...null !== (a = e.options.customVirtualKeyboardLayers) && void 0 !== a ? a : {}
                    },
                    c = {
                        ...br,
                        ...null !== (i = e.options.customVirtualKeyboards) && void 0 !== i ? i : {}
                    },
                    u = l.replace(/\s+/g, " ").split(" ");
                for (const t of u) {
                    if (!c[t]) continue;
                    let a = null !== (o = c[t].layers) && void 0 !== o ? o : [];
                    c[t].layer && a.push(c[t].layer), a = [...new Set(a)];
                    for (const i of a) {
                        if (!d[i]) break;
                        if ("object" == typeof d[i]) {
                            const e = d[i];
                            let t = "";
                            if ("string" == typeof e.styles ? t += `<style>${e.styles}</style>` : "object" == typeof e.styles && (t += `<style>${Cr(e.styles)}</style>`), e.backdrop && (t += `<div class='${e.backdrop}'>`), e.container && (t += `<div class='${e.container}'>`), e.rows) {
                                t += "<div class='rows'>";
                                for (const a of e.rows) {
                                    t += "<ul>";
                                    for (const e of a) {
                                        if (t += "<li", e.class) {
                                            let a = e.class;
                                            e.layer && !/layer-switch/.test(a) && (a += " layer-switch"), /separator/.test(a) || (a += " keycap"), t += ` class="${a}"`
                                        } else t += ' class="keycap"';
                                        if (e.key && (t += ` data-key="${e.key}"`), e.command && ("string" == typeof e.command ? t += ` data-command='"${e.command}"'` : (t += " data-command='", t += JSON.stringify(e.command), t += "'")), e.insert && (t += ` data-insert="${e.insert}"`), e.latex && (t += ` data-latex="${e.latex}"`), e.aside && (t += ` data-aside="${e.aside}"`), e.variants) {
                                            const a = Date.now().toString(36).slice(-2) + Math.floor(1e5 * Math.random()).toString(36);
                                            kr[a] = e.variants, t += ` data-alt-keys="${a}"`
                                        }
                                        e.shifted && (t += ` data-shifted="${e.shifted}"`), e.shiftedCommand && (t += ` data-shifted-command="${e.shiftedCommand}"`), e.layer && (t += ` data-layer="${e.layer}"`), t += `>${e.label?e.label:""}</li>`
                                    }
                                    t += "</ul>"
                                }
                                t += "</div>"
                            }
                            e.container && (t += "</div>"), e.backdrop && (t += "</div>"), d[i] = t
                        }
                        s += `<div tabindex="-1" class='keyboard-layer' data-layer='${i}'>`, s += _r(e.options, l, t);
                        const a = d[i];
                        "string" == typeof a && (s += Mr(e.options, a)), s += "</div>"
                    }
                }
                const p = document.createElement("div");
                p.className = "ML__keyboard", t ? p.classList.add(t) : e.options.virtualKeyboardTheme && p.classList.add(e.options.virtualKeyboardTheme);
                const h = document.createElement("div");
                h.className = "ML__keyboard--plate", h.innerHTML = e.options.createHTML(s), p.appendChild(h);
                const y = p.querySelectorAll(".keycap, .action, .fnbutton, .bigfnbutton");
                for (const e of y) e.id = "ML__k" + Date.now().toString(36).slice(-2) + Math.floor(1e5 * Math.random()).toString(36);
                Sr(e, [...y]);
                const b = p.querySelectorAll(".layer-switch");
                for (const t of b) t.classList.contains("shift") ? hr((t => e.executeCommand(t)), t, {
                    pressed: "shiftKeyboardLayer",
                    default: ["switchKeyboardLayer", t.getAttribute("data-layer")],
                    pressAndHoldEnd: "unshiftKeyboardLayer"
                }) : hr((t => e.executeCommand(t)), t, {
                    default: ["switchKeyboardLayer", t.getAttribute("data-layer")]
                });
                const g = p.querySelectorAll(".keyboard-layer");
                for (const e of g) e.addEventListener("mousedown", (e => {
                    e.preventDefault(), e.stopPropagation()
                })), e.addEventListener("touchstart", (e => {
                    e.preventDefault(), e.stopPropagation()
                }), {
                    passive: !1
                });
                return null === (n = g[0]) || void 0 === n || n.classList.add("is-visible"), p
            }(this, null != e ? e : ""), ii(this.element, "touchstart:passive mousedown", (() => this.focusMathfield())), null === (t = this.options.virtualKeyboardContainer) || void 0 === t || t.appendChild(this.element)
        }
        handleEvent(e) {
            if (this.element) switch (e.type) {
                case "mouseup":
                case "blur":
                case "touchend":
                case "touchcancel":
                    document.body.style.userSelect = "", Lr(this)
            }
        }
        focusMathfield() {
            var e, t;
            null === (t = null === (e = this._mathfield) || void 0 === e ? void 0 : e.focus) || void 0 === t || t.call(e)
        }
        blurMathfield() {
            var e, t;
            null === (t = null === (e = this._mathfield) || void 0 === e ? void 0 : e.blur) || void 0 === t || t.call(e)
        }
        stateChanged() {
            var e, t;
            null === (t = null === (e = this._mathfield) || void 0 === e ? void 0 : e.element) || void 0 === t || t.dispatchEvent(new Event("virtual-keyboard-toggle", {
                bubbles: !0,
                cancelable: !1,
                composed: !0
            }))
        }
        executeCommand(e) {
            var t, a, o;
            let r, n = [];
            return i(e) ? (r = e[0], n = e.slice(1)) : r = e, r = r.replace(/-\w/g, (e => e[1].toUpperCase())), "virtual-keyboard" === (null === (t = co[r]) || void 0 === t ? void 0 : t.target) ? co[r].fn(this, ...n) : null !== (o = null === (a = this._mathfield) || void 0 === a ? void 0 : a.executeCommand(e)) && void 0 !== o && o
        }
        create() {
            this.virtualKeyboardStylesheet || (mr || (mr = Si(pr).toString(36)), this.virtualKeyboardStylesheet = Mi(null, pr, mr)), this.coreStylesheet || (this.coreStylesheet = Mi(null, Ii, Si(Ii).toString(36))), null !== this.options.fontsDirectory && Do(this.options.fontsDirectory)
        }
        enable() {
            o() && (window.addEventListener("mouseup", this), window.addEventListener("blur", this), window.addEventListener("touchend", this), window.addEventListener("touchcancel", this))
        }
        disable() {
            o() && (window.removeEventListener("mouseup", this), window.removeEventListener("blur", this), window.removeEventListener("touchend", this), window.removeEventListener("touchcancel", this))
        }
        dispose() {}
        constructor(e, t) {
            this.originalContainerBottomPadding = null, this.options = e, this.visible = !1, this._mathfield = t, this.coreStylesheet = null, this.virtualKeyboardStylesheet = null
        }
    }
    const br = {
            numeric: {
                tooltip: "keyboard.tooltip.numeric",
                layer: "math",
                label: "123",
                layers: ["math"]
            },
            roman: {
                tooltip: "keyboard.tooltip.roman",
                layer: "lower-roman",
                label: "ABC",
                layers: ["lower-roman", "upper-roman"]
            },
            greek: {
                tooltip: "keyboard.tooltip.greek",
                layer: "lower-greek",
                label: "&alpha;&beta;&gamma;",
                classes: "tex-math",
                layers: ["lower-greek", "upper-greek"]
            },
            functions: {
                tooltip: "keyboard.tooltip.functions",
                layer: "functions",
                label: "<i>f</i>&thinsp;()",
                classes: "tex",
                layers: ["functions"]
            },
            symbols: {
                tooltip: "keyboard.tooltip.symbols",
                layer: "symbols",
                label: "&infin;≠∈",
                classes: "tex",
                layers: ["symbols"]
            },
            latex: {
                tooltip: "keyboard.tooltip.command",
                command: ["switchMode", "latex"],
                label: "<svg class=\"svg-glyph\"><use xlink:href='#svg-command' /></svg>",
                layers: ["latex-lower", "latex-upper", "latex-symbols"]
            },
            style: {
                tooltip: "keyboard.tooltip.style",
                layer: "style",
                label: "<b>b</b><i>i</i>𝔹"
            }
        },
        gr = {
            "\\varphi ": ["&Phi;", "\\Phi "],
            "\\varsigma ": ["&Sigma;", "\\Sigma "],
            "\\epsilon ": ["&#x0190;", '\\char"0190'],
            "\\rho ": ["&#x3A1", '\\char"3A1'],
            "\\tau ": ["&#x3A4;", '\\char"3A4'],
            "\\upsilon ": ["&Upsilon;", "\\Upsilon "],
            "\\theta ": ["&Theta;", "\\Theta "],
            "\\iota ": ["&Iota;", '\\char"399'],
            "\\omicron ": ["&#x039F;", '\\char"39F'],
            "\\pi ": ["&Pi;", "\\Pi "],
            "\\alpha ": ["&Alpha;", '\\char"391'],
            "\\sigma ": ["&Sigma;", "\\Sigma "],
            "\\delta ": ["&Delta;", "\\Delta "],
            "\\phi ": ["&#x03a6;", "\\Phi "],
            "\\gamma ": ["&Gamma;", "\\Gamma "],
            "\\eta ": ["&Eta;", '\\char"397'],
            "\\xi ": ["&Xi;", "\\Xi "],
            "\\kappa ": ["&Kappa;", '\\char"39A'],
            "\\lambda ": ["&Lambda;", "\\Lambda "],
            "\\zeta ": ["&Zeta;", '\\char"396'],
            "\\chi ": ["&Chi;", '\\char"3A7'],
            "\\psi ": ["&Psi;", "\\Psi "],
            "\\omega ": ["&Omega;", "\\Omega "],
            "\\beta ": ["&Beta;", '\\char"392'],
            "\\nu ": ["&Nu;", '\\char"39D'],
            "\\mu ": ["&Mu;", '\\char"39C']
        },
        vr = {
            0: ["\\emptyset", "\\varnothing", "\\infty", {
                latex: "#?_0",
                insert: "#@_0"
            }, "\\circ", "\\bigcirc", "\\bullet"],
            2: ["\\frac{1}{2}", {
                latex: "#?^2",
                insert: "#@^2"
            }],
            3: ["\\frac{1}{3}", {
                latex: "#?^3",
                insert: "#@^3"
            }],
            ".": [".", ",", ";", "\\colon", {
                latex: ":",
                aside: "ratio"
            }, {
                latex: "\\cdotp",
                aside: "center dot",
                class: "box"
            }, {
                latex: "\\cdots",
                aside: "center ellipsis",
                class: "box"
            }, {
                latex: "\\ldotp",
                aside: "low dot",
                class: "box"
            }, {
                latex: "\\ldots",
                aside: "low ellipsis",
                class: "box"
            }, {
                latex: "\\vdots",
                aside: "",
                class: "box"
            }, {
                latex: "\\ddots",
                aside: "",
                class: "box"
            }, "\\odot", "\\oslash", "\\circledcirc"],
            "*": ["\\cdot", "\\ast", "\\star", "\\bigstar", "\\ltimes", "\\rtimes", "\\rightthreetimes", "\\leftthreetimes", "\\intercal", "\\prod", {
                latex: "\\prod_{n\\mathop=0}^{\\infty}",
                class: "small"
            }],
            "+": ["\\pm", "\\mp", "\\sum", {
                latex: "\\sum_{n\\mathop=0}^{\\infty}",
                class: "small"
            }, "\\dotplus", "\\oplus"],
            "-": ["\\pm", "\\mp", "\\ominus", "\\vert #0  \\vert"],
            "/": ["\\divideontimes", "/", "\\div", "\\%"],
            "(": ["\\left( #0\\right)", "\\left[ #0\\right]", "\\left\\{ #0\\right\\}", "\\left\\langle #0\\right\\rangle", "\\lfloor", "\\llcorner", "(", "\\lbrack", "\\lvert", "\\lVert", "\\lgroup", "\\langle", "\\lceil", "\\ulcorner", "\\lmoustache", "\\lbrace"],
            ")": ["\\rfloor", "\\lrcorner", ")", "\\rbrack", "\\rvert", "\\rVert", "\\rgroup", "\\rangle", "\\rceil", "\\urcorner", "\\rmoustache", "\\rbrace"],
            "=": ["\\cong", "\\asymp", "\\equiv", "\\differencedelta", "\\varpropto", "\\thickapprox", "\\approxeq", "\\thicksim", "\\backsim", "\\eqsim", "\\simeq", "\\Bumpeq", "\\bumpeq", "\\doteq", "\\Doteq", "\\fallingdotseq", "\\risingdotseq", "\\coloneq", "\\eqcirc", "\\circeq", "\\triangleq", "\\between"],
            "!=": ["\\neq", "\\ncong", "", "\\nsim"],
            "<": ["\\leq", "\\leqq", "\\lneqq", "\\ll", "\\lessgtr", "\\nless", "\\nleq", "\\lesssim", "\\precsim", "\\prec", "\\nprec", "\\preccurlyeq", "\\lessdot"],
            ">": ["\\geq", "\\geqq", "\\gneqq", "\\gg", "\\gtrless", "\\ngtr", "\\ngeq", "\\gtrsim", "\\succsim", "\\succ", "\\nsucc", "\\succcurlyeq", "\\gtrdot"],
            in: ["\\owns"],
            "!in": ["\\backepsilon"],
            subset: ["\\subseteq", "\\nsubset", "\\nsubseteq"],
            superset: ["\\supseteq", "\\nsupset", "\\nsupseteq"],
            infinity: ["\\aleph_0", "\\aleph_1", "\\omega", "\\mathfrak{m}"],
            "numeric-pi": ["\\prod", "\\theta", "\\rho", "\\sin", "\\cos", "\\tan"],
            ee: ["\\times 10^{#?}", "\\ln", "\\ln_{10}", "\\log"],
            "^": ["_{#?}"],
            int: [{
                latex: "\\int_{#?}^{#?}",
                class: "small"
            }, {
                latex: "\\int",
                class: "small"
            }, {
                latex: "\\smallint",
                class: "small"
            }, {
                latex: "\\iint",
                class: "small"
            }, {
                latex: "\\iiint",
                class: "small"
            }, {
                latex: "\\oint",
                class: "small"
            }, {
                latex: "\\dfrac{\\rd}{\\rd x}",
                class: "small"
            }, {
                latex: "\\frac{\\partial}{\\partial x}",
                class: "small"
            }, "\\capitalDifferentialD", "\\rd", "\\partial"],
            nabla: ["\\nabla\\times", "\\nabla\\cdot", "\\nabla^{2}"],
            "!": ["!!", "\\Gamma", "\\Pi"],
            accents: ["\\bar{#@}", "\\vec{#@}", "\\hat{#@}", "\\check{#@}", "\\dot{#@}", "\\ddot{#@}", "\\mathring{#@}", "\\breve{#@}", "\\acute{#@}", "\\tilde{#@}", "\\grave{#@}"],
            underline: ["\\underbrace{#@}", "\\underlinesegment{#@}", "\\underleftrightarrow{#@}", "\\underrightarrow{#@}", "\\underleftarrow{#@}", "\\undergroup{#@}"],
            overline: ["\\overbrace{#@}", "\\overlinesegment{#@}", "\\overleftrightarrow{#@}", "\\overrightarrow{#@}", "\\overleftarrow{#@}", "\\overgroup{#@}"],
            xleftarrows: ["\\xlongequal{#@}", "\\xleftrightarrow{#@}", "\\xLeftrightarrow{#@}", "\\xleftrightharpoons{#@}", "\\xLeftarrow{#@}", "\\xleftharpoonup{#@}", "\\xleftharpoondown{#@}", "\\xtwoheadleftarrow{#@}", "\\xhookleftarrow{#@}", "\\xtofrom{#@}", "\\xleftequilibrium{#@}", "\\xrightleftarrows{#@}"],
            xrightarrows: ["\\xrightarrow{#@}", "\\xlongequal{#@}", "\\xleftrightarrow{#@}", "\\xLeftrightarrow{#@}", "\\xleftrightharpoons{#@}", "\\xRightarrow{#@}", "\\xrightharpoonup{#@}", "\\xrightharpoondown{#@}", "\\xtwoheadrightarrow{#@}", "\\xrightleftharpoons{#@}", "\\xhookrightarrow{#@}", "\\xmapsto{#@}", "\\xrightequilibrium{#@}", "\\xrightleftarrows{#@}"],
            A: [{
                latex: "\\aleph",
                aside: "aleph"
            }, {
                latex: "\\forall",
                aside: "for all"
            }],
            a: [{
                latex: "\\aleph",
                aside: "aleph"
            }, {
                latex: "\\forall",
                aside: "for all"
            }],
            b: [{
                latex: "\\beth",
                aside: "beth"
            }],
            B: [{
                latex: "\\beth",
                aside: "beth"
            }],
            c: [{
                latex: "\\C",
                aside: "set of complex numbers"
            }],
            d: [{
                latex: "\\daleth",
                aside: "daleth"
            }],
            D: [{
                latex: "\\daleth",
                aside: "daleth"
            }],
            e: [{
                latex: "\\exponentialE",
                aside: "exponential e"
            }, {
                latex: "\\exists",
                aside: "there is"
            }, {
                latex: "\\nexists",
                aside: "there isn’t"
            }],
            g: [{
                latex: "\\gimel",
                aside: "gimel"
            }],
            G: [{
                latex: "\\gimel",
                aside: "gimel"
            }],
            h: [{
                latex: "\\hbar",
                aside: "h bar"
            }, {
                latex: "\\hslash",
                aside: "h slash"
            }],
            i: [{
                latex: "\\imaginaryI",
                aside: "imaginary i"
            }],
            j: [{
                latex: "\\imaginaryJ",
                aside: "imaginary j"
            }],
            l: [{
                latex: "\\ell",
                aside: "ell"
            }],
            n: [{
                latex: "\\mathbb{N}",
                aside: "set of natural numbers"
            }],
            p: [{
                latex: "\\mathbb{P}",
                aside: "set of primes"
            }],
            q: [{
                latex: "\\mathbb{Q}",
                aside: "set of rational numbers"
            }],
            r: [{
                latex: "\\mathbb{R}",
                aside: "set of real numbers"
            }],
            z: [{
                latex: "\\mathbb{Z}",
                aside: "set of integers"
            }],
            "x-var": ["y", "z", "t", "r", {
                latex: "f(#?)",
                class: "small"
            }, {
                latex: "g(#?)",
                class: "small"
            }, "x^2", "x^n", "x_n", "x_{n+1}", "x_i", "x_{i+1}"],
            "n-var": ["i", "j", "p", "k", "a", "u"],
            ii: ["\\Re", "\\Im", "\\imaginaryJ", "\\Vert #0 \\Vert"],
            logic: [{
                latex: "\\exists",
                aside: "there is"
            }, {
                latex: "\\nexists",
                aside: "there isn’t"
            }, {
                latex: "\\ni",
                aside: "such that"
            }, {
                latex: "\\Colon",
                aside: "such that"
            }, {
                latex: "\\implies",
                aside: "implies"
            }, {
                latex: "\\impliedby",
                aside: "implied by"
            }, {
                latex: "\\iff",
                aside: "if and only if"
            }, {
                latex: "\\land",
                aside: "and"
            }, {
                latex: "\\lor",
                aside: "or"
            }, {
                latex: "\\oplus",
                aside: "xor"
            }, {
                latex: "\\lnot",
                aside: "not"
            }, {
                latex: "\\downarrow",
                aside: "nor"
            }, {
                latex: "\\uparrow",
                aside: "nand"
            }, {
                latex: "\\curlywedge",
                aside: "nor"
            }, {
                latex: "\\bar\\curlywedge",
                aside: "nand"
            }, {
                latex: "\\therefore",
                aside: "therefore"
            }, {
                latex: "\\because",
                aside: "because"
            }, {
                latex: "^\\biconditional",
                aside: "biconditional"
            }, "\\leftrightarrow", "\\Leftrightarrow", "\\to", "\\models", "\\vdash", "\\gets", "\\dashv", "\\roundimplies"],
            "set-operators": ["\\cap", "\\cup", "\\setminus", "\\smallsetminus", "\\complement"],
            "set-relations": ["\\in", "\\notin", "\\ni", "\\owns", "\\subset", "\\supset", "\\subseteq", "\\supseteq", "\\subsetneq", "\\supsetneq", "\\varsubsetneq", "\\subsetneqq", "\\nsubset", "\\nsupset", "\\nsubseteq", "\\nsupseteq"],
            space: [{
                latex: '\\char"203A\\!\\char"2039',
                insert: "\\!",
                aside: "negative thin space<br>⁻³⧸₁₈ em"
            }, {
                latex: '\\unicode{"203A}\\,\\unicode{"2039}',
                insert: "\\,",
                aside: "thin space<br>³⧸₁₈ em"
            }, {
                latex: '\\unicode{"203A}\\:\\unicode{"2039}',
                insert: "\\:",
                aside: "medium space<br>⁴⧸₁₈ em"
            }, {
                latex: '\\unicode{"203A}\\;\\unicode{"2039}',
                insert: "\\;",
                aside: "thick space<br>⁵⧸₁₈ em"
            }, {
                latex: '\\unicode{"203A}\\ \\unicode{"2039}',
                insert: "\\ ",
                aside: "⅓ em"
            }, {
                latex: '\\unicode{"203A}\\enspace\\unicode{"2039}',
                insert: "\\enspace",
                aside: "½ em"
            }, {
                latex: '\\unicode{"203A}\\quad\\unicode{"2039}',
                insert: "\\quad",
                aside: "1 em"
            }, {
                latex: '\\unicode{"203A}\\qquad\\unicode{"2039}',
                insert: "\\qquad",
                aside: "2 em"
            }],
            delete: [{
                label: '<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>',
                command: "deleteAll"
            }],
            "->|": []
        };
    let kr = {};
    const xr = {
        math: "\n        <div class='rows'>\n            <ul>\n                <li class='keycap tex' data-alt-keys='x-var'><i>x</i></li>\n                <li class='keycap tex' data-alt-keys='n-var'><i>n</i></li>\n                <li class='separator w5'></li>\n                <row name='numpad-1'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-latex='\\exponentialE' data-alt-keys='ee'>e</li>\n                <li class='keycap tex' data-latex='\\imaginaryI' data-alt-keys='ii'>i</li>\n                <li class='keycap tex' data-latex='\\pi' data-alt-keys='numeric-pi'></li>\n            </ul>\n            <ul>\n                <li class='keycap tex' data-key='<' data-alt-keys='<'>&lt;</li>\n                <li class='keycap tex' data-key='>' data-alt-keys='>'>&gt;</li>\n                <li class='separator w5'></li>\n                <row name='numpad-2'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-latex='#@^{2}' data-latex='x^2'></li>\n                <li class='keycap tex' data-alt-keys='^' data-insert='#@^{#?}' data-latex='x^\\placeholder'></li>\n                <li class='keycap tex small' data-insert='\\sqrt{#0}' data-latex='\\sqrt{#0}'></li>\n            </ul>\n            <ul>\n                <li class='keycap tex' data-alt-keys='(' >(</li>\n                <li class='keycap tex' data-alt-keys=')' >)</li>\n                <li class='separator w5'></li>\n                <row name='numpad-3'/>\n                <li class='separator w5'></li>\n                <li class='keycap small' data-alt-keys='int' data-latex='\\int_0^\\infty'></li>\n                <li class='keycap' data-latex='\\forall' data-alt-keys='logic' ></li>\n                <li class='action font-glyph bottom right' data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deleteBackward\"]'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li></ul>\n            </ul>\n            <ul>\n                <li class='keycap' data-alt-keys='foreground-color' data-command='[\"applyStyle\",{\"color\":\"red\"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428; box-sizing: border-box'></span></li>\n                <li class='keycap' data-alt-keys='background-color' data-command='[\"applyStyle\",{\"backgroundColor\":\"yellow\"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span></li>\n                <li class='separator w5'></li>\n                <row name='numpad-4'/>\n                <li class='separator w5'></li>\n                <arrows/>\n            </ul>\n        </div>\n    ",
        "lower-roman": "\n        <div class='rows'>\n            <ul>\n                <row name='numpad-1' class='if-wide'/>\n                <row name='lower-1' shift-layer='upper-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-2' class='if-wide'/>\n                <row name='lower-2'  shift-layer='upper-roman''/>\n            </ul>\n            <ul>\n                <row name='numpad-3' class='if-wide'/>\n                <row name='lower-3'  shift-layer='upper-roman''/>\n            </ul>\n            <ul>\n                <row name='numpad-4' class='if-wide'/>\n                <li class='keycap' >;</li>\n                <li class='keycap' >,</li>\n                <li class='keycap w50' data-key=' ' data-alt-keys='space'>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
        "upper-roman": "\n        <div class='rows'>\n            <ul>\n                <row name='numpad-1' class='if-wide'/>\n                <row name='upper-1'  shift-layer='lower-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-2' class='if-wide'/>\n                <row name='upper-2' shift-layer='lower-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-3' class='if-wide'/>\n                <row name='upper-3' shift-layer='lower-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-4' class='if-wide'/>\n                <li class='keycap' >;</li>\n                <li class='keycap' data-alt-keys='.'>;</li>\n                <li class='keycap w50' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
        symbols: "\n        <div class='rows'>\n            <ul>\n                <row name='numpad-1' class='if-wide'/>\n                <li class='keycap tex' data-alt-keys='(' data-insert='\\lbrace '>{</li>\n                <li class='keycap tex' data-alt-keys=')' data-insert='\\rbrace '>}</li>\n                <li class='separator w5'></li>\n                <li class='keycap tex small' data-alt-keys='xleftarrows' data-latex='\\leftarrow' ></li>\n                <li class='keycap tex small' data-alt-keys='xrightarrows' data-latex='\\rightarrow' ></li>\n                <li class='keycap tex' data-alt-keys='overline' data-latex='\\overline{#@}' data-aside='overline'></li>\n                <li class='keycap tex' data-alt-keys='underline' data-latex='\\underline{#@}' data-aside='underline'></li>\n                <li class='keycap w15' data-insert='\\ulcorner#0\\urcorner '><span><sup>&#x250c;</sup><span><span style='color:#ddd'>o</span><sup>&#x2510;</sup></span><aside>ceil</aside></li>\n                <li class='keycap tex' data-alt-keys='nabla' data-insert='\\nabla '>&#x2207;<aside>nabla</aside></li>\n                <li class='keycap tex' data-alt-keys='infinity' data-insert='\\infty '>&#x221e;</li>\n\n            </ul>\n            <ul>\n                <row name='numpad-2' class='if-wide'/>\n                <li class='keycap tex' data-alt-keys='(' data-insert='\\lbrack '>[</li>\n                <li class='keycap tex' data-alt-keys=')' data-insert='\\rbrack '>]</li>\n                <li class='separator w5'></li>\n\n                <li class='keycap tex' data-alt-keys='in' data-insert='\\in '>&#x2208;</li>\n                <li class='keycap tex' data-alt-keys='!in' data-insert='\\notin '>&#x2209;</li>\n                <li class='keycap tex' data-insert='\\Re '>&#x211c;<aside>Real</aside></li>\n                <li class='keycap tex' data-insert='\\Im '>&#x2111;<aside>Imaginary</aside></li>\n                <li class='keycap w15' data-insert='\\llcorner#0\\lrcorner '><span><sub>&#x2514;</sub><span style='color:#ddd'>o</span><sub>&#x2518;</sub></span><aside>floor</aside></li>\n\n                <li class='keycap tex' data-insert='\\partial '>&#x2202;<aside>partial<br>derivative</aside></li>\n                <li class='keycap tex' data-insert='\\emptyset '>&#x2205;<aside>empty set</aside></li>\n\n            </ul>\n            <ul>\n                <row name='numpad-3' class='if-wide'/>\n                <li class='keycap tex' data-alt-keys='(' data-insert='\\langle '>&#x27e8;</li>\n                <li class='keycap tex' data-alt-keys=')' data-insert='\\rangle '>&#x27e9;</li>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-alt-keys='subset' data-insert='\\subset '>&#x2282;</li>\n                <li class='keycap tex' data-alt-keys='superset' data-insert='\\supset '>&#x2283;</li>\n\n                <li class='keycap tex' data-alt-keys='accents' data-insert='\\vec{#@}' data-latex='\\vec{#?}' data-aside='vector'></li>\n                <li class='keycap tex' data-alt-keys='absnorm' data-insert='\\left| #0 \\right|' data-latex='\\left| #? \\right|' data-aside='abs'></li>\n\n                <li class='keycap tex' data-key='!' data-alt-keys='!'>!<aside>factorial</aside></li>\n                <li class='keycap' data-latex='^{\\prime} '><span><sup><span><span style='color:#ddd'>o</span>&#x2032</sup></span><aside>prime</aside></li>\n\n                <li class='action font-glyph bottom right w15'\n                    data-shifted='<span class=\"warning\"><svg class=\"svg-glyph\"><use xlink:href=\"#svg-trash\" /></svg></span>'\n                    data-shifted-command='\"deleteAll\"'\n                    data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deleteBackward\"]'\n                ><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li>\n            </ul>\n            <ul>\n                <row name='numpad-4' class='if-wide'/>\n                <li class='keycap tex' data-insert=','>,</li>\n                <li class='keycap tex' data-insert='\\cdot '>&#x22c5;<aside>centered dot</aside></li>\n                <li class='keycap tex' data-insert='\\colon '>:<aside>colon</aside></li>\n                <li class='keycap tex' data-insert='\\circ '>&#x2218;<aside>circle</aside></li>\n                <li class='keycap tex' data-insert='\\approx '>&#x2248;<aside>approx.</aside></li>\n                <li class='keycap tex' data-insert='\\ne '>&#x2260;</li>\n                <li class='keycap tex' data-insert='\\pm '>&#x00b1;</li>\n                <arrows/>\n            </ul>\n        </div>",
        "lower-greek": "\n        <div class='rows'>\n            <ul><li class='keycap tex' data-insert='\\varphi '><i>&#x03c6;</i><aside>phi var.</aside></li>\n                <li class='keycap tex' data-insert='\\varsigma '><i>&#x03c2;</i><aside>sigma var.</aside></li>\n                <li class='keycap tex' data-insert='\\epsilon '><i>&#x03f5;</i></li>\n                <li class='keycap tex' data-insert='\\rho '><i>&rho;</i></li>\n                <li class='keycap tex' data-insert='\\tau '><i>&tau;</i></li>\n                <li class='keycap tex' data-insert='\\upsilon '><i>&upsilon;</i></li>\n                <li class='keycap tex' data-insert='\\theta '><i>&theta;</i></li>\n                <li class='keycap tex' data-insert='\\iota '><i>&iota;</i></li>\n                <li class='keycap tex' data-insert='\\omicron '>&omicron;</i></li>\n                <li class='keycap tex' data-insert='\\pi '><i>&pi;</i></li>\n            </ul>\n            <ul><li class='keycap tex' data-insert='\\alpha ' data-shifted='&Alpha;' data-shifted-command='[\"insert\",\"\\\\char\\\"391\"]'><i>&alpha;</i></li>\n                <li class='keycap tex' data-insert='\\sigma '><i>&sigma;</i></li>\n                <li class='keycap tex' data-insert='\\delta '><i>&delta;</i></li>\n                <li class='keycap tex' data-insert='\\phi '><i>&#x03d5;</i></i></li>\n                <li class='keycap tex' data-insert='\\gamma '><i>&gamma;</i></li>\n                <li class='keycap tex' data-insert='\\eta '><i>&eta;</i></li>\n                <li class='keycap tex' data-insert='\\xi '><i>&xi;</i></li>\n                <li class='keycap tex' data-insert='\\kappa '><i>&kappa;</i></li>\n                <li class='keycap tex' data-insert='\\lambda '><i>&lambda;</i></li>\n            </ul>\n            <ul><li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='upper-greek'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-shift\" /></svg></li>\n                <li class='keycap tex' data-insert='\\zeta '><i>&zeta;</i></li>\n                <li class='keycap tex' data-insert='\\chi '><i>&chi;</i></li>\n                <li class='keycap tex' data-insert='\\psi '><i>&psi;</i></li>\n                <li class='keycap tex' data-insert='\\omega '><i>&omega;</i></li>\n                <li class='keycap tex' data-insert='\\beta '><i>&beta;</i></li>\n                <li class='keycap tex' data-insert='\\nu '><i>&nu;</i></li>\n                <li class='keycap tex' data-insert='\\mu '><i>&mu;</i></li>\n                <li class='action font-glyph bottom right w15'\n                    data-shifted='<span class=\"warning\"><svg class=\"svg-glyph\"><use xlink:href=\"#svg-trash\" /></svg></span>'\n                    data-shifted-command='\"deleteAll\"'\n                    data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deleteBackward\"]'\n                ><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li>\n            </ul>\n            <ul>\n                <li class='keycap ' data-key=' '>&nbsp;</li>\n                <li class='keycap'>,</li>\n                <li class='keycap tex' data-insert='\\varepsilon '><i>&#x03b5;</i><aside>epsilon var.</aside></li>\n                <li class='keycap tex' data-insert='\\vartheta '><i>&#x03d1;</i><aside>theta var.</aside></li>\n                <li class='keycap tex' data-insert='\\varkappa '><i>&#x3f0;</i><aside>kappa var.</aside></li>\n                <li class='keycap tex' data-insert='\\varpi '><i>&#x03d6;<aside>pi var.</aside></i></li>\n                <li class='keycap tex' data-insert='\\varrho '><i>&#x03f1;</i><aside>rho var.</aside></li>\n                <arrows/>\n            </ul>\n        </div>",
        "upper-greek": "\n        <div class='rows'>\n            <ul><li class='keycap tex' data-insert='\\Phi '>&Phi;<aside>phi</aside></li>\n                <li class='keycap tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>\n                <li class='keycap tex' data-insert='\\char\"0190'>&#x0190;<aside>epsilon</aside></li>\n                <li class='keycap tex' data-insert='\\char\"3A1'>&#x3A1;<aside>rho</aside></li>\n                <li class='keycap tex' data-insert='\\char\"3A4'>&#x3A4;<aside>tau</aside></li>\n                <li class='keycap tex' data-insert='\\Upsilon '>&Upsilon;<aside>upsilon</aside></li>\n                <li class='keycap tex' data-insert='\\Theta '>&Theta;<aside>theta</aside></li>\n                <li class='keycap tex' data-insert='\\char\"399'>&Iota;<aside>iota</aside></li>\n                <li class='keycap tex' data-insert='\\char\"39F'>&#x039F;<aside>omicron</aside></li>\n                <li class='keycap tex' data-insert='\\Pi '>&Pi;<aside>pi</aside></li></ul>\n            <ul><li class='keycap tex' data-insert='\\char\"391'>&#x391;<aside>alpha</aside></li>\n                <li class='keycap tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>\n                <li class='keycap tex' data-insert='\\Delta '>&Delta;<aside>delta</aside></li>\n                <li class='keycap tex' data-insert='\\Phi '>&#x03a6;<aside>phi</aside></li>\n                <li class='keycap tex' data-insert='\\Gamma '>&Gamma;<aside>gamma</aside></li>\n                <li class='keycap tex' data-insert='\\char\"397'>&Eta;<aside>eta</aside></li>\n                <li class='keycap tex' data-insert='\\Xi '>&Xi;<aside>xi</aside></li>\n                <li class='keycap tex' data-insert='\\char\"39A'>&Kappa;<aside>kappa</aside></li>\n                <li class='keycap tex' data-insert='\\Lambda '>&Lambda;<aside>lambda</aside></li></ul>\n            <ul><li class='shift modifier font-glyph bottom left selected w15 layer-switch' data-layer='lower-greek'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-shift\" /></svg></li>\n                <li class='keycap tex' data-insert='\\char\"396'>&Zeta;<aside>zeta</aside></li>\n                <li class='keycap tex' data-insert='\\char\"3A7'>&Chi;<aside>chi</aside></li>\n                <li class='keycap tex' data-insert='\\Psi '>&Psi;<aside>psi</aside></li>\n                <li class='keycap tex' data-insert='\\Omega '>&Omega;<aside>omega</aside></li>\n                <li class='keycap tex' data-insert='\\char\"392'>&Beta;<aside>beta</aside></li>\n                <li class='keycap tex' data-insert='\\char\"39D'>&Nu;<aside>nu</aside></li>\n                <li class='keycap tex' data-insert='\\char\"39C'>&Mu;<aside>mu</aside></li>\n                <li class='action font-glyph bottom right w15' data-command='[\"performWithFeedback\",\"deleteBackward\"]'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li></ul>\n            <ul>\n                <li class='separator w10'>&nbsp;</li>\n                <li class='keycap'>.</li>\n                <li class='keycap w50' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
        "latex-lower": "\n        <div class='rows'>\n            <ul><row name='lower-1' class='tt' shift-layer='latex-upper'/></ul>\n            <ul><row name='lower-2' class='tt' shift-layer='latex-upper'/></ul>\n            <ul><row name='lower-3' class='tt' shift-layer='latex-upper'/></ul>\n            <ul>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='latex-symbols'>01#</li>\n                <li class='keycap tt' data-shifted='[' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \"[\"]'>{</li>\n                <li class='keycap tt' data-shifted=']' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \"]\"]'>}</li>\n                <li class='keycap tt' data-shifted='(' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \"(\"]'>^</li>\n                <li class='keycap tt' data-shifted=')' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \")\"]'>_</li>\n                <li class='keycap w20' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
        "latex-upper": "\n        <div class='rows'>\n            <ul><row name='upper-1' class='tt' shift-layer='latex-lower'/></ul>\n            <ul><row name='upper-2' class='tt' shift-layer='latex-lower'/></ul>\n            <ul><row name='upper-3' class='tt' shift-layer='latex-lower'/></ul>\n            <ul>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='latex-symbols'01#</li>\n                <li class='keycap tt'>[</li>\n                <li class='keycap tt'>]</li>\n                <li class='keycap tt'>(</li>\n                <li class='keycap tt'>)</li>\n                <li class='keycap w20' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
        "latex-symbols": "\n        <div class='rows'>\n            <ul><li class='keycap tt'>1</li><li class='keycap tt'>2</li><li class='keycap tt'>3</li><li class='keycap tt'>4</li><li class='keycap tt'>5</li><li class='keycap tt'>6</li><li class='keycap tt'>7</li><li class='keycap tt'>8</li><li class='keycap tt'>9</li><li class='keycap tt'>0</li></ul>\n            <ul><li class='keycap tt'>!</li><li class='keycap tt'>@</li><li class='keycap tt'>#</li><li class='keycap tt'>$</li><li class='keycap tt'>%</li><li class='keycap tt'>^</li><li class='keycap tt'>&</li><li class='keycap tt'>*</li><li class='keycap tt'>+</li><li class='keycap tt'>=</li></ul>\n            <ul>\n                <li class='keycap tt'>\\</li>\n                <li class='keycap tt'>|</li>\n                <li class='keycap tt'>/</li>\n                <li class='keycap tt'>`</li>\n                <li class='keycap tt'>;</li>\n                <li class='keycap tt'>:</li>\n                <li class='keycap tt'>?</li>\n                <li class='keycap tt'>'</li>\n                <li class='keycap tt'>\"</li>\n                <li class='action font-glyph bottom right'\n                    data-shifted='<span class=\"warning\"><svg class=\"svg-glyph\"><use xlink:href=\"#svg-trash\" /></svg></span>'\n                    data-shifted-command='\"deleteAll\"'\n                    data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deleteBackward\"]'\n                ><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li>\n            </ul>\n            <ul>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='latex-lower'>abc</li>\n                <li class='keycap tt'>&lt;</li>\n                <li class='keycap tt'>&gt;</li>\n                <li class='keycap tt'>~</li>\n                <li class='keycap tt'>,</li>\n                <li class='keycap tt'>.</li>\n                <li class='keycap' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
        functions: "\n        <div class='rows'>\n            <ul><li class='separator'></li>\n                <li class='fnbutton' data-insert='\\sin'></li>\n                <li class='fnbutton' data-insert='\\sin^{-1}'></li>\n                <li class='fnbutton' data-insert='\\ln'></li>\n                <li class='fnbutton' data-insert='\\exponentialE^{#?}'></li>\n                <li class='bigfnbutton' data-insert='\\operatorname{lcm}(#?)' data-latex='\\operatorname{lcm}()'></li>\n                <li class='bigfnbutton' data-insert='\\operatorname{ceil}(#?)' data-latex='\\operatorname{ceil}()'></li>\n                <li class='bigfnbutton' data-insert='\\lim_{n\\to\\infty}'></li>\n                <li class='bigfnbutton' data-insert='\\int'></li>\n                <li class='bigfnbutton' data-insert='\\operatorname{abs}(#?)' data-latex='\\operatorname{abs}()'></li>\n            </ul>\n            <ul><li class='separator'></li>\n                <li class='fnbutton' data-latex='\\cos'></li>\n                <li class='fnbutton' data-latex='\\cos^{-1}'></li>\n                <li class='fnbutton' data-latex='\\ln_{10}'></li>\n                <li class='fnbutton' data-latex='10^{#?}'></li>\n                <li class='bigfnbutton' data-latex='\\operatorname{gcd}(#?)' data-latex='\\operatorname{gcd}()'></li>\n                <li class='bigfnbutton' data-latex='\\operatorname{floor}(#?)' data-latex='\\operatorname{floor}()'></li>\n                <li class='bigfnbutton' data-latex='\\sum_{n\\mathop=0}^{\\infty}'></li>\n                <li class='bigfnbutton' data-latex='\\int_{0}^{\\infty}'></li>\n                <li class='bigfnbutton' data-latex='\\operatorname{sign}(#?)' data-latex='\\operatorname{sign}()'></li>\n            </ul>\n            <ul><li class='separator'></li>\n                <li class='fnbutton' data-latex='\\tan'></li>\n                <li class='fnbutton' data-latex='\\tan^{-1}'></li>\n                <li class='fnbutton' data-latex='\\log_{#?}'></li>\n                <li class='fnbutton' data-latex='\\sqrt[#?]{#0}'></li>\n                <li class='bigfnbutton' data-insert='#0 \\mod' data-latex='\\mod'></li>\n                <li class='bigfnbutton' data-insert='\\operatorname{round}(#?) ' data-latex='\\operatorname{round}()'></li>\n                <li class='bigfnbutton' data-insert='\\prod_{n\\mathop=0}^{\\infty}' data-latex='{\\scriptstyle \\prod_{n=0}^{\\infty}}'></li>\n                <li class='bigfnbutton' data-insert='\\frac{\\differentialD #0}{\\differentialD x}'></li>\n                <li class='action font-glyph bottom right' data-command='[\"performWithFeedback\",\"deleteBackward\"]'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li></ul>\n            <ul><li class='separator'></li>\n                <li class='fnbutton'>(</li>\n                <li class='fnbutton'>)</li>\n                <li class='fnbutton' data-insert='^{#?}' data-latex='x^{#?}'></li>\n                <li class='fnbutton' data-insert='_{#?}' data-latex='x_{#?}'></li>\n                <li class='keycap w20 ' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
        style: "\n        <div class='rows'>\n            <ul>\n                <li class='keycap' data-alt-keys='foreground-color' data-command='[\"applyStyle\",{\"color\":\"red\"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428'></span></li>\n                <li class='keycap' data-alt-keys='background-color' data-command='[\"applyStyle\",{\"backgroundColor\":\"yellow\"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590'></span></li>\n                <li class='separator w5'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"size\":\"3\"}]' data-latex='\\scriptsize\\text{small}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"size\":\"5\"}]' data-latex='\\scriptsize\\text{normal}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"size\":\"9\"}]' data-latex='\\huge\\text{big}'></li>\n                <li class='separator w5'></li>\n                <li class='keycap' data-latex='\\langle' data-command='[\"insert\", \"\\\\langle\", {\"smartFence\":true}]'></li>\n            </ul>\n            <ul>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"l\"}]' data-latex='\\fontseries{l}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"m\"}]' data-latex='\\fontseries{m}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"b\"}]' data-latex='\\fontseries{b}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"bx\"}]' data-latex='\\fontseries{bx}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"sb\"}]' data-latex='\\fontseries{sb}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"c\"}]' data-latex='\\fontseries{c}\\text{Ab}'></li>\n            </ul>\n            <ul>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"up\"}]' data-latex='\\textup{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"it\"}]' data-latex='\\textit{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"sl\"}]' data-latex='\\textsl{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"sc\"}]' data-latex='\\textsc{Ab}'></li>\n                <li class='separator w5'></li>\n                <li class='keycap' data-insert='\\emph{#@} ' data-latex='\\text{\\emph{emph}}'></li>\n            </ul>\n            <ul>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cmr\"}]' data-latex='\\textrm{Az}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cmtt\"}]' data-latex='\\texttt{Az}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cmss\"}]' data-latex='\\textsf{Az}'></li>\n\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"bb\"}]'  data-latex='\\mathbb{AZ}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"scr\"}]'  data-latex='\\mathscr{AZ}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cal\"}]' data-latex='\\mathcal{A1}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"frak\"}]' data-latex='\\mathfrak{Az}'></li>\n            </ul>\n        </div>"
    };

    function wr(e, t) {
        e = e.replace(/(^|[^\\])#@/g, "$1#?");
        const a = ma(),
            i = new lt("root", a);
        return i.body = Nt(e, a, {
            parseMode: "math",
            args: t
        }), je(Fe(Ve(new Ne(i.render(new Ae({
            registers: a.registers
        }, {
            fontSize: 5
        }, "displaystyle")), {
            classes: "ML__base"
        }))), {
            classes: "ML__mathlive"
        }).toMarkup()
    }

    function _r(e, t, a) {
        var i, o, r;
        let n = "<div class='left'>";
        const s = t.replace(/\s+/g, " ").split(" ");
        if (s.length > 1) {
            const t = {
                ...br,
                ...null !== (i = e.customVirtualKeyboards) && void 0 !== i ? i : {}
            };
            for (const e of s) {
                if (!t[e]) break;
                n += "<div class='", e === a ? n += "selected " : t[e].command ? n += "action " : n += "layer-switch ", n += (null !== (o = t[e].classes) && void 0 !== o ? o : "") + "'", t[e].tooltip && (n += "data-tooltip='" + (null !== (r = u(t[e].tooltip)) && void 0 !== r ? r : t[e].tooltip) + "' "), e !== a && ("string" == typeof t[e].command ? n += `data-command='"${t[e].command}"'` : Array.isArray(t[e].command) && (n += `data-command='"${t[e].command.join("")}"'`), t[e].layer && (n += "data-layer='" + t[e].layer + "'")), n += ">" + t[e].label + "</div>"
            }
        }
        n += "</div>";
        const l = "default" === e.virtualKeyboardToolbar ? ["copyToClipboard", "undo", "redo"] : [],
            d = {
                copyToClipboard: `\n            <div class='action'\n                data-command='"copyToClipboard"'\n                data-tooltip='${u("tooltip.copy to clipboard")}'>\n                <svg><use xlink:href='#svg-copy' /></svg>\n            </div>\n        `,
                undo: `\n            <div class='action disabled'\n                data-command='"undo"'\n                data-tooltip='${u("tooltip.undo")}'>\n                <svg><use xlink:href='#svg-undo' /></svg>\n            </div>\n        `,
                redo: `\n            <div class='action disabled'\n                data-command='"redo"'\n                data-tooltip='${u("tooltip.redo")}'>\n                <svg><use xlink:href='#svg-redo' /></svg>\n            </div>\n        `
            };
        return l.length > 0 && (n += `\n            <div class='right'>\n                ${l.map((e=>d[e])).join("")}\n            </div>\n        `), "<div class='keyboard-toolbar' role='toolbar'>" + n + "</div>"
    }

    function Sr(e, t, a) {
        var i, o;
        for (const r of t) {
            let t;
            r.getAttribute("data-latex") ? t = wr(r.getAttribute("data-latex").replace(/&quot;/g, '"'), (() => "\\placeholder{}")) : r.getAttribute("data-insert") && "" === r.innerHTML ? t = wr(r.getAttribute("data-insert").replace(/&quot;/g, '"'), (() => "\\placeholder{}")) : r.getAttribute("data-content") && (t = r.getAttribute("data-content").replace(/&quot;/g, '"')), r.getAttribute("data-aside") && (t = (null != t ? t : "") + "<aside>" + r.getAttribute("data-aside").replace(/&quot;/g, '"') + "</aside>"), void 0 !== t && (r.innerHTML = e.options.createHTML(t)), r.getAttribute("data-classes") && r.classList.add(r.getAttribute("data-classes"));
            const n = null === (i = r.getAttribute("data-insert")) || void 0 === i ? void 0 : i.replace(/&quot;/g, '"');
            let s;
            n && gr[n] && (r.dataset.shifted = gr[n][0], r.dataset.shiftedCommand = JSON.stringify(["insertAndUnshiftKeyboardLayer", gr[n][1]]));
            const l = r.getAttribute("data-command");
            if (l)
                if (/^[a-zA-Z]+$/.test(l)) s = l;
                else try {
                    s = JSON.parse(l)
                } catch (e) {} else s = r.getAttribute("data-insert") ? ["insert", r.getAttribute("data-insert"), {
                    focus: !0,
                    feedback: !0,
                    scrollIntoView: !0,
                    mode: "math",
                    format: "latex",
                    resetStyle: !0
                }] : r.getAttribute("data-latex") ? ["insert", r.getAttribute("data-latex"), {
                    focus: !0,
                    feedback: !0,
                    scrollIntoView: !0,
                    mode: "math",
                    format: "latex",
                    resetStyle: !0
                }] : ["typedText", null !== (o = r.getAttribute("data-key")) && void 0 !== o ? o : r.textContent, {
                    focus: !0,
                    feedback: !0,
                    simulateKeystroke: !0
                }];
            if (s) {
                a && (s = [a, s]);
                let t = s;
                const i = r.getAttribute("data-alt-keys");
                i && kr[i] && (t = {
                    default: s,
                    pressAndHoldStart: ["showAlternateKeys", i],
                    pressAndHoldEnd: "hideAlternateKeys"
                }), hr((t => e.executeCommand(t)), r, t)
            }
        }
    }

    function Mr(e, t) {
        var a, i, o, r;
        const n = {
            qwerty: {
                "lower-1": "qwertyuiop",
                "lower-2": " asdfghjkl ",
                "lower-3": "^zxcvbnm~",
                "upper-1": "QWERTYUIOP",
                "upper-2": " ASDFGHJKL ",
                "upper-3": "^ZXCVBNM~",
                "numpad-1": "789/",
                "numpad-2": "456*",
                "numpad-3": "123-",
                "numpad-4": "0.=+"
            },
            azerty: {
                "lower-1": "azertyuiop",
                "lower-2": "qsdfghjklm",
                "lower-3": "^ wxcvbn ~",
                "upper-1": "AZERTYUIOP",
                "upper-2": "QSDFGHJKLM",
                "upper-3": "^ WXCVBN ~"
            },
            qwertz: {
                "lower-1": "qwertzuiop",
                "lower-2": " asdfghjkl ",
                "lower-3": "^yxcvbnm~",
                "upper-1": "QWERTZUIOP",
                "upper-2": " ASDFGHJKL",
                "upper-3": "^YXCVBNM~"
            },
            dvorak: {
                "lower-1": "^  pyfgcrl ",
                "lower-2": "aoeuidhtns",
                "lower-3": "qjkxbmwvz~",
                "upper-1": "^  PYFGCRL ",
                "upper-2": "AOEUIDHTNS",
                "upper-3": "QJKXBMWVZ~"
            },
            colemak: {
                "lower-1": " qwfpgjluy ",
                "lower-2": "arstdhneio",
                "lower-3": "^zxcvbkm~",
                "upper-1": " QWFPGNLUY ",
                "upper-2": "ARSTDHNEIO",
                "upper-3": "^ZXCVBKM~"
            }
        };
        let s = e.virtualKeyboardLayout;
        if ("auto" === s) {
            const e = Ki();
            e && (s = e.virtualLayout), s && "auto" !== s || (s = null !== (a = {
                fr: "azerty",
                be: "azerty",
                al: "qwertz",
                ba: "qwertz",
                cz: "qwertz",
                de: "qwertz",
                hu: "qwertz",
                sk: "qwertz",
                ch: "qwertz"
            } [c.locale.slice(0, 2)]) && void 0 !== a ? a : "qwerty")
        }
        const l = null !== (i = n[s]) && void 0 !== i ? i : n.qwerty;
        let d, u = t;
        u = u.replace(/<arrows\/>/g, '\n        <li class=\'action\' data-command=\'["performWithFeedback","moveToPreviousChar"]\'\n            data-shifted=\'<svg class="svg-glyph"><use xlink:href="#svg-angle-double-left" /></svg>\'\n            data-shifted-command=\'["performWithFeedback","extendToPreviousChar"]\'>\n            <svg class="svg-glyph"><use xlink:href=\'#svg-arrow-left\' /></svg>\n        </li>\n        <li class=\'action\' data-command=\'["performWithFeedback","moveToNextChar"]\'\n            data-shifted=\'<svg class="svg-glyph"><use xlink:href="#svg-angle-double-right" /></svg>\'\n            data-shifted-command=\'["performWithFeedback","extendToNextChar"]\'>\n            <svg class="svg-glyph"><use xlink:href=\'#svg-arrow-right\' /></svg>\n        </li>\n        <li class=\'action\' data-command=\'["performWithFeedback","commit"]\'>\n        <svg class="svg-glyph"><use xlink:href=\'#svg-commit\' /></svg></li>');
        let p = u.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
        for (; p;) {
            d = "";
            const t = p[2].match(/[a-zA-Z][a-zA-Z\d-]*=(['"])(.*?)\1/g),
                a = {};
            if (t)
                for (const e of t) {
                    const t = e.match(/([a-zA-Z][a-zA-Z\d-]*)=(['"])(.*?)\2/);
                    t && (a[t[1]] = t[3])
                }
            let i = l[a.name];
            if (i || (i = n.qwerty[a.name]), i)
                for (const t of i) {
                    let n = null !== (o = a.class) && void 0 !== o ? o : "";
                    n && (n = ` ${n}`), "~" === t ? (d += "<li class='action font-glyph bottom right ", d += i.length - (i.match(/ /g) || []).length / 2 == 10 ? "w10" : "w15", d += '\' data-shifted=\'<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>\'\n                        data-shifted-command=\'"deleteAll"\'\n                        data-alt-keys=\'delete\' data-command=\'["performWithFeedback","deleteBackward"]\'\n                        ><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li>') : " " === t ? d += "<li class='separator w5'></li>" : "^" === t ? d += "<li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='" + a["shift-layer"] + '\'><svg class="svg-glyph"><use xlink:href="#svg-shift" /></svg></li>' : "/" === t ? d += "<li class='keycap" + n + "' data-alt-keys='/' data-insert='\\frac{#@}{#?}'>&divide;</li>" : "*" === t ? d += "<li class='keycap" + n + "' data-alt-keys='*' data-insert='\\times '>&times;</li>" : "-" === t ? d += "<li class='keycap" + n + "' data-alt-keys='-' data-key='-'>&#x2212;</li>" : "." === t ? d += "<li class='keycap" + n + "' data-alt-keys='.' data-command='\"insertDecimalSeparator\"'>" + (null !== (r = e.decimalSeparator) && void 0 !== r ? r : ".") + "</li>" : n.includes("tt") ? d += `<li class='keycap${n}' data-alt-keys='${t}' data-command='["typedText","${t}",{"mode":"command", "focus":true, "feedback":true}]'>${t}</li>` : d += "<li class='keycap" + n + "' data-alt-keys='" + t + "'>" + t + "</li>"
                }
            u = u.replace(new RegExp(p[1] + p[2] + p[3]), d), p = u.match(/(<row\s+)(.*)((?:<\/row|\/)>)/)
        }
        return u
    }

    function Lr(e) {
        fr();
        const t = e.element.querySelectorAll("div.keyboard-layer.is-visible .rows .keycap, div.keyboard-layer.is-visible .rows .action");
        if (t)
            for (const a of t) {
                const t = a.getAttribute("data-unshifted-content");
                t && (a.innerHTML = e.options.createHTML(t), a.dataset.unshiftedContent = "");
                const i = a.getAttribute("data-unshifted-command");
                i && (a.dataset.command = i, a.dataset.unshiftedCommand = "")
            }
        return !1
    }

    function Cr(e) {
        return Object.keys(e).map((t => `${t} {${function(e){return"string"==typeof e?e:Object.entries(e).map((([e,t])=>`${e}:${t} !important`)).join(";")}(e[t])}}`)).join("")
    }

    function Ar(e, t) {
        "lower-command" !== t && "upper-command" !== t && "symbols-command" !== t && e.executeCommand("complete"), Dr(e), fr(), Lr(e);
        const a = null == e ? void 0 : e.element.querySelectorAll(".keyboard-layer");
        let i = !1;
        for (const e of a)
            if (e.dataset.layer === t) {
                i = !0;
                break
            } if (i)
            for (const e of a) e.dataset.layer === t ? e.classList.add("is-visible") : e.classList.remove("is-visible");
        return e.focusMathfield(), !0
    }

    function Dr(e, t = "") {
        const a = e.options.virtualKeyboardContainer;
        if (!a) return !1;
        if (e.element ? e.element.classList.add("is-visible") : e.buildAndAttachElement(t), !e.visible) {
            const t = Cn();
            t.visibleVirtualKeyboard && Tr(t.visibleVirtualKeyboard), t.visibleVirtualKeyboard = e;
            const i = a.style.paddingBottom;
            e.originalContainerBottomPadding = i, a.style.paddingBottom = i ? `calc(${i} + var(--keyboard-height, 276px) - 1px)` : "calc(var(--keyboard-height, 276px) - 1px)"
        }
        return setTimeout((() => {
            var t;
            null === (t = e.element) || void 0 === t || t.classList.add("is-visible"), e.focusMathfield()
        }), 1), e.visible = !0, e.stateChanged(), !1
    }

    function Tr(e) {
        var t, a, i;
        const o = e.options.virtualKeyboardContainer;
        return !!o && (e.element && (Cn().visibleVirtualKeyboard = void 0, e.disable(), fr(), e.visible = !1, null === (t = e.coreStylesheet) || void 0 === t || t.release(), e.coreStylesheet = null, null === (a = e.virtualKeyboardStylesheet) || void 0 === a || a.release(), e.virtualKeyboardStylesheet = null, null === (i = e._element) || void 0 === i || i.remove(), e._element = void 0, null !== e.originalContainerBottomPadding && (o.style.paddingBottom = e.originalContainerBottomPadding)), e.visible = !1, e.stateChanged(), !1)
    }

    function zr(e, t, a) {
        "function" == typeof t && (a = t, t = 1 / 0), void 0 === t && (t = 1 / 0);
        let i = e.position,
            o = !1,
            r = "";
        for (; !o;) {
            const n = e.at(i);
            o = 0 === t || void 0 === n || "math" !== n.mode || !(/mord|textord|mpunct/.test(n.type) || "mop" === n.type && /[a-zA-Z]+/.test(n.value)) || !n.hasEmptyBranch("superscript") || !n.hasEmptyBranch("subscript") || "function" == typeof a && !a(n), o || (n.mode = "text", n.command = n.value, n.verbatimLatex = void 0, r += n.value), i -= 1, t -= 1
        }
        Hi(e, {
            data: r,
            inputType: "insertText"
        })
    }

    function Br(e, t, a) {
        "function" == typeof t && (a = t, t = 1 / 0), void 0 === t && (t = 1 / 0);
        let i = e.position,
            o = !1;
        const r = [];
        for (; !o;) {
            const n = e.at(i);
            o = 0 === t || !n || n.isFirstSibling || "text" !== n.mode || " " === n.value || a && !a(n), o || (r.push(n.serialize({
                defaultMode: "math"
            })), n.mode = "math"), i -= 1, t -= 1
        }
        Kr(e), Hi(e, {
            data: at(r),
            inputType: "insertText"
        })
    }

    function Kr(e) {
        var t;
        let a = e.position - 1;
        for (; a >= 0 && "math" === (null === (t = e.at(a)) || void 0 === t ? void 0 : t.mode);) a -= 1;
        if (!(a < 0) && "text" === e.at(a).mode && " " === e.at(a).value && "math" === e.at(a - 1).mode) {
            e.at(a - 1).parent.removeChild(e.at(a - 1));
            const t = e.suppressChangeNotifications;
            e.suppressChangeNotifications = !0, e.position -= 1, e.suppressChangeNotifications = t, Hi(e, {
                inputType: "deleteContent"
            })
        }
    }
    uo({
        showAlternateKeys: function(e, t) {
            var a;
            r();
            const i = kr[t],
                o = document.createElement("div");
            o.setAttribute("aria-hidden", "true"), o.className = "ML__keyboard alternate-keys" + (e.element.classList.contains("material") ? " material" : ""), o.id = "mathlive-alternate-keys-panel", i.length >= 14 ? o.style.width = "236px" : i.length >= 7 ? o.style.width = "286px" : 4 === i.length || 2 === i.length ? o.style.width = "146px" : 1 === i.length ? o.style.width = "86px" : o.style.width = "146px", o.style.height = "auto";
            let n = "";
            for (const e of i) n += "<li", "string" == typeof e ? n += ' data-latex="' + e.replace(/"/g, "&quot;") + '"' : (e.latex && (n += ' data-latex="' + e.latex.replace(/"/g, "&quot;") + '"'), e.content && (n += ' data-content="' + e.content.replace(/"/g, "&quot;") + '"'), e.insert && (n += ' data-insert="' + e.insert.replace(/"/g, "&quot;") + '"'), e.command && ("string" == typeof e.command ? n += ` data-command="${e.command.replace(/"/g,"&quot;")}"` : n += " data-command='" + JSON.stringify(e.command).replace(/"/g, "&quot;") + "'"), e.aside && (n += ` data-aside="${e.aside.replace(/"/g,"&quot;")}"`), e.class && (n += ` data-classes="${e.class}"`)), n += ">", n += "string" == typeof e ? e : null !== (a = e.label) && void 0 !== a ? a : "", n += "</li>";
            n = "<ul>" + n + "</ul>", o.innerHTML = e.options.createHTML(n), Sr(e, [...o.querySelectorAll("li")], "performAlternateKeys"), or.scrim || (or.scrim = new or), or.scrim.open({
                root: e.options.virtualKeyboardContainer,
                child: o
            });
            const s = null == e ? void 0 : e.element.querySelector('div.keyboard-layer.is-visible div.rows ul li[data-alt-keys="' + t + '"]'),
                l = null == s ? void 0 : s.getBoundingClientRect();
            if (l) {
                l.top - o.clientHeight < 0 && (o.style.width = "auto", i.length <= 6 ? o.style.height = "56px" : i.length <= 12 ? o.style.height = "108px" : i.length <= 18 ? o.style.height = "205px" : o.classList.add("compact"));
                const e = (l.top - o.clientHeight + 5).toString() + "px",
                    t = Math.max(0, Math.min(window.innerWidth - o.offsetWidth, (l.left + l.right - o.offsetWidth) / 2)) + "px";
                o.style.transform = "translate(" + t + "," + e + ")", o.classList.add("is-visible")
            }
            return !1
        }
    }, {
        target: "virtual-keyboard"
    }), uo({
        shiftKeyboardLayer: function(e) {
            const t = null == e ? void 0 : e.element.querySelectorAll("div.keyboard-layer.is-visible .rows .keycap, div.keyboard-layer.is-visible .rows .action");
            if (t)
                for (const a of t) {
                    if (a.dataset.unshiftedContent) return !1;
                    let t = a.getAttribute("data-shifted");
                    if (t || /^[a-z]$/.test(a.innerHTML)) {
                        a.dataset.unshiftedContent = a.innerHTML, t || (t = a.innerHTML.toUpperCase()), a.innerHTML = e.options.createHTML(t);
                        const o = a.getAttribute("data-command");
                        if (o) {
                            a.dataset.unshiftedCommand = o;
                            const e = a.getAttribute("data-shifted-command");
                            if (e) a.dataset.command = e;
                            else {
                                const e = JSON.parse(o);
                                i(e) && (e[1] = e[1].toUpperCase()), a.dataset.command = JSON.stringify(e)
                            }
                        }
                    }
                }
            return !1
        }
    }, {
        target: "virtual-keyboard"
    }), uo({
        hideAlternateKeys: () => fr(),
        performAlternateKeys: function(e, t) {
            return fr(), e.executeCommand(t)
        },
        switchKeyboardLayer: (e, t) => Ar(e, t),
        unshiftKeyboardLayer: e => Lr(e),
        insertAndUnshiftKeyboardLayer: function(e, t) {
            return e.executeCommand(["insert", t]), Lr(e), !0
        }
    }, {
        target: "virtual-keyboard"
    }), uo({
        toggleVirtualKeyboardAlt: function(e) {
            let t = !1;
            return (null == e ? void 0 : e.element) && (t = null == e ? void 0 : e.element.classList.contains("material"), e.disable()), Dr(e, t ? "" : "material"), !1
        },
        toggleVirtualKeyboardShift: function(e) {
            var t, a;
            e.options.virtualKeyboardLayout = {
                qwerty: "azerty",
                azerty: "qwertz",
                qwertz: "dvorak",
                dvorak: "colemak",
                colemak: "qwerty"
            } [e.options.virtualKeyboardLayout];
            const i = null !== (a = null === (t = null == e ? void 0 : e.element.querySelector("div.keyboard-layer.is-visible")) || void 0 === t ? void 0 : t.id) && void 0 !== a ? a : "";
            return e && e.disable(), Dr(e), i && Ar(e, i), !1
        }
    }, {
        target: "virtual-keyboard"
    }), uo({
        toggleVirtualKeyboard: (e, t) => function(e, t) {
            return e.visible ? Tr(e) : Dr(e, t), !1
        }(e, t),
        hideVirtualKeyboard: e => Tr(e),
        showVirtualKeyboard: (e, t) => Dr(e, t),
        onUndoStateChanged: (e, t, a) => function(e, t, a) {
            var i;
            const o = null === (i = e.element) || void 0 === i ? void 0 : i.querySelector(".keyboard-toolbar");
            if (!o) return !1;
            const r = o.querySelector("[data-command='\"undo\"']"),
                n = o.querySelector("[data-command='\"redo\"']");
            return n && (a ? n.classList.remove("disabled") : n.classList.add("disabled")), r && (t ? r.classList.remove("disabled") : r.classList.add("disabled")), !1
        }(e, t, a)
    }, {
        target: "virtual-keyboard"
    });
    var qr = "#mathlive-keystroke-caption-panel{--keystroke:#fff;--on-keystroke:#555;--keystroke-border:#f7f7f7;background:var(--secondary,hsl(var(--hue,212),19%,26%));border-color:var(--secondary-border,#e8e8e8);border-radius:6px;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);display:flex;flex-direction:row-reverse;justify-content:center;padding:16px;position:absolute;text-align:center;visibility:hidden;z-index:1}@media (prefers-color-scheme:dark){body:not([theme=light]) #mathlive-keystroke-caption-panel{--keystroke:hsl(var(--hue,212),50%,30%);--on-keystroke:#fafafa;--keystroke-border:hsl(var(--hue,212),50%,25%)}}body[theme=dark] #mathlive-keystroke-caption-panel{--keystroke:hsl(var(--hue,212),50%,30%);--on-keystroke:#fafafa;--keystroke-border:hsl(var(--hue,212),50%,25%)}#mathlive-keystroke-caption-panel>span{fill:currentColor;background-color:var(--keystroke);border:2px solid var(--keystroke-border);border-radius:6px;color:var(--on-keystroke);font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:1em;margin:0 8px 0 0;min-width:14px;padding:4px}";
    let $r, Er = null,
        Or = null;

    function Nr(e) {
        return e.keystrokeCaption || (e.keystrokeCaption = ri("mathlive-keystroke-caption-panel"), void 0 === $r && ($r = Si(qr).toString(36)), Er = Mi(null, qr, $r), Or = Mi(null, Ii, Si(Ii).toString(36))), e.keystrokeCaption
    }

    function Pr(e) {
        if (!e) return null;
        if (e.length > 1) return null;
        const t = e[0];
        return t instanceof Tt && "(" === t.leftDelim && ")" === t.rightDelim ? t.removeBranch("body") : null
    }

    function Fr(e) {
        if (e) {
            for (let t = 0; e[t]; t++) {
                const a = e[t];
                if (a instanceof Tt && "(" === a.leftDelim) {
                    let i = 0,
                        o = 0,
                        r = 0;
                    for (let e = 0; a.body[e]; e++) "genfrac" === a.body[e].type && (i++, o = e), r++;
                    0 === r && 1 === i && (e[t] = a.body[o])
                }
            }
            for (const t of e) {
                for (const e of t.branches)
                    if (!t.hasEmptyBranch(e)) {
                        Fr(t.branch(e));
                        const a = Pr(t.branch(e));
                        a && t.setChildren(a, e)
                    } if (t instanceof Vt)
                    for (const e of t.cells) Fr(e)
            }
        }
    }

    function Rr(e) {
        if (!e) return [];
        const t = [];
        for (const a of e) {
            for (const e of a.branches)
                if (!a.hasEmptyBranch(e)) {
                    const i = Rr(a.branch(e));
                    t.push(...i)
                } a instanceof Bt && t.push(a)
        }
        return t
    }

    function Ir(e) {
        return !!/^(mord|surd|msubsup|leftright|mop|mclose)$/.test(e.type) && !e.isExtensibleSymbol && !e.isFunction
    }

    function Vr(e, t, a) {
        const i = e.at(e.position),
            {
                parent: o
            } = i;
        let r = o instanceof Tt ? o.leftDelim + o.rightDelim : "";
        if ("\\lbrace\\rbrace" === r && (r = "{}"), "\\{\\}" === r && (r = "{}"), "\\lparen\\rparen" === r && (r = "()"), "{}" === r && /\||\\vert|\\Vert|\\mvert|\\mid/.test(t)) return Oa.insert("math", e, "\\,\\middle" + t + "\\, ", {
            format: "latex",
            style: a
        }), !0;
        if ("{" !== t && "\\{" !== t || (t = "\\lbrace"), "}" !== t && "\\}" !== t || (t = "\\rbrace"), "[" === t && (t = "\\lbrack"), "]" === t && (t = "\\rbrack"), pt[t]) {
            const r = o;
            if ("leftright" === r.type && r.firstChild === i && ("?" === r.leftDelim || "." === r.leftDelim)) return r.leftDelim = t, r.isDirty = !0, !0;
            if (!(o instanceof Tt && "|" === o.leftDelim)) {
                if (Oa.insert("math", e, `\\left${t}\\right?`, {
                        format: "latex",
                        style: a
                    }), "first" !== i.lastSibling.type) {
                    const t = e.offsetOf(i.lastSibling),
                        a = e.extractAtoms([e.position, t]);
                    e.at(e.position).body = a, e.position -= 1
                }
                return !0
            }
        }
        let n = "";
        if (Object.keys(pt).forEach((e => {
                t === pt[e] && (n = e)
            })), n) {
            if (o instanceof Tt && i.isLastSibling) return o.isDirty = !0, o.rightDelim = t, e.position += 1, Hi(e, {
                data: t,
                inputType: "insertText"
            }), !0;
            const r = e.offsetOf(i.firstSibling);
            let n;
            for (n = e.position; n >= r; n--) {
                const t = e.at(n);
                if (t instanceof Tt && "?" === t.rightDelim) break
            }
            const s = e.at(n);
            if (n >= r && s instanceof Tt) return s.rightDelim = t, s.addChildren(e.extractAtoms([n, e.position]), i.treeBranch), e.position = n, Hi(e, {
                data: t,
                inputType: "insertText"
            }), !0;
            if (o instanceof Tt && "?" === o.rightDelim) return o.isDirty = !0, o.rightDelim = t, o.parent.addChildren(e.extractAtoms([e.position, e.offsetOf(i.lastSibling)]), o.treeBranch), e.position = e.offsetOf(o), Hi(e, {
                data: t,
                inputType: "insertText"
            }), !0;
            const l = o.parent;
            return !!(l instanceof Tt && "?" === l.rightDelim && e.at(e.position).isLastSibling) && (e.position = e.offsetOf(l), Vr(e, t, a))
        }
        return !1
    }

    function jr(e, t, a) {
        var i, o, r, n;
        const {
            model: s
        } = e;
        ! function(e) {
            var t, a;
            if (!e) return;
            if ("Unidentified" === e.key) return;
            if ("Dead" === e.key) return;
            const i = e.shiftKey && e.altKey ? 3 : e.altKey ? 2 : e.shiftKey ? 1 : 0;
            for (const o of Ti)(null === (t = o.mapping[e.code]) || void 0 === t ? void 0 : t[i]) === e.key ? o.score += 1 : (null === (a = o.mapping[e.code]) || void 0 === a ? void 0 : a[i]) && (o.score = 0);
            Ti.sort(((e, t) => t.score - e.score))
        }(a);
        const l = Ki();
        if (e.keyboardLayout !== l.id && (e.keyboardLayout = l.id, e._keybindings = void 0), clearTimeout(e.inlineShortcutBufferFlushTimer), e.inlineShortcutBufferFlushTimer = 0, function(e, t) {
                if (e.options.readOnly || !e.keystrokeCaptionVisible) return;
                const a = Nr(e),
                    i = e.element.getBoundingClientRect();
                a.style.left = `${i.left}px`, a.style.top = i.top - 64 + "px", a.innerHTML = e.options.createHTML("<span>" + (Ni(t) || t) + "</span>" + a.innerHTML), a.style.visibility = "visible", setTimeout((() => {
                    a.childNodes.length > 0 && a.childNodes[a.childNodes.length - 1].remove(), 0 === a.childNodes.length && (a.style.visibility = "hidden")
                }), 3e3)
            }(e, t), a.defaultPrevented) return e.flushInlineShortcutBuffer(), !1;
        let d, c, u = "";
        if (!e.options.readOnly) {
            if ("math" === e.mode && !a.ctrlKey && !a.metaKey)
                if ("[Backspace]" === t) e.inlineShortcutBuffer.pop(), e.flushInlineShortcutBuffer({
                    defer: !0
                });
                else if (sr(a)) {
                const t = cr(a),
                    r = (null !== (o = null === (i = e.inlineShortcutBuffer[e.inlineShortcutBuffer.length - 1]) || void 0 === i ? void 0 : i.keystrokes) && void 0 !== o ? o : "") + t;
                e.inlineShortcutBuffer.push({
                    state: s.getState(),
                    keystrokes: r,
                    leftSiblings: Wr(e)
                });
                let n = 0,
                    l = "";
                for (; !d && n < r.length;) {
                    c = e.inlineShortcutBuffer.length - (r.length - n), l = r.slice(n);
                    const t = e.inlineShortcutBuffer[c].leftSiblings;
                    d = Aa(t, l, e.options.inlineShortcuts), !d && /^[a-zA-Z][a-zA-Z0-9]+?([_\^][a-zA-Z0-9\*\+\-]+?)?$/.test(l) && (d = e.options.onInlineShortcut(e, l)), n += 1
                }
                e.flushInlineShortcutBuffer({
                    defer: !0
                })
            } else e.flushInlineShortcutBuffer(), e.snapshot();
            if (e.options.smartMode) {
                const i = e.mode;
                d ? e.mode = "math" : function(e, t, a) {
                    if (e.smartModeSuppressed) return !1;
                    const {
                        model: i
                    } = e;
                    if (!i.at(i.position).isLastSibling) return !1;
                    if (!a || !sr(a)) return !1;
                    const o = cr(a);
                    if (!i.selectionIsCollapsed) return !("text" !== e.mode || !/[/_^]/.test(o));
                    const r = function(e) {
                        let t = "",
                            a = e.position,
                            i = !1;
                        for (; !i;) {
                            const o = e.at(a);
                            i = !(o && ("text" === o.mode || "math" === o.mode && /mord|textord|mpunct/.test(o.type))), i || (t = o.value + t), a -= 1
                        }
                        return t
                    }(i) + o;
                    if ("text" === e.mode) {
                        if ("Esc" === t || /[/\\]/.test(o)) return !0;
                        if (/[\^_]/.test(o)) return /(^|\s)[a-zA-Z][^_]$/.test(r) && Br(i, 1), !0;
                        const e = {
                                ")": "(",
                                "}": "{",
                                "]": "["
                            } [o],
                            {
                                parent: a
                            } = i.at(i.position);
                        if (e && a instanceof Tt && a.leftDelim === e) return !0;
                        if (/(^|[^a-zA-Z])(a|I) $/.test(r)) return !1;
                        if (/[$\u20ac\xa3\u20a4\u20ba\xa5\xa4\u0e3f\xa2\u20a1\u20a7\u20a8\u20b9\u20a9\u20b1]/u.test(o)) return !0;
                        if (/(^|[^a-zA-Z'\u2019])[a-zA-Z] $/.test(r)) return Br(i, 1), !1;
                        if (/\D\.[^\d\s]$/.test(r)) {
                            Br(i, 1);
                            const e = i.at(i.position);
                            return e.value = "⋅", e.style.variant = "normal", e.command = "\\cdot", e.verbatimLatex = void 0, Hi(i, {
                                data: "\\cdot",
                                inputType: "insertText"
                            }), !0
                        }
                        if (/(^|\s)[a-zA-Z][^a-zA-Z]$/.test(r)) return Br(i, 1), !0;
                        if (/\.\d$/.test(r)) return Br(i, 1), !0;
                        if (/\([\d+\-.]$/.test(r)) return Br(i, 1), !0;
                        if (/\([a-z][,;]$/.test(r)) return Br(i, 2), !0;
                        if (/[\d+\-=><*|]$/.test(o)) return Kr(i), !0
                    } else {
                        if ("[Space]" === t) return zr(i, void 0, (e => /[a-z][:,;.]$/.test(e.value))), !0;
                        if (/[a-zA-Z]{3,}$/.test(r) && !/(dxd|abc|xyz|uvw)$/.test(r)) return zr(i, void 0, (e => /[a-zA-Z]/.test(e.value))), !0;
                        if (/(^|\W)(if)$/i.test(r)) return zr(i, 1), !0;
                        if (/(\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5){3,}$/u.test(r) && !/(\u03b1\u03b2\u03b3)$/.test(r)) return zr(i, void 0, (e => /(:|,|;|.|\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5)/u.test(e.value))), !0;
                        if ("?" === o) return !0;
                        if ("." === o && !/[\d-+]\.$/.test(r)) return !0
                    }
                    return !1
                }(e, t, a) && (e.mode = {
                    math: "text",
                    text: "math"
                } [e.mode], u = ""), e.mode !== i && ((null === (r = e.host) || void 0 === r ? void 0 : r.dispatchEvent(new Event("mode-change", {
                    bubbles: !0,
                    composed: !0,
                    cancelable: !0
                }))) || (e.mode = i))
            }
        }
        if (!d) {
            if (u || (u = function(e, t, a) {
                    if (0 === e.length) return "";
                    const i = Ci(Li(a));
                    for (let a = e.length - 1; a >= 0; a--)
                        if (e[a].key === i && (!e[a].ifMode || e[a].ifMode === t)) return e[a].command;
                    return ""
                }(e.keybindings, e.mode, t)), !u && ("[Enter]" === t || "[Return]" === t)) {
                let t = !1;
                return ji(s, {
                    inputType: "insertLineBreak"
                }) && (e.host && (t = !e.host.dispatchEvent(new Event("change", {
                    bubbles: !0,
                    composed: !0
                }))), t || a.preventDefault && (a.preventDefault(), a.stopPropagation()), Hi(s, {
                    inputType: "insertLineBreak"
                })), t
            }
            if ("math" === e.mode) {
                if ("[Space]" === t) {
                    if (e.flushInlineShortcutBuffer(), e.options.mathModeSpace) return e.snapshot(), Oa.insert("math", s, e.options.mathModeSpace, {
                        format: "latex"
                    }), u = "", e.dirty = !0, e.scrollIntoView(), a.preventDefault && (a.preventDefault(), a.stopPropagation()), !1;
                    const t = s.at(s.position + 1),
                        i = s.at(s.position - 1);
                    "text" !== (null == t ? void 0 : t.mode) && "text" !== (null == i ? void 0 : i.mode) || (e.snapshot(), Oa.insert("text", s, " "), e.dirty = !0)
                }(null === (n = s.at(s.position)) || void 0 === n ? void 0 : n.isDigit()) && "," === e.options.decimalSeparator && "," === cr(a) && (u = "insertDecimalSeparator")
            }
        }
        if (!d && !u) return !0;
        const p = s.at(Math.max(s.position, s.anchor)),
            {
                parent: h
            } = p;
        if ("moveAfterParent" === u && "leftright" === (null == h ? void 0 : h.type) && p.isLastSibling && e.options.smartFence && Vr(s, ".", e.style) && (u = "", no(e)), u) e.executeCommand(u);
        else if (d) {
            e.keyboardDelegate.cancelComposition();
            const t = {
                ...s.at(s.position).computedStyle,
                ...e.style
            };
            if (!/^\\({|}|\[|]|@|#|\$|%|&|\^|_|backslash)$/.test(d)) {
                const i = e.mode;
                Oa.insert(e.mode, s, cr(a), {
                    suppressChangeNotifications: !0,
                    style: t
                }), e.snapshot(), s.setState(e.inlineShortcutBuffer[c].state), e.mode = i
            }
            s.deferNotifications({
                content: !0,
                selection: !0,
                data: null != d ? d : null,
                type: "insertText"
            }, (() => (Oa.insert(e.mode, s, d, {
                format: "latex",
                style: t
            }), Kr(e.model), d.endsWith(" ") && (e.mode = "text", Oa.insert("text", s, " ", {
                style: t
            })), !0))), e.snapshot(), e.dirty = !0, s.announce("replacement")
        }
        return e.scrollIntoView(), a.preventDefault && a.preventDefault(), !1
    }

    function Hr(e, t, a) {
        var i;
        const {
            model: o
        } = e;
        if (e.options.readOnly) return void o.announce("plonk");
        if ((a = null != a ? a : {}).focus && e.focus(), a.feedback && (e.options.keypressVibration && s() && navigator.vibrate(3), e.playSound("keypress")), "string" == typeof a.mode && e.mode !== a.mode && e.switchMode(a.mode), a.simulateKeystroke) {
            const a = t.charAt(0),
                i = new KeyboardEvent("keypress", {
                    key: a
                });
            if (!jr(e, a, i)) return
        }
        const r = o.at(o.position),
            n = {
                ...r.computedStyle,
                ...e.style
            };
        o.selectionIsCollapsed || (o.deleteAtoms(Ca(o.selection)), e.snapshot());
        const l = Ye(t);
        if ("latex" === e.mode) o.deferNotifications({
            content: !0,
            selection: !0,
            data: t,
            type: "insertText"
        }, (() => {
            Ui(e);
            for (const e of l) Oa.insert("latex", o, e);
            Xi(e)
        }));
        else if ("text" === e.mode)
            for (const e of l) Oa.insert("text", o, e, {
                style: n
            });
        else if ("math" === e.mode)
            for (const t of l) {
                let a = {
                    "^": "moveToSuperscript",
                    _: "moveToSubscript",
                    " ": "moveAfterParent"
                } [t];
                " " === t && e.options.mathModeSpace && (a = ["insert", e.options.mathModeSpace]), a ? e.executeCommand(a) : /\d/.test(t) && e.options.smartSuperscript && "superscript" === r.treeBranch && "mop" !== (null === (i = r.parent) || void 0 === i ? void 0 : i.type) && r.hasNoSiblings ? (Oa.insert("math", o, t, {
                    style: n
                }), Qo(o)) : ("mord" === r.type && /[a-zA-Z]/.test(r.value) && /[a-zA-Z]/.test(t) && (r.style.variant && (n.variant = r.style.variant), r.style.variantStyle && (n.variantStyle = r.style.variantStyle)), Oa.insert("math", o, t, {
                    style: n
                }))
            }
        e.snapshotAndCoalesce(), e.dirty = !0, e.scrollIntoView()
    }

    function Wr(e) {
        const t = e.model,
            a = [];
        let i = t.at(Math.min(t.position, t.anchor));
        for (;
            "first" !== i.type;) a.push(i), i = i.leftSibling;
        return a
    }

    function Jr(e, t) {
        var a, i, o, r, n, s;
        const l = {};
        "string" == typeof t.color && (l.verbatimColor = t.color, l.color = null !== (a = e.colorMap(t.color)) && void 0 !== a ? a : "none"), "string" == typeof t.backgroundColor && (l.verbatimBackgroundColor = t.backgroundColor, l.backgroundColor = null !== (i = e.backgroundColorMap(t.backgroundColor)) && void 0 !== i ? i : "none"), "string" == typeof t.fontFamily && (l.fontFamily = t.fontFamily), "string" == typeof t.series && (l.fontSeries = t.series), "string" == typeof t.fontSeries && (l.fontSeries = t.fontSeries.toLowerCase()), l.fontSeries && (l.fontSeries = null !== (o = {
            bold: "b",
            medium: "m",
            normal: "m"
        } [l.fontSeries]) && void 0 !== o ? o : l.fontSeries), "string" == typeof t.shape && (l.fontShape = t.shape), "string" == typeof t.fontShape && (l.fontShape = t.fontShape.toLowerCase()), l.fontShape && (l.fontShape = null !== (r = {
            italic: "it",
            up: "n",
            upright: "n",
            normal: "n"
        } [l.fontShape]) && void 0 !== r ? r : l.fontShape);
        const d = null !== (n = t.size) && void 0 !== n ? n : t.fontSize;
        return "number" == typeof d ? l.fontSize = Math.max(1, Math.min(10, d)) : "string" == typeof d && (l.fontSize = null !== (s = {
            size1: 1,
            size2: 2,
            size3: 3,
            size4: 4,
            size5: 5,
            size6: 6,
            size7: 7,
            size8: 8,
            size9: 9,
            size10: 10
        } [d.toLowerCase()]) && void 0 !== s ? s : {
            tiny: 1,
            scriptsize: 2,
            footnotesize: 3,
            small: 4,
            normal: 5,
            normalsize: 5,
            large: 6,
            Large: 7,
            LARGE: 8,
            huge: 9,
            Huge: 10
        } [d]), l
    }
    new class extends Oa {
        onPaste(e, t) {
            if (!t.clipboardData) return !1;
            if (!ji(e.model, {
                    dataTransfer: t.clipboardData,
                    inputType: "insertFromPaste"
                })) return !1;
            let a = "",
                i = "auto",
                o = t.clipboardData.getData("application/json+mathlive");
            if (o) try {
                const a = JSON.parse(o);
                if (a && Array.isArray(a)) {
                    e.snapshot();
                    const i = ga(a, e),
                        {
                            model: o
                        } = e;
                    o.selectionIsCollapsed || o.deleteAtoms(Ca(o.selection));
                    const r = o.at(o.position);
                    if (r.parent instanceof Vt) {
                        const e = [];
                        let t = [];
                        "first" === i[0].type && i.shift(), "first" === i[i.length - 1].type && i.pop();
                        for (const a of i) "first" === a.type && t.length > 0 ? (e.push(t), t = [a]) : t.push(a);
                        t.length > 0 && e.push(t);
                        let a = Number(r.treeBranch[0]),
                            o = Number(r.treeBranch[1]);
                        const n = r.parent.maxColumns;
                        for (; r.parent.colCount - o < e.length && r.parent.colCount < n;) r.parent.addColumn();
                        r.parent.addChildrenAfter(e[0], r);
                        for (let t = 1; t < e.length; t++) o++, o >= n && (o = 0, r.parent.addRowAfter(a), a++), r.parent.setCell(a, o, e[t])
                    } else r.parent.addChildrenAfter(i.filter((e => "first" !== e.type)), r);
                    return o.position = o.offsetOf(i[i.length - 1]), Hi(o, {
                        inputType: "insertFromPaste"
                    }), no(e), t.preventDefault(), t.stopPropagation(), !0
                }
            } catch {}
            if (o = t.clipboardData.getData("application/json"), o && e.computeEngine) try {
                const t = JSON.parse(o);
                if ("object" == typeof t && "latex" in t && t.latex && (a = t.latex), !a) {
                    const i = e.computeEngine.box(t);
                    i && !i.has("Error") && (a = i.latex)
                }
                a || (i = "latex")
            } catch {}
            if (a || (a = t.clipboardData.getData("application/x-latex"), a && (i = "latex")), a || (a = t.clipboardData.getData("text/plain")), a) {
                let o;
                return e.snapshot(), [o, a] = $a(a), "auto" === i && o && (i = "latex"), this.insert(e.model, a, {
                    format: i
                }) && no(e), t.preventDefault(), t.stopPropagation(), !0
            }
            return !1
        }
        insert(e, t, a) {
            var i, o;
            const r = "string" == typeof t ? t : null !== (o = null === (i = e.mathfield.computeEngine) || void 0 === i ? void 0 : i.box(t).latex) && void 0 !== o ? o : "";
            if (!a.suppressChangeNotifications && !ji(e, {
                    data: r,
                    inputType: "insertText"
                })) return !1;
            if (a.insertionMode || (a.insertionMode = "replaceSelection"), a.selectionMode || (a.selectionMode = "placeholder"), a.format || (a.format = "auto"), e.mathfield.smartFence) {
                if (e.selectionIsCollapsed && "string" == typeof t && Vr(e, t, a.style)) return !0
            } else if ("replaceAll" !== a.insertionMode) {
                const {
                    parent: a
                } = e.at(e.position);
                if (a instanceof Tt && "?" === a.rightDelim && e.at(e.position).isLastSibling && "string" == typeof t && /^[)}\]|]$/.test(t)) return a.isDirty = !0, a.rightDelim = t, e.position += 1, Vi(e), Hi(e, {
                    data: r,
                    inputType: "insertText"
                }), !0
            }
            const {
                suppressChangeNotifications: n
            } = e;
            a.suppressChangeNotifications && (e.suppressChangeNotifications = !0);
            const s = e.suppressChangeNotifications;
            e.suppressChangeNotifications = !0;
            const l = {};
            if (l[0] = "replaceAll" === a.insertionMode ? "" : e.getValue(e.selection, "latex-unstyled"), l["?"] = "\\placeholder{}", l["@"] = l["?"], "replaceSelection" !== a.insertionMode || e.selectionIsCollapsed ? "replaceAll" === a.insertionMode ? (e.root.setChildren([], "body"), e.position = 0) : "insertBefore" === a.insertionMode ? e.collapseSelection("backward") : "insertAfter" === a.insertionMode && e.collapseSelection("forward") : e.deleteAtoms(Ca(e.selection)), e.at(e.position).isLastSibling || "placeholder" !== e.at(e.position + 1).type ? "placeholder" === e.at(e.position).type && e.deleteAtoms([e.position - 1, e.position]) : e.deleteAtoms([e.position, e.position + 1]), l[0]) l["@"] = l[0];
            else if ("string" == typeof t && /(^|[^\\])#@/.test(t)) {
                const t = function(e) {
                    let t = e.at(e.position);
                    if ("text" === t.mode) {
                        for (; !t.isFirstSibling && "text" === t.mode;) t = t.leftSibling;
                        return e.offsetOf(t)
                    }
                    const a = t,
                        i = [];
                    for (; !t.isFirstSibling && (Ir(t) || i.length > 0);) "mclose" === t.type && i.unshift(t.value), "mopen" === t.type && i.length > 0 && t.value === ht[i[0]] && i.shift(), t = t.leftSibling;
                    return a === t ? -1 : e.offsetOf(t)
                }(e);
                t >= 0 && (l["@"] = e.getValue(t, e.position, "latex-unstyled"), e.deleteAtoms([t, e.position]))
            }
            l[0] || (l[0] = l["?"]);
            let d = !1;
            const [c, u] = function(e, t, a, i) {
                var o;
                let r, n = [];
                if ("string" != typeof t || "math-json" === i.format) {
                    if (!e.mathfield.computeEngine) return ["math-json", []];
                    [r, t] = ["latex", e.mathfield.computeEngine.box(t).latex], n = Nt(t, e.mathfield, {
                        parseMode: "math"
                    })
                } else "string" == typeof t && "ascii-math" === i.format ? ([r, t] = Ta(t, {
                    format: "ascii-math",
                    inlineShortcuts: e.mathfield.options.inlineShortcuts
                }), n = Nt(t, e.mathfield, {
                    parseMode: "math"
                }), "latex" !== r && e.options.removeExtraneousParentheses && Fr(n)) : ("auto" === i.format || (null === (o = i.format) || void 0 === o ? void 0 : o.startsWith("latex"))) && ("auto" === i.format && ([r, t] = Ta(t, {
                    format: "auto",
                    inlineShortcuts: e.mathfield.options.inlineShortcuts
                })), "latex" === i.format && ([, t] = $a(t)), n = Nt(t, e.mathfield, {
                    parseMode: "math",
                    args: e => (d = !0, l[e])
                }), "latex" !== i.format && e.options.removeExtraneousParentheses && Fr(n));
                return Jo(n, i.style), [null != r ? r : "latex", n]
            }(e, t, 0, a);
            if (!u) return !1;
            const p = Rr(u),
                h = p.filter((t => t.placeholderId && !e.mathfield.placeholders.has(t.placeholderId))),
                m = p.map((e => e.placeholderId));
            [...e.mathfield.placeholders.keys()].filter((e => !m.includes(e))).forEach((t => {
                var a;
                e.mathfield.placeholders.has(t) && (null === (a = e.mathfield.placeholders.get(t)) || void 0 === a || a.field.remove(), e.mathfield.placeholders.delete(t))
            })), h.forEach((t => {
                var a, i;
                let o = e.mathfield.options.virtualKeyboardMode;
                "manual" === o && (o = "onfocus");
                const r = new fn({
                        ...e.mathfield.options,
                        virtualKeyboardMode: o,
                        readOnly: !1
                    }),
                    n = t.defaultValue ? lt.serialize(t.defaultValue, {
                        defaultMode: "math"
                    }) : "";
                r.value = n, r.addEventListener("input", (() => {
                    ! function(e, t) {
                        !e.suppressChangeNotifications && e.mathfield.host && (e.suppressChangeNotifications = !0, e.mathfield.host.dispatchEvent(new CustomEvent("placeholder-change", {
                            detail: {
                                placeholderId: t
                            },
                            bubbles: !0,
                            composed: !0
                        })), e.suppressChangeNotifications = !1)
                    }(e, t.placeholderId), setTimeout((() => no(e.mathfield)))
                })), null === (i = null === (a = e.mathfield.element) || void 0 === a ? void 0 : a.querySelector(".ML__placeholdercontainer")) || void 0 === i || i.appendChild(r), e.mathfield.placeholders.set(t.placeholderId, {
                    atom: t,
                    field: r
                })
            }));
            const {
                parent: f
            } = e.at(e.position);
            if ("latex" !== c && e.options.removeExtraneousParentheses && f instanceof Tt && "(" === f.leftDelim && f.hasEmptyBranch("body") && 1 === u.length && "genfrac" === u[0].type) {
                const e = f.parent,
                    t = f.treeBranch;
                e.removeChild(f), e.setChildren(u, t)
            }
            const y = f.hasEmptyBranch("body"),
                b = e.at(e.position);
            b.parent.addChildrenAfter(u, b), "latex" === c && "string" == typeof t && "root" === f.type && y && !d && (f.verbatimLatex = t), e.suppressChangeNotifications = s;
            const g = u[u.length - 1];
            if ("placeholder" === a.selectionMode) {
                const t = u.reduce(((e, t) => [...e, ...t.children.filter((e => "placeholder" === e.type))]), []);
                if (t.length > 0) {
                    const a = e.offsetOf(t[0]);
                    e.setSelection(a - 1, a), e.announce("move")
                } else g && (e.position = e.offsetOf(g))
            } else "before" === a.selectionMode || ("after" === a.selectionMode ? g && (e.position = e.offsetOf(g)) : "item" === a.selectionMode && e.setSelection(e.anchor, e.offsetOf(g)));
            return Hi(e, {
                data: r,
                inputType: "insertText"
            }), e.suppressChangeNotifications = n, !0
        }
        constructor() {
            super("math")
        }
    }, uo({
        undo: e => (Zi(e, "accept"), e.undo(), !0),
        redo: e => (Zi(e, "accept"), e.redo(), !0),
        scrollIntoView: e => (e.scrollIntoView(), !0),
        scrollToStart: e => (e.field.scroll(0, 0), !0),
        scrollToEnd: e => {
            const t = e.field.getBoundingClientRect();
            return e.field.scroll(t.left - window.scrollX, 0), !0
        },
        enterLatexMode: e => (e.switchMode("latex"), !0),
        toggleKeystrokeCaption: function(e) {
            return e.keystrokeCaptionVisible = !e.keystrokeCaptionVisible, e.keystrokeCaptionVisible ? (e.keystrokeCaption = Nr(e), e.keystrokeCaption.innerHTML = "") : e.keystrokeCaption && (e.keystrokeCaption.style.visibility = "hidden"), !1
        },
        plonk: e => (e.model.announce("plonk"), !0),
        switchMode: (e, t, a, i) => (e.switchMode(t, a, i), !0),
        insert: (e, t, a) => e.insert(t, a),
        typedText: (e, t, a) => (Hr(e, t, a), !0),
        insertDecimalSeparator: e => {
            if ("math" === e.mode && "," === e.options.decimalSeparator) {
                const t = e.model;
                if (t.at(Math.max(t.position, t.anchor)).isDigit()) return e.snapshot(), e.insert("{,}", {
                    format: "latex"
                }), !0
            }
            return e.insert("."), !0
        },
        commit: e => (ji(e.model, {
            inputType: "insertLineBreak"
        }) && (e.host && e.host.dispatchEvent(new Event("change", {
            bubbles: !0,
            composed: !0
        })), Hi(e.model, {
            inputType: "insertLineBreak"
        })), !0)
    }), uo({
        copyToClipboard: e => (e.focus(), e.model.selectionIsCollapsed && e.select(), document.execCommand("copy"), !1),
        cutToClipboard: e => (e.focus(), document.execCommand("cut"), !0),
        pasteFromClipboard: e => (e.focus(), document.execCommand("paste"), !0)
    }, {
        target: "mathfield",
        category: "clipboard"
    }), uo({
        applyStyle: function(e, t) {
            e.flushInlineShortcutBuffer();
            const a = Jr(e, t),
                {
                    model: i
                } = e;
            return i.selectionIsCollapsed ? (e.style.fontSeries && a.fontSeries === e.style.fontSeries && (a.fontSeries = "auto"), a.fontShape && a.fontShape === e.style.fontShape && (a.fontShape = "auto"), a.color && a.color === e.style.color && (a.color = "none"), a.backgroundColor && a.backgroundColor === e.style.backgroundColor && (a.backgroundColor = "none"), a.fontSize && a.fontSize === e.style.fontSize && (a.fontSize = "auto"), e.style = {
                ...e.style,
                ...a
            }) : e.model.deferNotifications({
                content: !0,
                type: "insertText"
            }, (() => {
                i.selection.ranges.forEach((e => Uo(i, e, a, {
                    operation: "toggle"
                }))), e.snapshot()
            })), !0
        }
    }, {
        target: "mathfield"
    });
    let Ur = null,
        Xr = 0;

    function Gr(e) {
        return o() && "TouchEvent" in globalThis && e instanceof TouchEvent
    }

    function Zr(e) {
        return o() && "PointerEvent" in globalThis && e instanceof PointerEvent
    }

    function Yr(e, t, a) {
        if (e >= a.left && e <= a.right && t >= a.top && t <= a.bottom) return 0;
        const i = e - (a.left + a.right) / 2,
            o = t - (a.top + a.bottom) / 2;
        return i * i + o * o
    }

    function Qr(e, t, a, i, o) {
        if (!a.id) return [1 / 0, null];
        if (t.has(a.id)) return t.get(a.id);
        const r = pi(e, a);
        if (!r) return [1 / 0, null];
        let n = [1 / 0, null];
        if (a.hasChildren && !a.captureSelection && i >= r.left && i <= r.right)
            for (const r of a.children) {
                const a = Qr(e, t, r, i, o);
                a[0] <= n[0] && (n = a)
            }
        return n[1] || (n = [Yr(i, o, r), a]), t.set(a.id, n), n
    }

    function en(e, t, a) {
        const [, i] = Qr(e, new Map, e.model.root, t, a);
        return i
    }

    function tn(e, t, a, i) {
        var o;
        const r = e.fieldContent.getBoundingClientRect();
        if (t > r.right || a > r.bottom + 8) return e.model.lastOffset;
        if (t < r.left || a < r.top - 8) return 0;
        (i = null != i ? i : {}).bias = null !== (o = i.bias) && void 0 !== o ? o : 0;
        let n = en(e, t, a);
        const s = [];
        let l = n;
        for (; l;) s.unshift(l), l = l.parent;
        for (const e of s)
            if (e.captureSelection) {
                n = e;
                break
            } let d = e.model.offsetOf(n);
        if (d < 0) return -1;
        if (n.leftSibling)
            if (0 === i.bias && "placeholder" !== n.type) {
                const a = pi(e, n);
                a && t < (a.left + a.right) / 2 && (d = e.model.offsetOf(n.leftSibling))
            } else i.bias < 0 && (d = e.model.offsetOf(n.leftSibling));
        return d
    }
    new class extends Oa {
        onPaste(e, t) {
            if (!t.clipboardData) return !1;
            const a = t.clipboardData.getData("text/plain");
            return !(!a || !ji(e.model, {
                inputType: "insertFromPaste",
                data: a
            }) || (e.snapshot(), this.insert(e.model, a) && (Hi(e.model, {
                inputType: "insertFromPaste"
            }), no(e)), t.preventDefault(), t.stopPropagation(), 0))
        }
        insert(e, t, a = {}) {
            if (!ji(e, {
                    data: t,
                    inputType: "insertText"
                })) return !1;
            a.insertionMode || (a.insertionMode = "replaceSelection"), a.selectionMode || (a.selectionMode = "placeholder"), a.format || (a.format = "auto");
            const {
                suppressChangeNotifications: i
            } = e;
            a.suppressChangeNotifications && (e.suppressChangeNotifications = !0);
            const o = e.suppressChangeNotifications;
            e.suppressChangeNotifications = !0, "replaceSelection" !== a.insertionMode || e.selectionIsCollapsed ? "replaceAll" === a.insertionMode ? (e.root.setChildren([], "body"), e.position = 0) : "insertBefore" === a.insertionMode ? e.collapseSelection("backward") : "insertAfter" === a.insertionMode && e.collapseSelection("forward") : e.deleteAtoms(Ca(e.selection));
            const r = (n = t, s = e.mathfield, Nt(n = (n = (n = (n = (n = (n = (n = (n = (n = (n = (n = n.replace(/\\/g, "\\textbackslash ")).replace(/#/g, "\\#")).replace(/\$/g, "\\$")).replace(/%/g, "\\%")).replace(/&/g, "\\&")).replace(/_/g, "\\_")).replace(/{/g, "\\textbraceleft ")).replace(/}/g, "\\textbraceright ")).replace(/\^/g, "\\textasciicircum ")).replace(/~/g, "\\textasciitilde ")).replace(/\xa3/g, "\\textsterling "), s, {
                parseMode: "text"
            }));
            var n, s;
            if (Jo(r, a.style), !r) return !1;
            const l = e.at(e.position),
                d = l.parent.addChildrenAfter(r, l);
            return e.suppressChangeNotifications = o, "before" === a.selectionMode || ("item" === a.selectionMode ? e.setSelection(e.anchor, e.offsetOf(d)) : d && (e.position = e.offsetOf(d))), Hi(e, {
                data: t,
                inputType: "insertText"
            }), e.suppressChangeNotifications = i, !0
        }
        constructor() {
            super("text")
        }
    };
    const an = "mathlive#remote-virtual-keyboard-message";
    class on {
        get visible() {
            var e, t;
            return null !== (t = null === (e = Cn().sharedVirtualKeyboard) || void 0 === e ? void 0 : e.visible) && void 0 !== t && t
        }
        set visible(e) {
            Cn().sharedVirtualKeyboard && (Cn().sharedVirtualKeyboard.visible = e)
        }
        setOptions(e) {
            this.sendMessage("setOptions", {
                options: JSON.stringify(rn(e))
            })
        }
        create() {}
        dispose() {
            this.disable()
        }
        enable() {
            this.enabled || (this.enabled = !0, globalThis.addEventListener("message", this))
        }
        disable() {
            this.enabled && (globalThis.removeEventListener("message", this), this.enabled = !1)
        }
        executeCommand(e) {
            var t, a, i;
            return "virtual-keyboard" === po(e) ? (this._mathfield && (this.setOptions(rn(this._mathfield.getOptions())), ("showVirtualKeyboard" === e || "toggleVirtualKeyboard" === e && !1 === this.visible) && (null === (a = (t = this._mathfield).focus) || void 0 === a || a.call(t))), this.sendMessage("executeCommand", {
                command: e
            }), !1) : null === (i = this._mathfield) || void 0 === i ? void 0 : i.executeCommand(e)
        }
        focusMathfield() {}
        blurMathfield() {}
        stateChanged() {}
        handleEvent(e) {
            var t, a, i, o;
            if ("message" === e.type && e.data && e.data.type === an) {
                if (!mi(e.origin, this.originValidator)) throw new Error(`Message from unknown origin (${e.origin}) cannot be handled`);
                const {
                    action: r
                } = e.data;
                if ("executeCommand" === r) {
                    if ("virtual-keyboard" === po(e.data.command) && window === globalThis.parent) return;
                    this.executeCommand(e.data.command)
                } else "updateState" === r ? (this.visible = e.data.state.visible, this.height = e.data.state.height) : "focus" === r ? null === (a = null === (t = this._mathfield) || void 0 === t ? void 0 : t.focus) || void 0 === a || a.call(t) : "blur" === r && (null === (o = null === (i = this._mathfield) || void 0 === i ? void 0 : i.blur) || void 0 === o || o.call(i))
            }
        }
        sendMessage(e, t = {}) {
            return !!globalThis.parent && (globalThis.parent.postMessage({
                type: an,
                action: e,
                ...t
            }, this.targetOrigin), !0)
        }
        constructor(e) {
            var t, a, i;
            this.targetOrigin = null !== (a = null !== (t = e.targetOrigin) && void 0 !== t ? t : globalThis.origin) && void 0 !== a ? a : "*", this.originValidator = null !== (i = e.originValidator) && void 0 !== i ? i : "same-origin", this._mathfield = e.mathfield
        }
    }

    function rn(e) {
        if ("object" != typeof e) return {};
        const t = {};
        return e.fontsDirectory && (t.fontsDirectory = e.fontsDirectory), e.soundsDirectory && (t.soundsDirectory = e.soundsDirectory), e.virtualKeyboards && (t.virtualKeyboards = e.virtualKeyboards), e.virtualKeyboardLayout && (t.virtualKeyboardLayout = e.virtualKeyboardLayout), e.customVirtualKeyboardLayers && (t.customVirtualKeyboardLayers = e.customVirtualKeyboardLayers), e.customVirtualKeyboards && (t.customVirtualKeyboards = e.customVirtualKeyboards), e.virtualKeyboardTheme && (t.virtualKeyboardTheme = e.virtualKeyboardTheme), e.keypressVibration && (t.keypressVibration = e.keypressVibration), e.keypressSound && (t.keypressSound = e.keypressSound), e.plonkSound && (t.plonkSound = e.plonkSound), e.virtualKeyboardToolbar && (t.virtualKeyboardToolbar = e.virtualKeyboardToolbar), e.targetOrigin && (t.targetOrigin = e.targetOrigin), e.originValidator && (t.originValidator = e.originValidator), t
    }
    let nn, sn;
    class ln {
        get audioContext() {
            return this._audioContext || (this._audioContext = new AudioContext), this._audioContext
        }
        get colorMap() {
            return e => {
                var t;
                let a;
                return "function" == typeof(null === (t = this.options) || void 0 === t ? void 0 : t.colorMap) && (a = this.options.colorMap(e)), a || (a = g(e)), a
            }
        }
        get backgroundColorMap() {
            return e => {
                var t;
                let a;
                return "function" == typeof(null === (t = this.options) || void 0 === t ? void 0 : t.backgroundColorMap) && (a = this.options.backgroundColorMap(e)), a || "function" != typeof this.options.colorMap || (a = this.options.colorMap(e)), a || (a = v(e)), a
            }
        }
        get fractionNavigationOrder() {
            var e, t;
            return null !== (t = null === (e = this.options) || void 0 === e ? void 0 : e.fractionNavigationOrder) && void 0 !== t ? t : "numerator-denominator"
        }
        get placeholderSymbol() {
            var e, t;
            return null !== (t = null === (e = this.options) || void 0 === e ? void 0 : e.placeholderSymbol) && void 0 !== t ? t : "▢"
        }
        get smartFence() {
            var e, t;
            return null !== (t = null === (e = this.options) || void 0 === e ? void 0 : e.smartFence) && void 0 !== t && t
        }
        get letterShapeStyle() {
            var e, t;
            return null !== (t = null === (e = this.options) || void 0 === e ? void 0 : e.letterShapeStyle) && void 0 !== t ? t : "tex"
        }
        get registers() {
            var e, t;
            return null !== (t = null === (e = this.options) || void 0 === e ? void 0 : e.registers) && void 0 !== t ? t : {}
        }
        getDefinition(e, t = "math") {
            return fa(e, t)
        }
        getMacro(e) {
            return ya(e, this.options.macros)
        }
        get virtualKeyboard() {
            if (!this.options.readOnly) return this._virtualKeyboard || (this.options.useSharedVirtualKeyboard || Cn().sharedVirtualKeyboard ? this._virtualKeyboard = new on({
                targetOrigin: this.options.sharedVirtualKeyboardTargetOrigin,
                originValidator: this.options.originValidator,
                mathfield: this
            }) : this._virtualKeyboard = new yr(this.options, this)), this._virtualKeyboard
        }
        get computeEngine() {
            var e, t;
            if (void 0 === this._computeEngine) {
                const t = null === (e = globalThis[Symbol.for("io.cortexjs.compute-engine")]) || void 0 === e ? void 0 : e.ComputeEngine;
                t && (this._computeEngine = new t), this._computeEngine && "," === this.options.decimalSeparator && (this._computeEngine.latexOptions.decimalMarker = "{,}")
            }
            return null !== (t = this._computeEngine) && void 0 !== t ? t : null
        }
        get virtualKeyboardState() {
            var e;
            return (null === (e = this.virtualKeyboard) || void 0 === e ? void 0 : e.visible) ? "visible" : "hidden"
        }
        set virtualKeyboardState(e) {
            this.virtualKeyboard && ("hidden" === e ? this.virtualKeyboard.executeCommand("hideVirtualKeyboard") : "visible" === e && this.virtualKeyboard.executeCommand("showVirtualKeyboard"))
        }
        get keybindings() {
            var e, t;
            if (this._keybindings) return this._keybindings;
            const [a, i] = function(e, t) {
                const a = [],
                    i = [];
                for (const o of e) try {
                    const e = Pi(o, t);
                    if (e) {
                        const i = a.filter((t => t.key === e.key && t.ifMode === e.ifMode));
                        if (i.length > 0) throw new Error(`Ambiguous key binding ${o.key} (${Fi(o.command)}) matches ${i[0].key} (${Fi(i[0].command)}) with the ${t.displayName} keyboard layout`);
                        a.push(e)
                    }
                } catch (e) {
                    e instanceof Error && i.push(e.message)
                }
                return [a, i]
            }(this.options.keybindings, null !== (e = Ki()) && void 0 !== e ? e : Ai);
            return (null === (t = Ki()) || void 0 === t ? void 0 : t.score) > 0 && (this._keybindings = a, i.length), a
        }
        setOptions(e) {
            var t, a;
            if (this.options = go(this.options, e), "computeEngine" in e && (this._computeEngine = this.options.computeEngine), this._computeEngine && "decimalSeparator" in e && (this._computeEngine.latexOptions.decimalMarker = "," === this.options.decimalSeparator ? "{,}" : "."), this.model.setListeners({
                    onSelectionDidChange: e => this._onSelectionDidChange()
                }), this.model.options.macros = this.options.macros, this._keybindings = void 0, ("soundsDirectory" in e || "plonkSound" in e || "keypressSound" in e || "spacebarKeypressSound" in e || "returnKeypressSound" in e || "deleteKeypressSound" in e) && (this.audioBuffers = {}), "inline-math" === this.options.defaultMode ? this.element.classList.add("ML__isInline") : this.element.classList.remove("ML__isInline"), this.options.readOnly ? (this.hasFocus() && "visible" === this.virtualKeyboardState && this.executeCommand("hideVirtualKeyboard"), this.onBlur(), this.element.classList.add("ML__isReadOnly")) : this.element.classList.remove("ML__isReadOnly"), null === (t = this.virtualKeyboard) || void 0 === t || t.setOptions(this.options), this.options.readOnly || "manual" !== this.options.virtualKeyboardMode ? this.virtualKeyboardToggle.classList.remove("is-visible") : this.virtualKeyboardToggle.classList.add("is-visible"), "virtualKeyboardToggleGlyph" in e) {
                const e = null === (a = this.element) || void 0 === a ? void 0 : a.querySelector(".ML__virtual-keyboard-toggle");
                e && (e.innerHTML = this.options.createHTML(this.options.virtualKeyboardToggleGlyph))
            }
            const i = lt.serialize(this.model.root, {
                expandMacro: !1,
                defaultMode: this.options.defaultMode
            });
            ("macros" in e || this.model.getValue() !== i) && Oa.insert("math", this.model, i, {
                insertionMode: "replaceAll",
                selectionMode: "after",
                format: "latex",
                suppressChangeNotifications: !0
            }), no(this)
        }
        getOptions(e) {
            return vo(this.options, e)
        }
        getOption(e) {
            return vo(this.options, e)
        }
        handleEvent(e) {
            if (si(this)) switch (e.type) {
                case "focus":
                    this.onFocus();
                    break;
                case "blur":
                    this.onBlur();
                    break;
                case "touchstart":
                case "mousedown":
                case "pointerdown":
                    ! function(e, t) {
                        var a;
                        e.atomBoundsCache = new Map;
                        const i = e;
                        let r, n = !1,
                            s = "none";
                        if (Zr(t) && t.buttons > 1) return;
                        let l = !1,
                            d = !1;
                        const c = Gr(t) ? t.touches[0].clientX : t.clientX,
                            u = Gr(t) ? t.touches[0].clientY : t.clientY,
                            p = Date.now(),
                            h = i.field,
                            m = setInterval((() => {
                                l ? h.scroll({
                                    top: 0,
                                    left: h.scrollLeft - 16
                                }) : d && h.scroll({
                                    top: 0,
                                    left: h.scrollLeft + 16
                                })
                            }), 32);

                        function f(t) {
                            o() && ("PointerEvent" in window ? (oi(h, "pointermove", y), oi(h, "pointerup pointercancel", f), t instanceof PointerEvent && h.releasePointerCapture(t.pointerId)) : (oi(h, "touchmove", y), oi(h, "touchcancel touchend", f), oi(window, "mousemove", y), oi(window, "mouseup blur", f)), n = !1, clearInterval(m), e.element.classList.remove("tracking"), t && t.preventDefault())
                        }

                        function y(t) {
                            if (!i.hasFocus()) return void f(null);
                            const a = Gr(t) ? t.touches[0].clientX : t.clientX,
                                o = Gr(t) ? t.touches[0].clientY : t.clientY,
                                n = Gr(t) || "touch" === t.pointerType ? 20 : 5;
                            if (Date.now() < p + 500 && Math.abs(c - a) < n && Math.abs(u - o) < n) return t.preventDefault(), void t.stopPropagation();
                            const s = h.getBoundingClientRect();
                            d = a > s.right, l = a < s.left;
                            let m = r;
                            Zr(t) ? t.isPrimary || (m = tn(i, t.clientX, t.clientY, {
                                bias: 0
                            })) : t.touches && 2 === t.touches.length && (m = tn(i, t.touches[1].clientX, t.touches[1].clientY, {
                                bias: 0
                            }));
                            const y = tn(i, a, o, {
                                bias: a <= c ? a === c ? 0 : -1 : 1
                            });
                            m >= 0 && y >= 0 && (i.model.extendSelectionTo(m, y), no(e)), t.preventDefault(), t.stopPropagation()
                        }
                        Ur && Math.abs(Ur.x - c) < 5 && Math.abs(Ur.y - u) < 5 && Date.now() < Ur.time + 500 ? (Xr += 1, Ur.time = p) : (Ur = {
                            x: c,
                            y: u,
                            time: p
                        }, Xr = 1);
                        const b = h.getBoundingClientRect();
                        if (c >= b.left && c <= b.right && u >= b.top && u <= b.bottom) {
                            if (e.hasFocus() || (s = "all", e.focus({
                                    scrollIntoView: !1
                                })), e.flushInlineShortcutBuffer(), e.smartModeSuppressed = !1, r = tn(e, c, u, {
                                    bias: 0
                                }), r >= 0) {
                                if (e.element.classList.add("tracking"), t.shiftKey) {
                                    const t = e.model.selectionIsCollapsed;
                                    e.model.extendSelectionTo(e.model.anchor, r), s = Gi(e.model) || t ? "all" : "selection"
                                } else "placeholder" === e.model.at(r).type ? (e.model.setSelection(r - 1, r), s = "selection") : "placeholder" === (null === (a = e.model.at(r).rightSibling) || void 0 === a ? void 0 : a.type) ? (e.model.setSelection(r, r + 1), s = "selection") : (e.model.position = r, s = Gi(e.model) ? "all" : "selection");
                                e.style = {}, 3 === t.detail || Xr > 2 ? (f(t), 3 !== t.detail && 3 !== Xr || (e.model.selection = {
                                    ranges: [
                                        [0, e.model.lastOffset]
                                    ]
                                }, s = "all")) : n || (n = !0, o() && "PointerEvent" in window ? (ii(h, "pointermove", y), ii(h, "pointerup pointercancel", f), t instanceof PointerEvent && h.setPointerCapture(t.pointerId)) : (ii(window, "blur", f), Gr(t) && t.touches ? (ii(t.target, "touchmove", y), ii(t.target, "touchcancel touchend", f)) : (ii(window, "mousemove", y), ii(window, "mouseup", f))), 2 !== t.detail && 2 !== Xr || (ir(e.model), s = "all"))
                            }
                        } else Ur = null;
                        "none" !== s && (e.model.selectionIsCollapsed && (s = "all"), no(e)), t.preventDefault()
                    }(this, e);
                    break;
                case "resize":
                    this.resizeTimer && cancelAnimationFrame(this.resizeTimer), this.resizeTimer = requestAnimationFrame((() => si(this) && this.onResize()));
                    break;
                case "wheel":
                    this.onWheel(e)
            }
        }
        dispose() {
            if (!si(this)) return;
            const e = this.element;
            delete this.element, delete e.mathfield, e.innerHTML = this.model.getValue(), oi(e, "pointerdown", this), oi(e, "touchstart:active mousedown", this), oi(e, "focus", this), oi(e, "blur", this), oi(window, "resize", this), window.removeEventListener("blur", this, {
                capture: !0
            }), delete this.accessibleNode, delete this.ariaLiveText, delete this.field, delete this.fieldContent, this.virtualKeyboardToggle.remove(), delete this.virtualKeyboardToggle, this._virtualKeyboard && (this._virtualKeyboard.dispose(), delete this._virtualKeyboard), ni(this.popover), Qi && Qi.release(), eo && eo.release(), delete this.popover, ni(this.keystrokeCaption), Er && Er.release(), Or && Or.release(), delete this.keystrokeCaption, this.stylesheets.forEach((e => null == e ? void 0 : e.release()))
        }
        flushInlineShortcutBuffer(e) {
            if (null != e || (e = {
                    defer: !1
                }), !e.defer) return this.inlineShortcutBuffer = [], clearTimeout(this.inlineShortcutBufferFlushTimer), void(this.inlineShortcutBufferFlushTimer = 0);
            this.options.inlineShortcutTimeout > 0 && (clearTimeout(this.inlineShortcutBufferFlushTimer), this.inlineShortcutBufferFlushTimer = setTimeout((() => this.flushInlineShortcutBuffer()), this.options.inlineShortcutTimeout))
        }
        executeCommand(e) {
            var t, a;
            return "virtual-keyboard" === po(e) ? null !== (a = null === (t = this.virtualKeyboard) || void 0 === t ? void 0 : t.executeCommand(e)) && void 0 !== a && a : function(e, t) {
                var a, o, r;
                if (!t) return !1;
                let n, s = [],
                    l = !1,
                    d = !1;
                i(t) ? (n = t[0], s = t.slice(1)) : n = t, n = n.replace(/-\w/g, (e => e[1].toUpperCase()));
                const c = null === (a = co[n]) || void 0 === a ? void 0 : a.target;
                if ("model" === c) {
                    if (e.options.readOnly && /^(paste|cut|insert|delete|transpose|add)/.test(n)) return e.model.announce("plonk"), !1;
                    /^(delete|transpose|add)/.test(n) && "deleteBackward" !== n && e.flushInlineShortcutBuffer(), /^(delete|transpose|add)/.test(n) && "latex" !== e.mode && (e.popUndoStack(), e.snapshot()), "latex" !== e.mode || /^(complete)/.test(n) || Ui(e), co[n].fn(e.model, ...s), "latex" !== e.mode && /^(delete|transpose|add)/.test(n) && e.snapshot(), "latex" === e.mode && Xi(e), d = !0, l = !0
                } else if ("virtual-keyboard" === c) d = null !== (r = null === (o = e.virtualKeyboard) || void 0 === o ? void 0 : o.executeCommand(t)) && void 0 !== r && r, l = !0;
                else {
                    if (!co[n]) throw new Error(`Unknown command "${n}"`);
                    /^(undo|redo)/.test(n) && e.flushInlineShortcutBuffer(), d = co[n].fn(e, ...s), l = !0
                }
                return "virtual-keyboard" !== c && (e.model.selectionIsCollapsed && !/^(transpose|paste|complete|((moveToNextChar|moveToPreviousChar|extend).*))_$/.test(n) || (e.flushInlineShortcutBuffer(), e.style = {})), d && no(e), l
            }(this, e)
        }
        get errors() {
            return Pt(this.model.getValue(), this)
        }
        getValue(e, t, a) {
            return this.model.getValue(e, t, a)
        }
        setValue(e, t) {
            var a;
            void 0 === (t = null != t ? t : {
                mode: "math"
            }).insertionMode && (t.insertionMode = "replaceAll"), void 0 !== t.format && "auto" !== t.format || (t.format = "latex");
            let i = "math";
            void 0 !== t.mode && "auto" !== t.mode || (i = null !== (a = Wo(this.model, this.model.position)) && void 0 !== a ? a : "math"), Oa.insert(i, this.model, e, t) && (this.undoManager.snapshot(), no(this))
        }
        get expression() {
            const e = this.computeEngine;
            return e ? e.box(e.parse(this.model.getValue())) : null
        }
        loadSound(e) {
            var t, a, i, o, r, n, s;
            delete this.audioBuffers[e];
            let l = "";
            switch (e) {
                case "keypress":
                    l = "string" == typeof this.options.keypressSound ? this.options.keypressSound : null === (t = this.options.keypressSound) || void 0 === t ? void 0 : t.default;
                    break;
                case "spacebar":
                    l = "string" == typeof this.options.keypressSound ? this.options.keypressSound : null !== (i = null === (a = this.options.keypressSound) || void 0 === a ? void 0 : a.spacebar) && void 0 !== i ? i : null === (o = this.options.keypressSound) || void 0 === o ? void 0 : o.default;
                    break;
                case "delete":
                    l = "string" == typeof this.options.keypressSound ? this.options.keypressSound : null !== (n = null === (r = this.options.keypressSound) || void 0 === r ? void 0 : r.delete) && void 0 !== n ? n : null === (s = this.options.keypressSound) || void 0 === s ? void 0 : s.default;
                    break;
                case "plonk":
                    l = this.options.plonkSound
            }
            if ("string" != typeof l) return;
            l = l.trim();
            const d = this.options.soundsDirectory;
            null != d && "null" !== d && "none" !== l && "null" !== l && fetch(Co(d + "/" + l)).then((e => e.arrayBuffer())).then((e => this.audioContext.decodeAudioData(e))).then((t => {
                this.audioBuffers[e] = t
            }))
        }
        playSound(e) {
            if (this.audioBuffers[e] || this.loadSound(e), !this.audioBuffers[e]) return;
            const t = this.audioContext.createBufferSource();
            t.buffer = this.audioBuffers[e];
            const a = this.audioContext.createGain();
            a.gain.value = .5, t.connect(a).connect(this.audioContext.destination), t.start()
        }
        scrollIntoView() {
            var e;
            if (!this.element) return;
            null === (e = this.host) || void 0 === e || e.scrollIntoView({
                block: "nearest",
                inline: "nearest"
            }), this.dirty && so(this, {
                interactive: !0
            });
            const t = this.field.getBoundingClientRect();
            let a = null;
            if (this.model.selectionIsCollapsed) a = li(this.field);
            else {
                const e = hi(this);
                if (e.length > 0) {
                    let i = -1 / 0,
                        o = -1 / 0;
                    for (const t of e) t.right > i && (i = t.right), t.top < o && (o = t.top);
                    a = {
                        x: i + t.left - this.field.scrollLeft,
                        y: o + t.top - this.field.scrollTop,
                        height: 0
                    }
                }
            }
            if (this.host && a) {
                const e = this.host.getBoundingClientRect(),
                    t = a.y;
                let i = this.host.scrollTop;
                t < e.top ? i = t - e.top + this.host.scrollTop : t > e.bottom && (i = t - e.bottom + this.host.scrollTop + a.height), this.host.scroll({
                    top: i,
                    left: 0
                })
            }
            if (a) {
                const e = a.x - window.scrollX;
                let i = this.field.scrollLeft;
                e < t.left ? i = e - t.left + this.field.scrollLeft - 20 : e > t.right && (i = e - t.right + this.field.scrollLeft + 20), this.field.scroll({
                    top: this.field.scrollTop,
                    left: i
                })
            }
        }
        insert(e, t) {
            if ("string" == typeof e && e.length > 0) {
                if (this.flushInlineShortcutBuffer(), (t = null != t ? t : {
                        mode: "math"
                    }).focus && this.focus(), t.feedback && (this.options.keypressVibration && s() && navigator.vibrate(3), this.playSound("keypress")), t.scrollIntoView && this.scrollIntoView(), "\\\\" === e) Ro(this.model);
                else if ("&" === e) Io(this.model);
                else {
                    const a = this.style;
                    Oa.insert(this.mode, this.model, e, {
                        style: this.model.at(this.model.position).computedStyle,
                        ...t
                    }), t.resetStyle && (this.style = a)
                }
                return this.undoManager.snapshot(), no(this), !0
            }
            return !1
        }
        switchMode(e, t = "", a = "") {
            var i;
            if (this.mode === e || this.options.readOnly) return;
            if (!(null === (i = this.host) || void 0 === i ? void 0 : i.dispatchEvent(new Event("mode-change", {
                    bubbles: !0,
                    composed: !0,
                    cancelable: !0
                })))) return;
            const o = this.mode,
                {
                    model: r
                } = this;
            r.deferNotifications({
                content: Boolean(a) || Boolean(t),
                selection: !0,
                type: "insertText"
            }, (() => {
                var i;
                let n = !1;
                if (this.flushInlineShortcutBuffer(), this.smartModeSuppressed = /text|math/.test(this.mode) && /text|math/.test(e), t && "latex" !== e) {
                    const a = Nt(t, this, {
                        parseMode: e
                    });
                    r.collapseSelection("forward");
                    const i = r.at(r.position);
                    r.position = r.offsetOf(i.parent.addChildrenAfter(a, i)), n = !0
                }
                if (this.mode = e, "latex" === e) {
                    let e, a = r.selectionIsCollapsed;
                    Zi(this, "accept"), (null === (i = this.virtualKeyboard) || void 0 === i ? void 0 : i.visible) && this.executeCommand(["switchKeyboardLayer", "latex-lower"]);
                    let o = r.at(r.position);
                    if (a) e = "\\";
                    else {
                        const i = Ca(r.selection);
                        e = this.model.getValue(i, "latex");
                        const n = this.model.extractAtoms(i);
                        1 === n.length && n[0] instanceof Bt && (e = t, a = !0), o = r.at(i[0])
                    }
                    const n = new aa(e, this);
                    o.parent.addChildAfter(n, o), a ? r.position = r.offsetOf(n.lastChild) : r.setSelection(r.offsetOf(n.firstChild), r.offsetOf(n.lastChild))
                } else Wi(r).forEach((e => {
                    e.isError = !1
                }));
                if (a) {
                    const e = Nt(a, this, {
                        parseMode: o
                    });
                    r.collapseSelection("forward");
                    const t = r.at(r.position);
                    r.position = r.offsetOf(t.parent.addChildrenAfter(e, t)), n = !0
                }
                return no(this), n
            })), this.mode = e
        }
        hasFocus() {
            return o() && this.keyboardDelegate.hasFocus()
        }
        focus(e) {
            var t;
            this.keyboardDelegate.focus(), this.model.announce("line"), (null === (t = null == e ? void 0 : e.scrollIntoView) || void 0 === t || t) && this.scrollIntoView()
        }
        blur() {
            this.keyboardDelegate.blur()
        }
        select() {
            this.model.selection = {
                ranges: [
                    [0, this.model.lastOffset]
                ]
            }
        }
        applyStyle(e, t = {}) {
            var a, i;
            const o = {
                operation: "set",
                suppressChangeNotifications: !1
            };
            zo(t) ? o.range = t : (o.range = t.range, o.suppressChangeNotifications = null !== (a = t.suppressChangeNotifications) && void 0 !== a && a);
            const r = Jr(this, e),
                n = null !== (i = o.operation) && void 0 !== i ? i : "set";
            this.model.deferNotifications({
                content: !o.suppressChangeNotifications,
                type: "insertText"
            }, (() => {
                void 0 === o.range ? this.model.selection.ranges.forEach((e => Uo(this.model, e, r, {
                    operation: n
                }))) : Uo(this.model, o.range, r, {
                    operation: n
                })
            })), no(this)
        }
        getCaretPoint() {
            const e = li(this.field);
            return e ? {
                x: e.x,
                y: e.y
            } : null
        }
        setCaretPoint(e, t) {
            const a = tn(this, e, t, {
                bias: 0
            });
            if (a < 0) return !1;
            const i = this.model.position;
            return this.model.position = a, this.model.announce("move", i), no(this), !0
        }
        getPlaceholderField(e) {
            var t;
            return null === (t = this.placeholders.get(e)) || void 0 === t ? void 0 : t.field
        }
        attachNestedMathfield() {
            let e = !1;
            const t = this.field.getBoundingClientRect();
            this.placeholders.forEach(((a, i) => {
                var o, r;
                const n = this.field.querySelector(`[data-placeholder-id=${i}]`);
                if (!n) return;
                const s = n.getBoundingClientRect(),
                    l = s.left - t.left + (null !== (o = this.element.offsetLeft) && void 0 !== o ? o : 0);
                (!a.field.style.left || Math.abs(l - parseFloat(a.field.style.left)) >= 1) && (e = !0, a.field.style.left = `${l}px`);
                const d = s.top - t.top + (null !== (r = this.element.offsetTop) && void 0 !== r ? r : 0);
                (!a.field.style.top || Math.abs(d - parseFloat(a.field.style.top)) >= 1) && (e = !0, a.field.style.top = `${d}px`)
            })), e && no(this)
        }
        canUndo() {
            return this.undoManager.canUndo()
        }
        canRedo() {
            return this.undoManager.canRedo()
        }
        popUndoStack() {
            this.undoManager.pop()
        }
        snapshot() {
            var e, t;
            this.undoManager.snapshot() && (null === (e = this.virtualKeyboard) || void 0 === e || e.executeCommand(["onUndoStateChanged", this.canUndo(), this.canRedo()]), null === (t = this.host) || void 0 === t || t.dispatchEvent(new CustomEvent("undo-state-change", {
                bubbles: !0,
                composed: !0,
                detail: {
                    type: "snapshot"
                }
            })))
        }
        snapshotAndCoalesce() {
            var e, t;
            this.undoManager.snapshotAndCoalesce() && (null === (e = this.virtualKeyboard) || void 0 === e || e.executeCommand(["onUndoStateChanged", this.canUndo(), this.canRedo()]), null === (t = this.host) || void 0 === t || t.dispatchEvent(new CustomEvent("undo-state-change", {
                bubbles: !0,
                composed: !0,
                detail: {
                    type: "snapshot"
                }
            })))
        }
        undo() {
            var e, t;
            this.undoManager.undo() && (null === (e = this.virtualKeyboard) || void 0 === e || e.executeCommand(["onUndoStateChanged", this.canUndo(), this.canRedo()]), null === (t = this.host) || void 0 === t || t.dispatchEvent(new CustomEvent("undo-state-change", {
                bubbles: !0,
                composed: !0,
                detail: {
                    type: "undo"
                }
            })))
        }
        redo() {
            var e, t;
            this.undoManager.redo() && (null === (e = this.virtualKeyboard) || void 0 === e || e.executeCommand(["onUndoStateChanged", this.canUndo(), this.canRedo()]), null === (t = this.host) || void 0 === t || t.dispatchEvent(new CustomEvent("undo-state-change", {
                bubbles: !0,
                composed: !0,
                detail: {
                    type: "undo"
                }
            })))
        }
        resetUndo() {
            var e;
            null === (e = this.undoManager) || void 0 === e || e.reset()
        }
        _onSelectionDidChange() {
            var e, t, a;
            this.keyboardDelegate.setValue(this.model.getValue(this.model.selection, "latex-expanded"));
            const i = this.model.getAtoms(this.model.selection);
            if (1 === i.length && "placeholder" === i[0].type) {
                const t = i[0];
                this.model.mathfield.placeholders.has(t.placeholderId) && (null === (e = this.model.mathfield.placeholders.get(t.placeholderId)) || void 0 === e || e.field.focus())
            } {
                const e = this.model.at(this.model.position),
                    a = null !== (t = e.mode) && void 0 !== t ? t : wo(this.options);
                this.mode !== a && ("latex" === this.mode ? (Zi(this, "accept", {
                    mode: a
                }), this.model.position = this.model.offsetOf(e)) : this.switchMode(a))
            }
            null === (a = this.host) || void 0 === a || a.dispatchEvent(new Event("selection-change", {
                bubbles: !0,
                composed: !0
            }))
        }
        onFocus() {
            var e, t, a;
            !this.focusBlurInProgress && this.blurred && (this.focusBlurInProgress = !0, this.blurred = !1, this.keyboardDelegate.focus(), null === (e = this.virtualKeyboard) || void 0 === e || e.setOptions(this.options), null === (t = this.virtualKeyboard) || void 0 === t || t.enable(), "onfocus" === this.options.virtualKeyboardMode && this.executeCommand("showVirtualKeyboard"), ao(this), so(this, {
                interactive: !0
            }), null === (a = this.host) || void 0 === a || a.dispatchEvent(new Event("focus", {
                bubbles: !1,
                composed: !0
            })), this.valueOnFocus = this.model.getValue(), this.focusBlurInProgress = !1)
        }
        onBlur() {
            var e, t;
            this.focusBlurInProgress || this.blurred || (this.focusBlurInProgress = !0, this.blurred = !0, this.ariaLiveText.textContent = "", Zi(this, "accept"), this.model.getValue() !== this.valueOnFocus && this.executeCommand("commit"), /onfocus|manual/.test(this.options.virtualKeyboardMode) && !Cn().sharedVirtualKeyboard && this.executeCommand("hideVirtualKeyboard"), null === (e = this.virtualKeyboard) || void 0 === e || e.disable(), null === (t = this.host) || void 0 === t || t.dispatchEvent(new Event("blur", {
                bubbles: !1,
                composed: !0
            })), no(this), this.focusBlurInProgress = !1)
        }
        onCompositionStart(e) {
            this.model.deleteAtoms(Ca(this.model.selection)), requestAnimationFrame((() => {
                so(this);
                const e = li(this.field);
                e && this.keyboardDelegate.moveTo(e.x, e.y)
            }))
        }
        onCompositionUpdate(e) {
            ! function(e, t) {
                const a = e.at(e.position);
                if ("composition" === a.type) a.value = t;
                else {
                    const {
                        caret: i
                    } = a;
                    a.caret = "";
                    const o = new Jt(t, e.mathfield, {
                        mode: a.mode
                    });
                    o.caret = i, a.parent.addChildAfter(o, a), e.position += 1
                }
            }(this.model, e), no(this)
        }
        onCompositionEnd(e) {
            ! function(e) {
                const t = e.at(e.position);
                "composition" === t.type && (t.parent.removeChild(t), e.position -= 1)
            }(this.model), Hr(this, e, {
                simulateKeystroke: !0
            })
        }
        onResize() {
            ao(this)
        }
        onWheel(e) {
            const t = 5 * e.deltaX;
            if (!Number.isFinite(t) || 0 === t) return;
            const a = this.field;
            t < 0 && 0 === a.scrollLeft || t > 0 && a.offsetWidth + a.scrollLeft >= a.scrollWidth || (a.scrollBy({
                top: 0,
                left: t
            }), e.preventDefault(), e.stopPropagation())
        }
        getHTMLElement(e) {
            let t = e;
            for (; !t.id && t.hasChildren;) t = e.children[0];
            if (t.id) return this.element.querySelector(`[data-atom-id="${t.id}"]`);
            throw new TypeError("Could not get an ID from atom")
        }
        constructor(e, t) {
            var a, i, r;
            this.focusBlurInProgress = !1, this.stylesheets = [], this.audioBuffers = {}, this.options = go({
                ...xo(),
                registers: ha(this)
            }, t.readOnly ? {
                ...t,
                virtualKeyboardMode: "off"
            } : {
                plonkSound: "plonk.wav",
                keypressSound: {
                    spacebar: "keypress-spacebar.wav",
                    return: "keypress-return.wav",
                    delete: "keypress-delete.wav",
                    default: "keypress-standard.wav"
                },
                ...t
            }), "auto" === this.options.virtualKeyboardMode && (this.options.virtualKeyboardMode = n() ? "onfocus" : "off"), void 0 !== this.options.computeEngine && (this._computeEngine = t.computeEngine), t.eventSink && (this.host = t.eventSink), this.placeholders = new Map, this.element = e, e.mathfield = this;
            let s = null !== (a = t.value) && void 0 !== a ? a : this.element.textContent;
            s && (s = s.trim()), null !== this.options.fontsDirectory && Do(this.options.fontsDirectory), nn || (nn = Si(Ii).toString(36)), this.stylesheets.push(Mi(e, Ii, nn)), sn || (sn = Si(Mo).toString(36)), this.stylesheets.push(Mi(e, Mo, sn));
            let l = "<span class=ML__textarea>";
            if (n() ? l += "<span class=ML__textarea__textarea tabindex=-1 role=textbox></span>" : l += `<textarea class=ML__textarea__textarea autocapitalize=off autocomplete=off autocorrect=off spellcheck=false inputmode=none aria-hidden="true" tabindex="${null!==(i=e.tabIndex)&&void 0!==i?i:0}"></textarea>`, l += "</span>", l += '<span part="container" class="ML__container"><span part="content" class="ML__content"></span>', l += `<div part='virtual-keyboard-toggle' class="ML__virtual-keyboard-toggle" role="button" data-ML__tooltip="${u("tooltip.toggle virtual keyboard")}">`, l += null !== (r = this.options.virtualKeyboardToggleGlyph) && void 0 !== r ? r : ko, l += "</div>", l += "<div class='ML__placeholdercontainer'></div>", l += "</span>", l += '<div class="ML__sr-only"><span aria-role="status" aria-live="assertive" aria-atomic="true"></span><span></span></div>', this.element.innerHTML = this.options.createHTML(l), !this.element.children) return;
            let d = 0;
            const c = this.element.children[d++].firstElementChild;
            this.field = this.element.children[d].children[0], d++, this.virtualKeyboardToggle = this.element.querySelector(".ML__virtual-keyboard-toggle"), this.ariaLiveText = this.element.children[d].children[0], this.accessibleNode = this.element.children[d++].children[1], this.keystrokeCaptionVisible = !1, this.popoverVisible = !1, this.suggestionIndex = 0, this.inlineShortcutBuffer = [], this.inlineShortcutBufferFlushTimer = 0, this.mode = wo(this.options), this.smartModeSuppressed = !1, this.style = {}, this.options.readOnly || "manual" !== this.options.virtualKeyboardMode ? this.virtualKeyboardToggle.classList.remove("is-visible") : this.virtualKeyboardToggle.classList.add("is-visible"), this.options.readOnly ? this.element.classList.add("ML__isReadOnly") : this.element.classList.remove("ML__isReadOnly"), "inline-math" === this.options.defaultMode ? this.element.classList.add("ML__isInline") : this.element.classList.remove("ML__isInline"), this.element.querySelector(".ML__content").addEventListener("click", (e => e.stopImmediatePropagation()), {
                capture: !1
            }), this.field.addEventListener("wheel", this, {
                passive: !1
            }), hr((e => this.executeCommand(e)), this.virtualKeyboardToggle, {
                default: "toggleVirtualKeyboard",
                alt: "toggleVirtualKeyboardAlt",
                shift: "toggleVirtualKeyboardShift"
            }), this.blurred = !0, ii(this.element, "focus", this), ii(this.element, "blur", this), this.keyboardDelegate = function(e, t, a) {
                let i, o = null,
                    r = null,
                    n = !1,
                    s = !1,
                    l = !1;

                function d(e) {
                    clearTimeout(i), i = setTimeout((() => {
                        clearTimeout(i), e()
                    }))
                }

                function c() {
                    if (e.selectionStart !== e.selectionEnd) return;
                    const t = e.value;
                    e.value = "", t.length > 0 && a.typedText(t)
                }
                const u = e;
                return u.addEventListener("keydown", (t => {
                    n || "Process" === t.key || "CapsLock" === t.code || /(Control|Meta|Alt|Shift)(Left|Right)/.test(t.code) ? o = null : (o = t, r = null, a.keystroke(lr(t), t) ? "textarea" !== e.tagName.toLowerCase() && (1 === t.key.length && a.typedText(t.key), t.preventDefault()) : (o = null, e.value = ""))
                }), !0), u.addEventListener("keypress", (e => {
                    n || (o && r && a.keystroke(lr(o), o), r = e, d(c))
                }), !0), u.addEventListener("keyup", (() => {
                    n || o && !r && c()
                }), !0), u.addEventListener("paste", (t => {
                    e.focus(), e.value = "", a.paste(t) || t.preventDefault(), t.stopImmediatePropagation()
                }), !0), u.addEventListener("cut", (e => a.cut(e)), !0), u.addEventListener("copy", (e => a.copy(e)), !0), u.addEventListener("blur", (i => {
                    var n, d, c;
                    if ((null === (d = null === (n = i.relatedTarget) || void 0 === n ? void 0 : n._mathfield) || void 0 === d ? void 0 : d.element) === t) return e.focus(), i.preventDefault(), void i.stopPropagation();
                    const u = null === (c = or.scrim) || void 0 === c ? void 0 : c.state;
                    return "open" === u || "opening" === u || i.relatedTarget === i.target.getRootNode().host ? (i.preventDefault(), void i.stopPropagation()) : void(l || s || (l = !0, o = null, r = null, a.blur && a.blur(), l = !1, i.stopPropagation()))
                }), !0), u.addEventListener("focus", (t => {
                    l || s || (s = !0, a.focus && a.focus(), dr() === e && "function" == typeof e.select && e.select(), s = !1, t.stopPropagation())
                }), !0), u.addEventListener("compositionstart", (t => {
                    n = !0, e.value = "", a.compositionStart && a.compositionStart(t.data)
                }), !0), u.addEventListener("compositionupdate", (e => {
                    n && a.compositionUpdate && a.compositionUpdate(e.data)
                }), !0), u.addEventListener("compositionend", (t => {
                    e.value = "", n && (n = !1, a.compositionEnd && a.compositionEnd(t.data))
                }), !0), u.addEventListener("beforeinput", (e => {
                    e.stopImmediatePropagation()
                })), u.addEventListener("input", (e => {
                    if (!n && "insertCompositionText" !== e.inputType) {
                        if ("insertFromPaste" === e.inputType) return e.preventDefault(), void e.stopPropagation();
                        d(c), e.preventDefault(), e.stopPropagation()
                    }
                })), {
                    cancelComposition: () => {
                        const t = a.blur,
                            i = a.focus;
                        a.blur = null, a.focus = null, e.blur(), e.focus(), a.blur = t, a.focus = i
                    },
                    blur: () => {
                        "function" == typeof e.blur && e.blur()
                    },
                    focus: () => {
                        "function" == typeof e.focus && e.focus()
                    },
                    hasFocus: () => dr() === e,
                    setValue: t => {
                        t ? (e.value = t, dr() === e && "function" == typeof e.select && e.select()) : (e.value = "", e.setAttribute("aria-label", ""))
                    },
                    setAriaLabel: t => {
                        e.setAttribute("aria-label", "after: " + t)
                    },
                    moveTo: (t, a) => {
                        e.style.top = `${a}px`, e.style.left = `${t}px`
                    }
                }
            }(c, this.element, {
                typedText: e => Hr(this, e),
                cut: e => {
                    this.options.readOnly ? this.model.announce("plonk") : ji(this.model, {
                        inputType: "deleteByCut"
                    }) && (this.snapshot(), Oa.onCopy(this, e), setTimeout((() => {
                        Ho(this.model, Ca(this.model.selection), "deleteByCut"), no(this)
                    }), 0))
                },
                copy: e => Oa.onCopy(this, e),
                paste: e => {
                    let t = !0;
                    return this.options.readOnly && (t = !1), t && (t = Oa.onPaste(this.model.at(this.model.position).mode, this, e)), t || this.model.announce("plonk"), t
                },
                keystroke: (e, t) => jr(this, e, t),
                focus: () => this.onFocus(),
                blur: () => this.onBlur(),
                compositionStart: e => this.onCompositionStart(e),
                compositionUpdate: e => this.onCompositionUpdate(e),
                compositionEnd: e => this.onCompositionEnd(e)
            }), o() && "PointerEvent" in window ? ii(this.field, "pointerdown", this) : ii(this.field, "touchstart:active mousedown", this), ii(window, "resize", this), window.addEventListener("blur", (() => {
                si(this) && this.hasFocus() && window.addEventListener("focus", (e => {
                    e.target === window && si(this) && this.focus()
                }), {
                    once: !0
                })
            }), {
                capture: !0
            }), this.model = new Oo({
                mode: wo(this.options),
                macros: this.options.macros,
                removeExtraneousParentheses: this.options.removeExtraneousParentheses
            }, {
                onSelectionDidChange: e => this._onSelectionDidChange()
            }, this), this.undoManager = new ur(this.model), s && Oa.insert("math", this.model, s, {
                insertionMode: "replaceAll",
                selectionMode: "after",
                format: "latex",
                suppressChangeNotifications: !0
            }), this.undoManager.startRecording(), this.undoManager.snapshot(), this.model.setListeners({
                onSelectionDidChange: e => this._onSelectionDidChange()
            }), no(this), o() && document.fonts.ready.then((() => so(this)))
        }
    }
    var dn, cn, un, pn;
    const hn = o() ? document.createElement("template") : null;
    hn && (hn.innerHTML = '<style>\n:host { display: block; position: relative; overflow: hidden auto;}\n:host([hidden]) { display: none; }\n:host([disabled]) { opacity:  .5; }\n:host(:focus), :host(:focus-within) {\n  outline: Highlight auto 1px;    /* For Firefox */\n  outline: -webkit-focus-ring-color auto 1px;\n}\n:host([readonly]), :host([read-only]) { outline: none; }\n</style>\n<div></div><slot style="display:none"></slot>');
    const mn = new WeakMap;
    class fn extends HTMLElement {
        static get optionsAttributes() {
            return {
                "default-mode": "string",
                "fonts-directory": "string",
                "sounds-directory": "string",
                "horizontal-spacing-scale": "string",
                "math-mode-space": "string",
                "inline-shortcut-timeout": "string",
                "keypress-vibration": "on/off",
                "keypress-sound": "string",
                "plonk-sound": "string",
                "letter-shape-style": "string",
                locale: "string",
                "read-only": "boolean",
                "remove-extraneous-parentheses": "on/off",
                "smart-fence": "on/off",
                "smart-mode": "on/off",
                "smart-superscript": "on/off",
                "speech-engine": "string",
                "speech-engine-rate": "string",
                "speech-engine-voice": "string",
                "text-to-speech-markup": "string",
                "text-to-speech-rules": "string",
                "virtual-keyboard-layout": "string",
                "virtual-keyboard-mode": "string",
                "virtual-keyboard-theme": "string",
                "virtual-keyboards": "string",
                "use-shared-virtual-keyboard": "boolean",
                "shared-virtual-keyboard-target-origin": "string"
            }
        }
        static get observedAttributes() {
            return [...Object.keys(fn.optionsAttributes), "disabled", "readonly", "read-only"]
        }
        onPointerDown() {
            window.addEventListener("pointerup", (e => {
                e.target === this && this.dispatchEvent(new MouseEvent("click", {
                    altKey: e.altKey,
                    button: e.button,
                    buttons: e.buttons,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    ctrlKey: e.ctrlKey,
                    metaKey: e.metaKey,
                    movementX: e.movementX,
                    movementY: e.movementY,
                    relatedTarget: e.relatedTarget,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    shiftKey: e.shiftKey
                }))
            }), {
                once: !0
            })
        }
        getPlaceholderField(e) {
            var t;
            return null === (t = this._mathfield) || void 0 === t ? void 0 : t.getPlaceholderField(e)
        }
        addEventListener(e, t, a) {
            return super.addEventListener(e, t, a)
        }
        removeEventListener(e, t, a) {
            super.removeEventListener(e, t, a)
        }
        get mode() {
            var e, t;
            return null !== (t = null === (e = this._mathfield) || void 0 === e ? void 0 : e.mode) && void 0 !== t ? t : "math"
        }
        set mode(e) {
            this._mathfield && (this._mathfield.mode = e)
        }
        get computeEngine() {
            if (this._mathfield) return this._mathfield.computeEngine
        }
        set computeEngine(e) {
            this._mathfield && this._mathfield.setOptions({
                computeEngine: e
            })
        }
        get expression() {
            if (this._mathfield) return this._mathfield.expression
        }
        set expression(e) {
            var t, a;
            if (!this._mathfield) return;
            const i = null !== (a = null === (t = this.computeEngine) || void 0 === t ? void 0 : t.box(e).latex) && void 0 !== a ? a : null;
            null !== i && this._mathfield.setValue(i)
        }
        get errors() {
            var e, t;
            return null !== (t = null === (e = this._mathfield) || void 0 === e ? void 0 : e.errors) && void 0 !== t ? t : []
        }
        get placeholders() {
            if (!this._mathfield) return {};
            const e = {};
            for (const [t, a] of this._mathfield.placeholders) e[t] = a.field;
            return e
        }
        getOptions(e) {
            return this._mathfield ? vo(this._mathfield.options, e) : mn.has(this) ? vo(go(xo(), mn.get(this).options), e) : null
        }
        getOption(e) {
            return this.getOptions([e])[e]
        }
        setOptions(e) {
            if (this._mathfield) this._mathfield.setOptions(e), this._mathfield.placeholders.forEach((t => {
                t.field.setOptions({
                    ...e,
                    readOnly: !1
                })
            }));
            else if (mn.has(this)) {
                const t = {
                    ...mn.get(this).options,
                    ...e
                };
                mn.set(this, {
                    ...mn.get(this),
                    selection: {
                        ranges: t.readOnly ? [
                            [0, 0]
                        ] : [
                            [0, -1]
                        ]
                    },
                    options: t
                })
            } else mn.set(this, {
                value: void 0,
                selection: {
                    ranges: [
                        [0, 0]
                    ]
                },
                options: e
            });
            ! function(e) {
                const t = xo(),
                    a = e.getOptions();
                Object.keys(fn.optionsAttributes).forEach((i => {
                    const o = yn(i);
                    "on/off" === fn.optionsAttributes[i] ? t[o] !== a[o] ? e.setAttribute(i, a[o] ? "on" : "off") : e.removeAttribute(i) : t[o] !== a[o] && ("boolean" === fn.optionsAttributes[i] ? a[o] ? e.setAttribute(i, "") : e.removeAttribute(i) : "string" != typeof a[o] && "number" != typeof a[o] || e.setAttribute(i, a[o].toString()))
                }))
            }(this)
        }
        executeCommand(e) {
            var t, a;
            return null !== (a = null === (t = this._mathfield) || void 0 === t ? void 0 : t.executeCommand(e)) && void 0 !== a && a
        }
        getValue(e, t, a) {
            var i, o;
            if (this._mathfield) return this._mathfield.model.getValue(e, t, a);
            if (mn.has(this)) {
                let r, n, s;
                if (Bo(e) ? ([r, n] = e.ranges[0], s = t) : zo(e) ? ([r, n] = e, s = t) : To(e) && To(t) ? (r = e, n = t, s = a) : (r = 0, n = -1, s = e), (void 0 === s || "latex" === s) && 0 === r && -1 === n) return null !== (o = null !== (i = mn.get(this).value) && void 0 !== i ? i : this.textContent) && void 0 !== o ? o : ""
            }
            return ""
        }
        setValue(e, t) {
            if (this._mathfield && void 0 !== e) return t || (t = {
                suppressChangeNotifications: !0
            }), void this._mathfield.setValue(e, t);
            if (mn.has(this)) {
                const t = mn.get(this).options;
                return void mn.set(this, {
                    value: e,
                    selection: {
                        ranges: t.readOnly ? [
                            [0, 0]
                        ] : [
                            [0, -1]
                        ],
                        direction: "forward"
                    },
                    options: t
                })
            }
            const a = bn(this);
            mn.set(this, {
                value: e,
                selection: {
                    ranges: a.readOnly ? [
                        [0, 0]
                    ] : [
                        [0, -1]
                    ],
                    direction: "forward"
                },
                options: a
            })
        }
        hasFocus() {
            var e, t;
            return null !== (t = null === (e = this._mathfield) || void 0 === e ? void 0 : e.hasFocus()) && void 0 !== t && t
        }
        get virtualKeyboardState() {
            var e, t;
            return null !== (t = null === (e = this._mathfield) || void 0 === e ? void 0 : e.virtualKeyboardState) && void 0 !== t ? t : "hidden"
        }
        set virtualKeyboardState(e) {
            this._mathfield && (this._mathfield.virtualKeyboardState = e)
        }
        focus() {
            super.focus()
        }
        blur() {
            var e;
            null === (e = this._mathfield) || void 0 === e || e.blur(), super.blur()
        }
        select() {
            var e;
            null === (e = this._mathfield) || void 0 === e || e.select()
        }
        insert(e, t) {
            var a, i;
            return null !== (i = null === (a = this._mathfield) || void 0 === a ? void 0 : a.insert(e, t)) && void 0 !== i && i
        }
        applyStyle(e, t) {
            var a;
            return null === (a = this._mathfield) || void 0 === a ? void 0 : a.applyStyle(e, t)
        }
        get caretPoint() {
            var e, t;
            return null !== (t = null === (e = this._mathfield) || void 0 === e ? void 0 : e.getCaretPoint()) && void 0 !== t ? t : null
        }
        set caretPoint(e) {
            var t;
            e && (null === (t = this._mathfield) || void 0 === t || t.setCaretPoint(e.x, e.y))
        }
        setCaretPoint(e, t) {
            var a, i;
            return null !== (i = null === (a = this._mathfield) || void 0 === a ? void 0 : a.setCaretPoint(e, t)) && void 0 !== i && i
        }
        offsetFromPoint(e, t, a) {
            return this._mathfield ? tn(this._mathfield, e, t, a) : -1
        }
        hitboxFromOffset(e) {
            if (!this._mathfield) return null;
            const t = this._mathfield.model.at(e);
            if (!t) return null;
            const a = pi(this._mathfield, t);
            return a ? new DOMRect(a.left, a.top, a.right - a.left, a.bottom - a.top) : null
        }
        resetUndo() {
            var e;
            null === (e = this._mathfield) || void 0 === e || e.resetUndo()
        }
        canUndo() {
            return !!this._mathfield && this._mathfield.canUndo()
        }
        canRedo() {
            return !!this._mathfield && this._mathfield.canRedo()
        }
        connectedCallback() {
            var e, t, a;
            this.hasAttribute("role") || this.setAttribute("role", "textbox"), this.setAttribute("dir", "ltr"), this.hasAttribute("aria-label") || this.setAttribute("aria-label", "math input field"), this.setAttribute("contenteditable", "true"), this.setAttribute("aria-multiline", "false"), this.hasAttribute("tabindex") || this.setAttribute("tabindex", "0");
            const i = this.shadowRoot.querySelector("slot:not([name])");
            try {
                this._style = i.assignedElements().filter((e => "style" === e.tagName.toLowerCase())).map((e => e.textContent)).join("")
            } catch (e) {}
            if (this._style) {
                const e = document.createElement("style");
                e.textContent = this._style, this.shadowRoot.appendChild(e)
            }
            try {
                const e = i.assignedElements().filter((e => "script" === e.tagName.toLowerCase() && "application/json" === e.type)).map((e => e.textContent)).join("");
                e && this.setOptions(JSON.parse(e))
            } catch (e) {}
            let o = "";
            if (o = this.hasAttribute("value") ? null !== (e = this.getAttribute("value")) && void 0 !== e ? e : "" : null !== (t = null == i ? void 0 : i.assignedNodes().map((e => 3 === e.nodeType ? e.textContent : "")).join("").trim()) && void 0 !== t ? t : "", this._mathfield = new ln(this.shadowRoot.querySelector(":host > div"), {
                    ...mn.has(this) ? mn.get(this).options : bn(this),
                    eventSink: this,
                    value: o
                }), !mn.has(this)) {
                this.upgradeProperty("disabled"), this.upgradeProperty("readonly");
                for (const e of Object.keys(fn.optionsAttributes)) this.upgradeProperty(yn(e))
            }(null === (a = this._mathfield) || void 0 === a ? void 0 : a.model) ? (mn.has(this) && this._mathfield.model.deferNotifications({
                content: !1,
                selection: !1
            }, (() => {
                const e = mn.get(this).value;
                void 0 !== e && this._mathfield.setValue(e), this._mathfield.model.selection = mn.get(this).selection, mn.delete(this)
            })), i.addEventListener("slotchange", (e => {
                if (e.target !== i) return;
                const t = i.assignedNodes().map((e => 3 === e.nodeType ? e.textContent : "")).join("").trim();
                t !== this._slotValue && (this._mathfield ? this._mathfield.setValue(t) : this.value = t)
            })), this.dispatchEvent(new Event("mount", {
                cancelable: !1,
                bubbles: !0,
                composed: !0
            }))) : this._mathfield = null
        }
        disconnectedCallback() {
            if (this.dispatchEvent(new Event("unmount", {
                    cancelable: !1,
                    bubbles: !0,
                    composed: !0
                })), !this._mathfield) return;
            const e = vo(this._mathfield.options, Object.keys(fn.optionsAttributes).map((e => yn(e))));
            mn.set(this, {
                value: this._mathfield.getValue(),
                selection: this._mathfield.model.selection,
                options: e
            }), this._mathfield.dispose(), this._mathfield = null
        }
        upgradeProperty(e) {
            if (this.hasOwnProperty(e)) {
                const t = this[e];
                delete this[e], "readonly" !== e && "read-only" !== e || (e = "readOnly"), this[e] = t
            }
        }
        attributeChangedCallback(e, t, a) {
            if (t === a) return;
            const i = null !== a;
            switch (e) {
                case "disabled":
                    this.disabled = i;
                    break;
                case "read-only":
                case "readonly":
                    this.readOnly = i
            }
        }
        get readonly() {
            return this.hasAttribute("readonly") || this.hasAttribute("read-only")
        }
        set readonly(e) {
            const t = Boolean(e);
            t ? (this.setAttribute("readonly", ""), this.setAttribute("disabled", ""), this.setAttribute("aria-readonly", "true")) : (this.removeAttribute("readonly"), this.removeAttribute("read-only"), this.removeAttribute("disabled"), this.removeAttribute("aria-readonly")), this.setOptions({
                readOnly: t
            })
        }
        get disabled() {
            return this.hasAttribute("disabled")
        }
        set disabled(e) {
            const t = Boolean(e);
            t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled"), this.setAttribute("aria-disabled", t ? "true" : "false"), this.setOptions({
                readOnly: t
            })
        }
        get value() {
            return this.getValue()
        }
        set value(e) {
            this.setValue(e)
        }
        get defaultMode() {
            return this.getOption("defaultMode")
        }
        set defaultMode(e) {
            this.setOptions({
                defaultMode: e
            })
        }
        get fontsDirectory() {
            return this.getOption("fontsDirectory")
        }
        set fontsDirectory(e) {
            this.setOptions({
                fontsDirectory: e
            })
        }
        get mathModeSpace() {
            return this.getOption("mathModeSpace")
        }
        set mathModeSpace(e) {
            this.setOptions({
                mathModeSpace: e
            })
        }
        get inlineShortcutTimeout() {
            return this.getOption("inlineShortcutTimeout")
        }
        set inlineShortcutTimeout(e) {
            this.setOptions({
                inlineShortcutTimeout: e
            })
        }
        get keypressVibration() {
            return this.getOption("keypressVibration")
        }
        set keypressVibration(e) {
            this.setOptions({
                keypressVibration: e
            })
        }
        get keypressSound() {
            return this.getOption("keypressSound")
        }
        set keypressSound(e) {
            this.setOptions({
                keypressSound: e
            })
        }
        get plonkSound() {
            var e;
            return null !== (e = this.getOption("plonkSound")) && void 0 !== e ? e : null
        }
        set plonkSound(e) {
            this.setOptions({
                plonkSound: e
            })
        }
        get letterShapeStyle() {
            return this.getOption("letterShapeStyle")
        }
        set letterShapeStyle(e) {
            this.setOptions({
                letterShapeStyle: e
            })
        }
        get locale() {
            return this.getOption("locale")
        }
        set locale(e) {
            this.setOptions({
                locale: e
            })
        }
        get readOnly() {
            return this.getOption("readOnly")
        }
        set readOnly(e) {
            this.setOptions({
                readOnly: e
            })
        }
        get removeExtraneousParentheses() {
            return this.getOption("removeExtraneousParentheses")
        }
        set removeExtraneousParentheses(e) {
            this.setOptions({
                removeExtraneousParentheses: e
            })
        }
        get smartFence() {
            return this.getOption("smartFence")
        }
        set smartFence(e) {
            this.setOptions({
                smartFence: e
            })
        }
        get smartMode() {
            return this.getOption("smartMode")
        }
        set smartMode(e) {
            this.setOptions({
                smartMode: e
            })
        }
        get smartSuperscript() {
            return this.getOption("smartSuperscript")
        }
        set smartSuperscript(e) {
            this.setOptions({
                smartSuperscript: e
            })
        }
        get speechEngine() {
            return this.getOption("speechEngine")
        }
        set speechEngine(e) {
            this.setOptions({
                speechEngine: e
            })
        }
        get speechEngineRate() {
            return this.getOption("speechEngineRate")
        }
        set speechEngineRate(e) {
            this.setOptions({
                speechEngineRate: e
            })
        }
        get speechEngineVoice() {
            return this.getOption("speechEngineVoice")
        }
        set speechEngineVoice(e) {
            this.setOptions({
                speechEngineVoice: e
            })
        }
        get textToSpeechMarkup() {
            return this.getOption("textToSpeechMarkup")
        }
        set textToSpeechMarkup(e) {
            this.setOptions({
                textToSpeechMarkup: e
            })
        }
        get textToSpeechRules() {
            return this.getOption("textToSpeechRules")
        }
        set textToSpeechRule(e) {
            this.setOptions({
                textToSpeechRules: e
            })
        }
        get virtualKeyboardLayout() {
            return this.getOption("virtualKeyboardLayout")
        }
        set virtualKeyboardLayout(e) {
            this.setOptions({
                virtualKeyboardLayout: e
            })
        }
        get virtualKeyboardMode() {
            return this.getOption("virtualKeyboardMode")
        }
        set virtualKeyboardMode(e) {
            this.setOptions({
                virtualKeyboardMode: e
            })
        }
        get virtualKeyboardTheme() {
            return this.getOption("virtualKeyboardTheme")
        }
        set virtualKeyboardTheme(e) {
            this.setOptions({
                virtualKeyboardTheme: e
            })
        }
        get virtualKeyboards() {
            return this.getOption("virtualKeyboards")
        }
        set virtualKeyboards(e) {
            this.setOptions({
                virtualKeyboards: e
            })
        }
        get useSharedVirtualKeyboard() {
            return this.getOption("useSharedVirtualKeyboard")
        }
        set useSharedVirtualKeyboard(e) {
            this.setOptions({
                useSharedVirtualKeyboard: e
            })
        }
        get sharedVirtualKeyboardTargetOrigin() {
            return this.getOption("sharedVirtualKeyboardTargetOrigin")
        }
        set sharedVirtualKeyboardTargetOrigin(e) {
            this.setOptions({
                sharedVirtualKeyboardTargetOrigin: e
            })
        }
        get selection() {
            return this._mathfield ? this._mathfield.model.selection : mn.has(this) ? mn.get(this).selection : {
                ranges: [
                    [0, 0]
                ],
                direction: "forward"
            }
        }
        set selection(e) {
            "number" == typeof e && (e = {
                ranges: [
                    [e, e]
                ]
            }), this._mathfield ? this._mathfield.model.selection = e : mn.has(this) ? mn.set(this, {
                ...mn.get(this),
                selection: e
            }) : mn.set(this, {
                value: void 0,
                selection: e,
                options: bn(this)
            })
        }
        get selectionIsCollapsed() {
            const e = this.selection;
            return 1 === e.ranges.length && e.ranges[0][0] === e.ranges[0][1]
        }
        get position() {
            return this._mathfield ? this._mathfield.model.position : mn.has(this) ? mn.get(this).selection.ranges[0][0] : 0
        }
        set position(e) {
            this._mathfield && (this._mathfield.model.position = e), mn.has(this) ? mn.set(this, {
                ...mn.get(this),
                selection: {
                    ranges: [
                        [e, e]
                    ]
                }
            }) : mn.set(this, {
                value: void 0,
                selection: {
                    ranges: [
                        [e, e]
                    ]
                },
                options: bn(this)
            })
        }
        getOffsetDepth(e) {
            var t, a;
            return this._mathfield && (a = (null === (t = this._mathfield.model.at(e)) || void 0 === t ? void 0 : t.treeDepth) - 2, 1) && void 0 !== a ? a : 0
        }
        get lastOffset() {
            var e, t;
            return null !== (t = null === (e = this._mathfield) || void 0 === e ? void 0 : e.model.lastOffset) && void 0 !== t ? t : -1
        }
        constructor(e) {
            r(), super(), this.attachShadow({
                mode: "open"
            }), this.shadowRoot.append(hn.content.cloneNode(!0));
            const t = this.shadowRoot.querySelector("slot:not([name])");
            this._slotValue = t.assignedNodes().map((e => 3 === e.nodeType ? e.textContent : "")).join("").trim(), e && this.setOptions(e), this.shadowRoot.host.addEventListener("pointerdown", (e => this.onPointerDown()), !0), this.shadowRoot.host.addEventListener("focus", (() => {
                var e;
                return null === (e = this._mathfield) || void 0 === e ? void 0 : e.focus()
            }), !0), this.shadowRoot.host.addEventListener("blur", (() => {
                var e;
                return null === (e = this._mathfield) || void 0 === e ? void 0 : e.blur()
            }), !0)
        }
    }

    function yn(e) {
        return e.toLowerCase().replace(/[^a-zA-Z\d]+(.)/g, ((e, t) => t.toUpperCase()))
    }

    function bn(e) {
        const t = {},
            a = fn.optionsAttributes;
        return Object.keys(a).forEach((i => {
            if (e.hasAttribute(i)) {
                const o = e.getAttribute(i);
                "boolean" === a[i] ? t[yn(i)] = !0 : "on/off" === a[i] ? t[yn(i)] = "on" === o || "off" !== o && void 0 : "number" === a[i] ? t[yn(i)] = Number.parseFloat(null != o ? o : "0") : t[yn(i)] = o
            } else "boolean" === a[i] && (t[yn(i)] = !1)
        })), t
    }

    function gn(e, t, a) {
        let i = a,
            o = 0;
        const r = e.length;
        for (; i < t.length;) {
            const a = t[i];
            if (o <= 0 && t.slice(i, i + r) === e) return i;
            "\\" === a ? i++ : "{" === a ? o++ : "}" === a && o--, i++
        }
        return -1
    }

    function vn(e, t, a, i, o = "latex") {
        const r = [];
        for (const n of e)
            if ("text" === n.type) {
                const e = n.data;
                let s, l = !0,
                    d = 0;
                s = e.indexOf(t), -1 !== s && (d = s, d > 0 && r.push({
                    type: "text",
                    data: e.slice(0, d)
                }), l = !1);
                let c = !1;
                for (; !c;) {
                    if (l) {
                        if (s = e.indexOf(t, d), -1 === s) {
                            c = !0;
                            break
                        }
                        d !== s && r.push({
                            type: "text",
                            data: e.slice(d, s)
                        }), d = s
                    } else {
                        if (s = gn(a, e, d + t.length), -1 === s) {
                            c = !0;
                            break
                        }
                        let n = e.slice(d + t.length, s);
                        "ascii-math" === o && ([, n] = Ta(n, {
                            format: "ascii-math"
                        })), r.push({
                            type: "math",
                            data: n,
                            rawData: e.slice(d, s + a.length),
                            mathstyle: i
                        }), d = s + a.length
                    }
                    l = !l
                }
                d < e.length && r.push({
                    type: "text",
                    data: e.slice(d)
                })
            } else r.push(n);
        return r
    }

    function kn(e, t, a) {
        let i = [{
            type: "text",
            data: e
        }];
        return (null == t ? void 0 : t.inline) && t.inline.forEach((([e, t]) => {
            i = vn(i, e, t, "textstyle")
        })), (null == t ? void 0 : t.display) && t.display.forEach((([e, t]) => {
            i = vn(i, e, t, "displaystyle")
        })), (null == a ? void 0 : a.inline) && a.inline.forEach((([e, t]) => {
            i = vn(i, e, t, "textstyle", "ascii-math")
        })), (null == a ? void 0 : a.display) && a.display.forEach((([e, t]) => {
            i = vn(i, e, t, "displaystyle", "ascii-math")
        })), i
    }

    function xn(e, t, a, i) {
        var o;
        const n = function(e, t, a, i) {
                r();
                try {
                    const i = t.renderToMarkup(e, {
                            mathstyle: a,
                            format: "html"
                        }),
                        o = document.createElement("displaystyle" === a ? "div" : "span");
                    return o.setAttribute("aria-hidden", "true"), o.innerHTML = t.createHTML ? t.createHTML(i) : i, o
                } catch (t) {
                    if (i) return document.createTextNode(e)
                }
                return null
            }(e, a, t || "displaystyle", i),
            s = null !== (o = a.renderAccessibleContent) && void 0 !== o ? o : "";
        if (n && /\b(mathml|speakable-text)\b/i.test(s)) {
            r();
            const t = document.createElement("span");
            if (/\bmathml\b/i.test(s) && a.renderToMathML && t.append(function(e, t) {
                    r();
                    const a = document.createElement("span");
                    try {
                        const i = "<math xmlns='http://www.w3.org/1998/Math/MathML'>" + t.renderToMathML(e) + "</math>";
                        a.innerHTML = t.createHTML ? t.createHTML(i) : i
                    } catch (t) {
                        a.textContent = e
                    }
                    return a.className = "ML__sr-only", a
                }(e, a)), /\bspeakable-text\b/i.test(s) && a.renderToSpeakableText) {
                const i = document.createElement("span"),
                    o = a.renderToSpeakableText(e, a);
                i.innerHTML = a.createHTML ? a.createHTML(o) : o, i.className = "ML__sr-only", t.append(i)
            }
            return t.append(n), t
        }
        return n
    }

    function wn(e, t) {
        var a, i, o;
        r();
        let n = null;
        if ((null === (a = t.TeX) || void 0 === a ? void 0 : a.processEnvironments) && /^\s*\\begin/.test(e)) {
            n = document.createDocumentFragment();
            const a = xn(e, "", t, !0);
            a && n.appendChild(a)
        } else {
            if (!e.trim()) return null;
            const a = kn(e, null === (i = t.TeX) || void 0 === i ? void 0 : i.delimiters, null === (o = t.asciiMath) || void 0 === o ? void 0 : o.delimiters);
            if (1 === a.length && "text" === a[0].type) return null;
            n = document.createDocumentFragment();
            for (const e of a)
                if ("text" === e.type) n.appendChild(document.createTextNode(e.data));
                else {
                    const a = xn(e.data, "textstyle" === e.mathstyle ? "textstyle" : "displaystyle", t, !0);
                    a && n.appendChild(a)
                }
        }
        return n
    }

    function _n(e, t) {
        var a, i, o, r, n, s, l, d, c, u, p, h, m, f, y, b;
        if (1 === e.childNodes.length && 3 === e.childNodes[0].nodeType) {
            const n = null !== (a = e.childNodes[0].textContent) && void 0 !== a ? a : "";
            if ((null === (i = t.TeX) || void 0 === i ? void 0 : i.processEnvironments) && /^\s*\\begin/.test(n)) {
                e.textContent = "";
                const a = xn(n, "", t, !0);
                return void(a && e.append(a))
            }
            const s = kn(n, null === (o = t.TeX) || void 0 === o ? void 0 : o.delimiters, null === (r = t.asciiMath) || void 0 === r ? void 0 : r.delimiters);
            if (1 === s.length && "math" === s[0].type) {
                e.textContent = "";
                const a = xn(s[0].data, "textstyle" === s[0].mathstyle ? "textstyle" : "displaystyle", t, !0);
                return void(a && e.append(a))
            }
            if (1 === s.length && "text" === s[0].type) return
        }
        for (let a = e.childNodes.length - 1; a >= 0; a--) {
            const i = e.childNodes[a];
            if (3 === i.nodeType) {
                const e = wn(null !== (n = i.textContent) && void 0 !== n ? n : "", t);
                e && (a += e.childNodes.length - 1, i.replaceWith(e))
            } else if (1 === i.nodeType) {
                const a = i,
                    o = i.nodeName.toLowerCase();
                if ("script" === o) {
                    const a = i;
                    let o;
                    if (null === (s = t.processScriptTypePattern) || void 0 === s ? void 0 : s.test(a.type)) o = null !== (l = a.textContent) && void 0 !== l ? l : "";
                    else if (null === (d = t.processMathJSONScriptTypePattern) || void 0 === d ? void 0 : d.test(a.type)) try {
                        o = null === (c = t.serializeToLatex) || void 0 === c ? void 0 : c.call(t, JSON.parse(null !== (u = a.textContent) && void 0 !== u ? u : ""))
                    } catch (e) {}
                    if (o) {
                        let e = "displaystyle";
                        for (const t of a.type.split(";")) {
                            const [a, i] = t.toLowerCase().split("=");
                            "mode" === a.trim() && (e = "display" === i.trim() ? "displaystyle" : "textstyle")
                        }
                        const i = xn(o, e, t, !0);
                        i && a.parentNode.replaceChild(i, a)
                    }
                } else if (null !== (h = null === (p = t.processClassPattern) || void 0 === p ? void 0 : p.test(a.className)) && void 0 !== h && h || !(null !== (f = null === (m = t.skipTags) || void 0 === m ? void 0 : m.includes(o)) && void 0 !== f && f || null !== (b = null === (y = t.ignoreClassPattern) || void 0 === y ? void 0 : y.test(a.className)) && void 0 !== b && b))
                    if (1 === e.childNodes.length && 3 === e.childNodes[0].nodeType) {
                        const a = e.textContent;
                        e.textContent = "";
                        const i = xn(null != a ? a : "", "displaystyle", t, !0);
                        i && e.append(i)
                    } else _n(a, t)
            }
        }
    }
    o() && !(null === (dn = window.customElements) || void 0 === dn ? void 0 : dn.get("math-field")) && (null !== (cn = globalThis[pn = Symbol.for("io.cortexjs.mathlive")]) && void 0 !== cn || (globalThis[pn] = {}), globalThis[Symbol.for("io.cortexjs.mathlive")].version = "0.86.0", window.MathfieldElement = fn, null === (un = window.customElements) || void 0 === un || un.define("math-field", fn));
    const Sn = {
        skipTags: ["math-field", "noscript", "style", "textarea", "pre", "code", "annotation", "annotation-xml"],
        processScriptType: "math/tex",
        processMathJSONScriptType: "math/json",
        ignoreClass: "tex2jax_ignore",
        processClass: "tex2jax_process",
        renderAccessibleContent: "mathml",
        asciiMath: {
            delimiters: {
                display: [
                    ["`", "`"]
                ]
            }
        },
        TeX: {
            processEnvironments: !0,
            delimiters: {
                inline: [
                    ["\\(", "\\)"]
                ],
                display: [
                    ["$$", "$$"],
                    ["\\[", "\\]"]
                ]
            }
        }
    };

    function Mn(e, t) {
        var a, i, o, r;
        try {
            const n = {
                ...Sn,
                ...t
            };
            n.ignoreClassPattern = new RegExp(null !== (a = n.ignoreClass) && void 0 !== a ? a : ""), n.processClassPattern = new RegExp(null !== (i = n.processClass) && void 0 !== i ? i : ""), n.processScriptTypePattern = new RegExp(null !== (o = n.processScriptType) && void 0 !== o ? o : ""), n.processMathJSONScriptTypePattern = new RegExp(null !== (r = n.processMathJSONScriptType) && void 0 !== r ? r : ""), null !== n.fontsDirectory && Do(n.fontsDirectory), Mi(null, Ii, Si(Ii).toString(36)), _n(e, n)
        } catch (e) {
            Error
        }
    }

    function Ln(e, t, a = 3e3, i = "$0") {
        for (const o of t) _[o] && (_[o].frequency = a, _[o].category = e, _[o].template = i.replace(/\$0/g, o)), M[o] && (M[o] = {
            ...M[o],
            frequency: a,
            category: e,
            template: i.replace(/\$0/g, o)
        })
    }

    function Cn() {
        var e, t;
        return null !== (e = globalThis[t = Symbol.for("io.cortexjs.mathlive")]) && void 0 !== e || (globalThis[t] = {}), globalThis[Symbol.for("io.cortexjs.mathlive")]
    }

    function An(e, t) {
        var a;
        (t = null != t ? t : {}).mathstyle = null !== (a = t.mathstyle) && void 0 !== a ? a : "displaystyle";
        const i = ma(),
            o = new lt("root", i);
        o.body = Nt(e, i, {
            parseMode: "math",
            mathstyle: t.mathstyle
        });
        const r = o.render(new Ae({
            registers: i.registers,
            renderPlaceholder: () => new Ne(160, {
                maxFontSize: 1
            })
        }, {
            fontSize: 5,
            letterShapeStyle: i.letterShapeStyle
        }, t.mathstyle));
        return r ? (Ve(r), Fe(r), je(r, {
            classes: "ML__mathlive"
        }).toMarkup()) : ""
    }

    function Dn(e, t = {}) {
        return Ua(Nt(e, ma(), {
            parseMode: "math",
            args: () => "",
            mathstyle: "displaystyle"
        }), t)
    }

    function Tn(e, t = {}) {
        return ai(Nt(e, ma(), {
            parseMode: "math",
            mathstyle: "displaystyle"
        }), t)
    }
    let zn;

    function Bn(e) {
        var t, a;
        if (!zn) {
            const e = null === (t = globalThis[Symbol.for("io.cortexjs.compute-engine")]) || void 0 === t ? void 0 : t.ComputeEngine;
            e && (zn = new e)
        }
        return null !== (a = null == zn ? void 0 : zn.box(e).latex) && void 0 !== a ? a : ""
    }

    function Kn(e, t) {
        var a, i, r, n;
        const s = function(e) {
            if ("string" == typeof e && o()) {
                const t = document.getElementById(e);
                if (null === t) throw new Error(`The element with ID "${e}" could not be found.`);
                return t
            }
            return "string" == typeof e ? null : e
        }(e);
        if (!s) return;
        const l = null != t ? t : {};
        null !== (a = l.renderToMarkup) && void 0 !== a || (l.renderToMarkup = An), null !== (i = l.renderToMathML) && void 0 !== i || (l.renderToMathML = Dn), null !== (r = l.renderToSpeakableText) && void 0 !== r || (l.renderToSpeakableText = Tn), null !== (n = l.serializeToLatex) && void 0 !== n || (l.serializeToLatex = Bn), Mn(s, l)
    }
    Ln("Trigonometry", ["\\cos", "\\sin", "\\tan"], 4e3), Ln("Trigonometry", ["\\arccos", "\\arcsin", "\\arctan", "\\arctg", "\\arcctg", "\\arcsec", "\\arccsc", "\\arsinh", "\\arcosh", "\\artanh", "\\arcsech", "\\arccsch", "\\arg", "\\ch", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\lg", "\\lb", "\\sec", "\\sinh", "\\sh", "\\tanh", "\\tg", "\\th"], 2e3), Ln("Functions", ["\\ln", "\\log", "\\exp", "\\lim"], 4e3), Ln("Functions", ["\\dim", "\\ker", "\\deg", "\\det", "\\mod", "\\min", "\\max"], 3e3), Ln("Functions", ["\\hom"], 1200), Ln("Decoration", ["\\rule"], 200, "$0{2em}{1em}"), Ln("Decoration", ["\\color", "\\textcolor"], 200, "{$0{m0}A}{$0{m1}B}{$0{m2}C }{$0{m3}a}{$0{m4}b}{$0{m5}c}{$0{m6}8}"), Ln("Decoration", ["\\overline", "\\underline"], 3e3, "$0{\\placeholder{}}"), Ln("Decoration", ["\\enclose"], 1200, '\\enclose{updiagonalstrike,roundedbox}[1px solid red, mathbackground="#fbc0bd"]{x=0}'), Ln("Decoration", ["\\fcolorbox"], 1200, '\\fcolorbox{#cd0030}{#ffd400}{\\unicode{"2B1A}}'), Ln("Decoration", ["\\colorbox"], 1200, '\\colorbox{#fbc0bd}{\\unicode{"2B1A}}'), Ln("Decoration", ["\\boxed", "\\cancel", "\\bcancel", "\\xcancel"], 1200, "$0{\\placeholder{}}"), Ln("Decoration", ["\\bbox"], 1200, '\\bbox[#ffd400, solid 2px #ffd400]{\\unicode{"2B1A}}'), Ln("Styling", ["\\mathbb"], 4e3, "$0{Don Knuth}"), Ln("Styling", ["\\textbf", "\\textup", "\\textit", "\\textrm", "\\textsf", "\\texttt", "\\textnormal", "\\textmd", "\\textsl", "\\textsc", "\\mathsf", "\\mathtt", "\\mathrm", "\\mathfrak", "\\mathcal", "\\mathscr", "\\mathbf", "\\mathmd", "\\mathit", "\\text", "\\mbox", "\\Bbb", "\\bold", "\\bm", "\\boldsymbol"], 3e3, "$0{Don Knuth}"), Ln("Styling", ["\\frak", "\\tt", "\\bf", "\\it", "\\rmfamily", "\\sffamily", "\\ttfamily", "\\class", "\\cssId", "\\htmlData", "\\htmlStyle"], 1200, "{$0 Don Knuth}"), Ln("Styling", ["\\bfseries", "\\mdseries", "\\upshape", "\\slshape", "\\scshape"], 1200, "\\text{$0 Don Knuth}"), Ln("Styling", ["\\class", "\\cssId"], 1200, "$0{testIdentifier}{Don Knuth}"), Ln("Styling", ["\\fontseries"], 1200, "\\text{$0{b}Don Knuth}"), Ln("Styling", ["\\fontfamily"], 1200, "\\text{$0{cmtt}Don Knuth}"), Ln("Styling", ["\\fontshape"], 1200, "\\text{$0{sc}Don Knuth}"), Ln("Styling", ["\\selectfont"], 1200, "\\text{$0}"), Ln("Styling", ["\\emph"], 1200, "Don$0{Knuth}"), Ln("Styling", ["\\em"], 1200, "Don{$0 Knuth}"), Ln("Layout", ["\\mathop", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathord", "\\mathinner", "\\operatorname", "\\operatorname*"], 1200, "x=$0{arg}=0"), Ln("Layout", ["\\middle"], 1200, "\\left\\{x$0|x>0\\right\\}"), Ln("Layout", ["\\overset", "\\underset", "\\stackrel", "\\stackbin"], 1200, "$0{arg}{x=0}"), Ln("Layout", ["\\rlap", "\\mathrlap"], 1200, "$0{/}0"), Ln("Layout", ["\\llap", "\\mathllap"], 1200, "o$0{/}"), Ln("Fractions", ["\\frac"], 4e3, "$0{\\placeholder{}}{\\placeholder{}}"), Ln("Fractions", ["\\binom", "\\dfrac", "\\tfrac", "\\dbinom", "\\tbinom", "\\pdiff", "\\cfrac"], 1200, "$0{\\placeholder{}}{\\placeholder{}}"), Ln("Fractions", ["\\over", "\\atop", "\\choose"], 1200, '\\unicode{"2B1A} $0 \\unicode{"2B1A}'), Ln("Fractions", ["\\overwithdelims", "\\atopwithdelims"], 1200, '{\\unicode{"2B1A} $0{\\lbrace}{\\rbrace} \\unicode{"2B1A}}'), Ln("Extensible Operators", ["\\sum", "\\prod", "\\bigcap", "\\bigcup", "\\int"], 4e3), Ln("Extensible Operators", ["\\bigoplus", "\\smallint", "\\iint", "\\oint"], 3e3), Ln("Extensible Operators", ["\\bigwedge", "\\bigvee", "\\coprod", "\\bigsqcup", "\\bigotimes", "\\bigodot", "\\biguplus", "\\intop", "\\sqcup", "\\sqcap", "\\uplus", "\\wr", "\\Cap", "\\Cup", "\\doublecap", "\\doublecup", "\\amalg", "\\iiint", "\\oiint", "\\oiiint", "\\intclockwise", "\\varointclockwise", "\\ointctrclockwise", "\\intctrclockwise"], 1200), Ln("Accents", ["\\vec"], 4e3), Ln("Accents", ["\\bar", "\\ddot", "\\acute", "\\tilde", "\\check"], 3e3, "$0{\\placeholder{}}"), Ln("Accents", ["\\^", "\\`", "\\'"], 1200, "$0{e}"), Ln("Accents", ["\\c"], 1200, "$0{c}"), Ln("Accents", ["\\~"], 1200, "$0{n}"), Ln("Accents", ["\\mathring", "\\hat", "\\dot", "\\breve", "\\grave"], 1200, "$0{\\placeholder{}}"), Ln("Extensible Symbols", ["\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftharpoon", "\\overrightharpoon", "\\overleftrightarrow", "\\overbrace", "\\overlinesegment", "\\overgroup", "\\widehat", "\\widecheck", "\\widetilde"], 3e3, "$0{ABC}"), Ln("Extensible Symbols", ["\\underrightarrow", "\\underleftarrow", "\\underleftrightarrow", "\\underbrace", "\\underlinesegment", "\\undergroup", "\\utilde"], 3e3, "$0{ABC}"), Ln("Sizing", ["\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], 1200, "$0{x=0}"), Ln("Sizing", ["\\big", "\\Big", "\\bigg", "\\Bigg"], 1200, "$0($0)"), Ln("Sizing", ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl"], 1200, "$0("), Ln("Sizing", ["\\bigr", "\\Bigr", "\\biggr", "\\Biggr"], 1200, "$0)"), Ln("Sizing", ["\\bigm", "\\Bigm", "\\biggm", "\\Biggm"], 1200, "$0|"), Ln("Letterlike Symbols", ["\\nabla", "\\partial", "\\N", "\\R", "\\Q", "\\C", "\\Z", "\\exponentialE", "\\forall", "\\exists", "\\nexists"], 4e3), Ln("Letterlike Symbols", ["\\doubleStruckCapitalP", "\\P", "\\ell", "\\hbar", "\\hslash", "\\imath", "\\jmath", "\\imaginaryI", "\\imaginaryJ", "\\differentialD", "\\rd", "\\capitalDifferentialD", "\\doubleStruckCapitalN", "\\doubleStruckCapitalR", "\\doubleStruckCapitalQ", "\\doubleStruckCapitalC", "\\doubleStruckCapitalZ", "\\rD", "\\differencedelta", "\\mid", "@", "\\Re", "\\Im", "\\$", "\\%", "\\And", "\\degree"], 3e3), Ln("Letterlike Symbols", ["\\top", "\\bot", "\\scriptCapitalE", "\\scriptCapitalH", "\\scriptCapitalL", "\\gothicCapitalC", "\\gothicCapitalH", "\\gothicCapitalI", "\\gothicCapitalR", "\\Bbbk", "\\Finv", "\\Game", "\\wp", "\\eth", "\\mho", "\\pounds", "\\yen", "\\euro"], 1200), Ln("Crosses", ["\\dagger", "\\dag"], 4e3), Ln("Crosses", ["\\ddag", "\\ddagger", "\\maltese", "\\textdagger", "\\textdaggerdbl"], 1200), Ln("Various", ["\\checkmark", "\\diagup", "\\diagdown", "\\angle", "\\measuredangle", "\\sphericalangle", "\\prime", "\\doubleprime", "\\backprime", "\\backdoubleprime", "\\sharp", "\\flat", "\\natural", "\\&", "\\#", "\\clubsuit", "\\spadesuit", "\\diamondsuit", "\\heartsuit", "\\backslash", "\\infty", "/", "\\_", "\\/", "|", "'"], 1200), Ln("Various", ["\\unicode"], 1200, '$0{"2B1A}'), Ln("Arrows", ["\\longrightarrow", "\\rightarrow", "\\Longrightarrow", "\\Rightarrow"], 4e3), Ln("Arrows", ["\\longmapsto", "\\mapsto", "\\Longleftrightarrow", "\\rightleftarrows", "\\leftarrow", "\\curvearrowleft", "\\uparrow", "\\downarrow", "\\hookrightarrow", "\\rightharpoonup", "\\rightleftharpoons"], 3e3), Ln("Arrows", ["\\Leftarrow", "\\longleftrightarrow", "\\longleftarrow", "\\Longleftarrow", "\\searrow", "\\nearrow", "\\swarrow", "\\nwarrow", "\\Uparrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "\\hookleftarrow", "\\leftharpoonup", "\\leftharpoondown", "\\rightharpoondown", "\\leftrightarrows", "\\dashrightarrow", "\\dashleftarrow", "\\leftleftarrows", "\\Lleftarrow", "\\twoheadleftarrow", "\\leftarrowtail", "\\looparrowleft", "\\leftrightharpoons", "\\circlearrowleft", "\\Lsh", "\\upuparrows", "\\downharpoonleft", "\\multimap", "\\leftrightsquigarrow", "\\twoheadrightarrow", "\\rightarrowtail", "\\looparrowright", "\\curvearrowright", "\\circlearrowright", "\\Rsh", "\\downdownarrows", "\\upharpoonright", "\\downharpoonright", "\\rightsquigarrow", "\\leadsto", "\\Rrightarrow", "\\restriction"], 1200), Ln("Arrows", ["\\upharpoonleft", "\\rightrightarrows"], 0), Ln("Negated Arrows", ["\\nrightarrow", "\\nRightarrow", "\\nleftrightarrow", "\\nLeftrightarrow", "\\nleftarrow", "\\nLeftarrow"], 1200), Ln("Extensible Symbols", ["\\xrightarrow", "\\xleftarrow", "\\xRightarrow", "\\xLeftarrow", "\\xleftharpoonup", "\\xleftharpoondown", "\\xrightharpoonup", "\\xrightharpoondown", "\\xlongequal", "\\xtwoheadleftarrow", "\\xtwoheadrightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xtofrom", "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium"], 1200, "$0[below]{above}=0"), Ln("Negated Relations", ["\\nless", "\\nleqslant", "\\lneq", "\\lneqq", "\\nleqq", "\\unlhd", "\\unrhd", "\\lvertneqq", "\\lnsim", "\\lnapprox", "\\nprec", "\\npreceq", "\\precnsim", "\\precnapprox", "\\nsim", "\\nshortmid", "\\nmid", "\\nvdash", "\\nvDash", "\\ngtr", "\\ngeqslant", "\\ngeqq", "\\gneq", "\\gneqq", "\\gvertneqq", "\\gnsim", "\\nsucc", "\\succnsim", "\\ncong", "\\nshortparallel", "\\nparallel", "\\nVDash", "\\nVdash", "\\precneqq", "\\succneqq", "\\gnapprox", "\\succnapprox", "\\nsucceq"], 1200), Ln("Hebrew", ["\\aleph", "\\beth", "\\daleth", "\\gimel"], 1200), Ln("Fences", ["\\lbrace", "\\rbrace", "\\vert", "\\Vert", "\\{", "\\}", "(", ")", "[", "]"], 4e3), Ln("Fences", ["\\langle", "\\rangle", "\\lfloor", "\\rfloor", "\\lceil", "\\rceil", "\\mvert", "\\|", "\\mVert"], 3e3), Ln("Fences", ["\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lbrack", "\\rbrack", "\\ulcorner", "\\urcorner", "\\llcorner", "\\lrcorner", "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache"], 1200), Ln("Relations", ["=", "\\ne", "\\neq", "<", ">", "\\leqslant", "\\geqslant", "\\approx"], 4e3), Ln("Relations", ["\\lt", "\\gt", "\\le", "\\ge", "\\leq", "\\geq", "\\gg", "\\cong", "\\equiv", "\\prec", "\\preceq", "\\succ", "\\perp", "\\parallel", "\\propto", "\\smile", "\\frown", "\\sim", "\\gtrsim"], 3e3), Ln("Relations", ["\\coloneq", "\\succeq", "\\approxeq", "\\thickapprox", "\\lessapprox", "\\gtrapprox", "\\precapprox", "\\succapprox", "\\thicksim", "\\succsim", "\\precsim", "\\backsim", "\\eqsim", "\\backsimeq", "\\simeq", "\\lesssim", "\\nleq", "\\ngeq", "\\smallsmile", "\\smallfrown", "\\bowtie", "\\asymp", "\\leqq", "\\eqslantless", "\\ll", "\\lll", "\\lessgtr", "\\lesseqgtr", "\\lesseqqgtr", "\\risingdotseq", "\\fallingdotseq", "\\preccurlyeq", "\\curlyeqprec", "\\vDash", "\\Vvdash", "\\bumpeq", "\\Bumpeq", "\\geqq", "\\eqslantgtr", "\\ggg", "\\gtrless", "\\gtreqless", "\\gtreqqless", "\\succcurlyeq", "\\curlyeqsucc", "\\Vdash", "\\shortmid", "\\shortparallel", "\\between", "\\pitchfork", "\\varpropto", "\\backepsilon", "\\llless", "\\gggtr", "\\lhd", "\\rhd", "\\Join", "\\doteq", "\\doteqdot", "\\Doteq", "\\eqcirc", "\\circeq", "\\lessdot", "\\gtrdot", "\\measeq", "\\eqdef", "\\questeq"], 1200), Ln("Logic", ["\\leftrightarrow", "\\Leftrightarrow", "\\to"], 4e3), Ln("Logic", ["\\models", "\\vdash"], 3e3), Ln("Logic", ["\\therefore", "\\because", "\\implies", "\\gets", "\\dashv", "\\impliedby", "\\biconditional", "\\roundimplies"], 1200), Ln("Operators", ["+", "-", "*", "\\cdot"], 4e3), Ln("Operators", ["\\sqrt"], 4e3, "$0{\\placeholder{}}"), Ln("Operators", ["\\pm", "\\mp", "\\times", "\\div", "\\surd"], 3e3), Ln("Operators", ["\\ltimes", "\\rtimes", "\\leftthreetimes", "\\rightthreetimes", "\\intercal", "\\dotplus", "\\centerdot", "\\doublebarwedge", "\\divideontimes", "\\divides"], 1200), Ln("Logic", ["\\wedge", "\\vee", "\\neg"], 4e3), Ln("Logic", ["\\lnot"], 3e3), Ln("Logic", ["\\land", "\\lor", "\\barwedge", "\\veebar", "\\nor", "\\curlywedge", "\\curlyvee"], 1200), Ln("Greek", ["\\alpha", "\\beta", "\\gamma", "\\delta", "\\epsilon", "\\varepsilon", "\\zeta", "\\eta", "\\theta", "\\vartheta", "\\iota", "\\kappa", "\\varkappa", "\\lambda", "\\mu", "\\nu", "\\xi", "\\pi", "\\varpi", "\\rho", "\\varrho", "\\sigma", "\\varsigma", "\\tau", "\\phi", "\\varphi", "\\upsilon", "\\chi", "\\psi", "\\omega", "\\Gamma", "\\Delta", "\\Theta", "\\Lambda", "\\Xi", "\\Pi", "\\Sigma", "\\Upsilon", "\\Phi", "\\Psi", "\\Omega", "\\digamma", "\\omicron"], 3e3), Ln("Sets", ["\\emptyset", "\\varnothing", "\\cap", "\\cup", "\\in", "\\notin", "\\subset", "\\supset", "\\subseteq", "\\supseteq", "\\sqsubseteq"], 4e3), Ln("Sets", ["\\setminus", "\\not", "\\ni", "\\sqsupseteq", "\\nsupseteqq", "\\supsetneq", "\\varsupsetneq", "\\supsetneqq", "\\varsupsetneqq"], 3e3), Ln("Sets", ["\\smallsetminus", "\\complement", "\\owns", "\\subsetneq", "\\varsubsetneq", "\\subsetneqq", "\\varsubsetneqq", "\\nsubset", "\\nsupset", "\\nsubseteq", "\\nsupseteq", "\\nsubseteqq", "\\subseteqq", "\\Subset", "\\sqsubset", "\\supseteqq", "\\Supset", "\\sqsupset"], 1200), Ln("Spacing", ["\\space", "\\quad", "\\qquad"], 3e3, '\\unicode{"203A}$0\\unicode{"2039}'), Ln("Spacing", ["\\!", "\\,", "\\:", "\\;", "\\enskip", "\\enspace"], 1200, '\\unicode{"203A}$0\\unicode{"2039}'), Ln("Spacing", ["\\hspace", "\\hspace*"], 1200, '\\unicode{"203A}$0{1em}\\unicode{"2039}'), Ln("Punctuation", ["\\colon", "\\cdotp", "\\ldots", "\\cdots", "\\ddots", "\\vdots", "?", "!", ":", '"', ",", ".", ";"], 3e3), Ln("Punctuation", ["\\mathellipsis", "\\ldotp", "\\Colon"], 1200), Ln("Boxes", ["\\square", "\\Box"], 3e3), Ln("Boxes", ["\\blacksquare", "\\boxminus", "\\boxplus", "\\boxtimes", "\\boxdot"], 1200), Ln("Circles", ["\\circ", "\\bullet", "\\circleddash", "\\oplus", "\\otimes"], 3e3), Ln("Circles", ["\\bigcirc", "\\circledast", "\\ominus", "\\circledcirc", "\\oslash", "\\circledS", "\\circledR", "\\odot"], 1200), Ln("Triangles", ["\\triangle", "\\triangleq"], 3e3), Ln("Triangles", ["\\bigtriangleup", "\\vartriangle", "\\triangledown", "\\bigtriangledown", "\\triangleleft", "\\vartriangleleft", "\\trianglelefteq", "\\ntriangleleft", "\\ntrianglelefteq", "\\triangleright", "\\vartriangleright", "\\trianglerighteq", "\\ntriangleright", "\\ntrianglerighteq", "\\blacktriangle", "\\blacktriangledown", "\\blacktriangleleft", "\\blacktriangleright"], 1200), Ln("Shapes", ["\\ast", "\\star"], 3e3), Ln("Shapes", ["\\diamond", "\\Diamond", "\\lozenge", "\\blacklozenge", "\\bigstar"], 1200)
}));